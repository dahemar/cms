<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <!-- CSP is set via HTTP headers in vercel.json, not via meta tag to avoid conflicts -->
    <title>Admin Panel - CMS</title>
    <!-- Quill Editor CSS -->
    <link href="https://cdn.quilljs.com/1.3.6/quill.snow.css" rel="stylesheet">
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
        background: #ffffff;
        padding: 0;
        color: #000000;
        line-height: 1.6;
      }

      .container {
        max-width: 1200px;
        margin: 0 auto;
        background: #ffffff;
        padding: 40px;
      }

      h1 {
        margin-bottom: 40px;
        color: #000000;
        font-weight: 300;
        font-size: 28px;
        letter-spacing: -0.5px;
        border-bottom: 1px solid #000000;
        padding-bottom: 15px;
      }

      .section {
        margin-bottom: 60px;
      }

      .section h2 {
        margin-bottom: 25px;
        color: #000000;
        font-size: 20px;
        font-weight: 400;
        letter-spacing: -0.3px;
      }

      .form-group {
        margin-bottom: 15px;
      }

      label {
        display: block;
        margin-bottom: 8px;
        font-weight: 400;
        color: #000000;
        font-size: 13px;
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }

      input[type="text"],
      input[type="email"],
      textarea,
      select {
        width: 100%;
        padding: 12px;
        border: 1px solid #000000;
        border-radius: 0;
        font-size: 14px;
        font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
        background: #ffffff;
        color: #000000;
        transition: border-color 0.2s ease;
      }

      input[type="text"]:focus,
      input[type="email"]:focus,
      textarea:focus,
      select:focus {
        outline: none;
        border-color: #000000;
      }

      input[type="text"]:hover,
      input[type="email"]:hover,
      textarea:hover,
      select:hover {
        border-color: #333333;
      }

      textarea {
        min-height: 150px;
        resize: vertical;
      }

      /* Estilos para el editor Quill */
      #editor-container {
        min-height: 300px;
        margin-bottom: 20px;
      }

      .ql-editor {
        min-height: 300px;
        font-size: 14px;
      }

      .ql-container {
        font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
        border: 1px solid #000000;
        border-radius: 0;
      }

      .ql-toolbar {
        border: 1px solid #000000;
        border-bottom: none;
        border-radius: 0;
        background: #ffffff;
        padding: 8px;
      }

      .ql-toolbar button {
        border-radius: 0;
        transition: all 0.2s ease;
      }

      .ql-toolbar button:hover {
        background: #000000 !important;
        color: #ffffff !important;
      }

      .ql-toolbar button:hover .ql-stroke {
        stroke: #ffffff !important;
      }

      .ql-toolbar button:hover .ql-fill {
        fill: #ffffff !important;
      }

      .ql-toolbar button.ql-active {
        background: #000000 !important;
        color: #ffffff !important;
      }

      .ql-toolbar button.ql-active .ql-stroke {
        stroke: #ffffff !important;
      }

      .ql-toolbar button.ql-active .ql-fill {
        fill: #ffffff !important;
      }

      /* Estilos para pickers (botones con "A" - tamaño, color, etc.) */
      .ql-toolbar .ql-picker-label {
        border-radius: 0;
        transition: all 0.2s ease;
      }

      .ql-toolbar .ql-picker-label:hover {
        background: #000000 !important;
        color: #ffffff !important;
      }

      .ql-toolbar .ql-picker-label:hover {
        background: #000000 !important;
        color: #ffffff !important;
      }

      .ql-toolbar .ql-picker-label:hover .ql-stroke {
        stroke: #ffffff !important;
      }

      .ql-toolbar .ql-picker-label:hover .ql-fill {
        fill: #ffffff !important;
      }

      .ql-toolbar .ql-picker-label.ql-active {
        background: #000000 !important;
        color: #ffffff !important;
      }

      .ql-toolbar .ql-picker-label.ql-active .ql-stroke {
        stroke: #ffffff !important;
      }

      .ql-toolbar .ql-picker-label.ql-active .ql-fill {
        fill: #ffffff !important;
      }

      /* Items del dropdown del picker */
      .ql-toolbar .ql-picker-item:hover {
        background: #000000 !important;
        color: #ffffff !important;
      }

      .ql-toolbar .ql-picker-item:hover .ql-stroke {
        stroke: #ffffff !important;
      }

      .ql-toolbar .ql-picker-item:hover .ql-fill {
        fill: #ffffff !important;
      }

      .ql-editor {
        font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
        color: #000000;
      }
      
      /* Estilos para vídeos embebidos en el editor */
      .ql-video-embed {
        margin: 15px 0;
        max-width: 100%;
        display: block;
      }
      
      /* Contenedor de vídeos con aspect ratio 16:9 en el editor */
      .ql-video-embed div[id^="youtube-container-"],
      .ql-video-embed div[style*="margin-bottom: 15px"][style*="position: relative"],
      .ql-video-embed div[style*="margin: 15px 0"][style*="position: relative"] {
        position: relative;
        width: 100%;
        max-width: 560px;
        margin: 15px 0;
        padding-bottom: 56.25%; /* 16:9 aspect ratio (9/16 = 0.5625) */
        height: 0;
        overflow: hidden;
      }
      
      .ql-video-embed iframe {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        border-radius: 0;
        border: none;
      }
      
      /* Estilos para embeds de Instagram en el editor */
      .ql-instagram-embed {
        margin: 15px 0;
        max-width: 100%;
        display: block;
      }
      
      .ql-instagram-embed div[style*="position: relative"] {
        position: relative;
        width: 100%;
        max-width: 540px;
        margin: 15px 0;
        min-height: 400px;
        height: auto;
        overflow: visible;
      }
      
      .ql-instagram-embed iframe {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        min-height: 400px;
        height: auto;
        border-radius: 0;
        border: none;
      }
      
      /* Estilos para embeds de SoundCloud en el editor */
      .ql-soundcloud-embed {
        margin: 15px 0;
        max-width: 100%;
        display: block;
      }
      
      .ql-soundcloud-embed div[style*="position: relative"] {
        position: relative;
        width: 100%;
        max-width: 100%;
        margin: 15px 0;
        height: auto;
        min-height: 166px;
        overflow: visible;
      }
      
      /* Para perfiles de SoundCloud (con lista de tracks) */
      .ql-soundcloud-embed div[style*="padding-bottom: 40%"] {
        padding-bottom: 0 !important;
        height: 450px !important;
      }
      
      /* Para tracks individuales */
      .ql-soundcloud-embed div[style*="padding-bottom: 20%"] {
        padding-bottom: 0 !important;
        height: 166px !important;
      }
      
      .ql-soundcloud-embed iframe {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        border-radius: 0;
        border: none;
      }
      
      /* Estilos para botones personalizados de Instagram y SoundCloud en el toolbar */
      .ql-toolbar button.ql-instagram,
      .ql-toolbar button.ql-soundcloud {
        display: inline-flex !important;
        align-items: center !important;
        justify-content: center !important;
        cursor: pointer !important;
        border: none !important;
        border-radius: 0 !important;
        opacity: 1 !important;
        visibility: visible !important;
        background: transparent !important;
        vertical-align: middle !important;
        margin: 0 !important;
        position: relative !important;
        color: #444 !important;
        padding: 2px 4px !important;
        width: auto !important;
        height: auto !important;
        min-width: 24px !important;
        min-height: 24px !important;
        box-sizing: border-box !important;
      }

      /* Separar el botón de Instagram del botón anterior */
      .ql-toolbar button.ql-instagram {
        margin-left: 8px !important;
      }
      
      /* Hover uniforme: fondo negro para todos los botones */
      .ql-toolbar button.ql-instagram:hover,
      .ql-toolbar button.ql-soundcloud:hover {
        background-color: #000000 !important;
        color: #ffffff !important;
      }

      .ql-toolbar button.ql-instagram:hover svg,
      .ql-toolbar button.ql-instagram:hover svg path {
        fill: #ffffff !important;
      }

      .ql-toolbar button.ql-soundcloud:hover svg,
      .ql-toolbar button.ql-soundcloud:hover svg path {
        fill: #ffffff !important;
      }
      
      /* Quitar cualquier borde o outline en hover */
      .ql-toolbar button.ql-instagram:hover,
      .ql-toolbar button.ql-soundcloud:hover,
      .ql-toolbar button.ql-instagram:focus,
      .ql-toolbar button.ql-soundcloud:focus {
        outline: none !important;
        border: none !important;
        box-shadow: none !important;
      }
      
      .ql-toolbar button.ql-instagram svg,
      .ql-toolbar button.ql-soundcloud svg,
      .ql-toolbar button.ql-soundcloud img {
        display: block !important;
        width: 18px !important;
        height: 18px !important;
        margin: 0 !important;
        fill: currentColor !important;
        pointer-events: none !important;
        transition: filter 0.2s ease !important;
        flex-shrink: 0 !important;
      }
      
      /* Estilo específico para la imagen de SoundCloud en hover - convertir a blanco cuando el fondo es negro */
      .ql-toolbar button.ql-soundcloud:hover img {
        filter: brightness(0) invert(1) !important;
      }
      
      /* Asegurar que los botones no se oculten - sobrescribir cualquier estilo de Quill */
      .ql-toolbar .ql-formats button.ql-instagram,
      .ql-toolbar .ql-formats button.ql-soundcloud,
      .ql-toolbar button.ql-instagram,
      .ql-toolbar button.ql-soundcloud {
        display: inline-block !important;
        opacity: 1 !important;
        visibility: visible !important;
      }
      
      /* Ocultar cualquier recuadro gris que pueda aparecer */
      .ql-toolbar .ql-formats:empty,
      .ql-toolbar .ql-formats:has(button.ql-instagram):not(:has(button:not(.ql-instagram):not(.ql-soundcloud))) {
        display: none !important;
      }

      .checkbox-group {
        display: flex;
        align-items: center;
        gap: 12px;
      }

      input[type="checkbox"] {
        width: 18px;
        height: 18px;
        accent-color: #000000;
        cursor: pointer;
      }

      button {
        background: #000000;
        color: #ffffff;
        border: 1px solid #000000;
        padding: 12px 32px;
        border-radius: 0;
        cursor: pointer;
        font-size: 13px;
        font-weight: 400;
        font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
        text-transform: uppercase;
        letter-spacing: 1px;
        transition: all 0.2s ease;
      }

      button:hover {
        background: #ffffff;
        color: #000000;
      }

      button.delete {
        background: #000000;
        border-color: #000000;
      }

      button.delete:hover {
        background: #ffffff;
        color: #000000;
      }

      button.edit {
        background: #000000;
        border-color: #000000;
      }

      button.edit:hover {
        background: #ffffff;
        color: #000000;
      }

      .posts-list {
        display: grid;
        gap: 20px;
      }

      .post-card {
        border: 1px solid #000000;
        border-radius: 0;
        padding: 30px;
        background: #ffffff;
        margin-bottom: 20px;
        transition: border-color 0.2s ease;
      }

      .post-card:hover {
        border-color: #333333;
      }

      .post-header {
        display: flex;
        justify-content: space-between;
        align-items: start;
        margin-bottom: 20px;
        padding-bottom: 15px;
        border-bottom: 1px solid #000000;
      }

      .post-title {
        font-size: 18px;
        font-weight: 400;
        color: #000000;
        margin-bottom: 8px;
        letter-spacing: -0.3px;
      }

      .post-meta {
        font-size: 11px;
        color: #666666;
        margin-bottom: 12px;
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }

      .post-content {
        color: #000000;
        line-height: 1.8;
        font-size: 14px;
        margin-bottom: 15px;
        white-space: pre-wrap;
      }
      
      /* Estilos para imágenes y vídeos dentro del contenido del post */
      .post-content img {
        max-width: 100%;
        height: auto;
        border-radius: 0;
        margin: 10px 0;
        border: 1px solid #000000;
        display: block;
      }
      
      /* Contenedor de vídeos con aspect ratio 16:9 */
      .post-content div[id^="youtube-container-"],
      .post-content div[style*="margin-bottom: 15px"][style*="position: relative"],
      .post-content div[style*="margin: 15px 0"][style*="position: relative"] {
        position: relative;
        width: 100%;
        max-width: 560px;
        margin: 15px 0;
        padding-bottom: 56.25%; /* 16:9 aspect ratio (9/16 = 0.5625) */
        height: 0;
        overflow: hidden;
      }
      
      .post-content iframe {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        border-radius: 0;
        border: none;
      }
      
      /* Estilos para embeds de Instagram en posts */
      .post-content div[style*="padding-bottom: 100%"] {
        position: relative;
        width: 100%;
        max-width: 540px;
        margin: 15px 0;
        padding-bottom: 100%;
        height: 0;
        overflow: hidden;
      }
      
      /* Estilos para embeds de SoundCloud en posts */
      .post-content div[style*="height: 450px"] {
        position: relative;
        width: 100%;
        max-width: 100%;
        margin: 15px 0;
        height: 450px;
        overflow: visible;
      }
      
      .post-content div[style*="height: 166px"] {
        position: relative;
        width: 100%;
        max-width: 100%;
        margin: 15px 0;
        height: 166px;
        overflow: visible;
      }
      
      .post-content div[style*="height: 450px"] iframe,
      .post-content div[style*="height: 166px"] iframe {
        height: 100%;
      }

      .post-actions {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
      }

      .badge {
        display: inline-block;
        padding: 6px 12px;
        border-radius: 0;
        font-size: 11px;
        font-weight: 400;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        border: 1px solid #000000;
        background: #ffffff;
        color: #000000;
        transition: all 0.2s ease;
      }

      .badge.published {
        background: transparent;
        color: #000000;
        border: none;
        padding: 0;
        font-size: 11px;
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }

      .badge.published:hover {
        background: transparent;
        color: #000000;
      }

      .badge.draft {
        background: #ffffff;
        color: #000000;
        border-color: #666666;
      }

      .badge.draft:hover {
        background: #000000;
        color: #ffffff;
        border-color: #000000;
      }

      .message {
        padding: 15px;
        border-radius: 0;
        margin-bottom: 25px;
        display: none;
        border: 1px solid #000000;
        background: #ffffff;
        color: #000000;
        font-size: 13px;
      }

      .message.success {
        background: #ffffff;
        color: #000000;
        border-color: #000000;
      }

      .message.error {
        background: #ffffff;
        color: #000000;
        border-color: #000000;
      }

      .message.show {
        display: block;
      }

      .form-actions {
        display: flex;
        gap: 10px;
        margin-top: 20px;
      }

      .form-actions button[type="button"] {
        background: #ffffff;
        color: #000000;
        border: 1px solid #000000;
      }

      .form-actions button[type="button"]:hover {
        background: #000000;
        color: #ffffff;
      }

      /* Modal de preview */
      .preview-modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        z-index: 10000;
        overflow-y: auto;
      }

      .preview-modal.show {
        display: flex;
        align-items: flex-start;
        justify-content: center;
        padding: 40px 20px;
      }

      .preview-content {
        background: #ffffff;
        border: 1px solid #000000;
        border-radius: 0;
        max-width: 800px;
        width: 100%;
        padding: 40px;
        margin: 20px auto;
        position: relative;
      }

      .preview-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 30px;
        padding-bottom: 20px;
        border-bottom: 1px solid #000000;
      }

      .preview-header h3 {
        margin: 0;
        font-size: 18px;
        font-weight: 400;
        color: #000000;
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }

      .preview-close {
        background: #000000;
        color: #ffffff;
        border: 1px solid #000000;
        padding: 8px 16px;
        font-size: 11px;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .preview-close:hover {
        background: #ffffff;
        color: #000000;
      }

      .preview-post {
        font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
      }

      .preview-post-title {
        font-size: 24px;
        font-weight: 400;
        color: #000000;
        margin-bottom: 20px;
        letter-spacing: -0.3px;
      }

      .preview-post-content {
        color: #000000;
        line-height: 1.8;
        font-size: 14px;
        margin-top: 20px;
      }

      .preview-post-content img {
        max-width: 100%;
        height: auto;
        border-radius: 0;
        margin: 20px 0;
        border: 1px solid #000000;
        display: block;
      }

      .preview-post-content iframe {
        border-radius: 0;
        border: none;
      }

      /* Estilos para videos embebidos en preview */
      .preview-post-content div[id^="youtube-container-"],
      .preview-post-content div[style*="margin: 15px 0"][style*="position: relative"] {
        position: relative;
        width: 100%;
        max-width: 560px;
        margin: 20px 0;
        padding-bottom: 56.25%;
        height: 0;
        overflow: hidden;
      }

      .preview-post-content div[id^="youtube-container-"] iframe,
      .preview-post-content div[style*="margin: 15px 0"][style*="position: relative"] iframe {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
      }

      /* Estilos para Instagram embeds en preview */
      .preview-post-content div[style*="min-height: 400px"] {
        position: relative;
        width: 100%;
        max-width: 540px;
        margin: 20px 0;
        min-height: 400px;
        height: auto;
        overflow: visible;
      }

      .preview-post-content div[style*="min-height: 400px"] iframe {
        height: auto;
        min-height: 400px;
      }

      /* Estilos para SoundCloud embeds en preview */
      .preview-post-content div[style*="height: 450px"],
      .preview-post-content div[style*="height: 166px"] {
        position: relative !important;
        width: 100% !important;
        max-width: 100% !important;
        margin: 20px 0 !important;
        overflow: visible !important;
      }

      .preview-post-content div[style*="height: 450px"] {
        height: 450px !important;
      }

      .preview-post-content div[style*="height: 166px"] {
        height: 166px !important;
      }

      .preview-post-content div[style*="height: 450px"] iframe,
      .preview-post-content div[style*="height: 166px"] iframe {
        position: absolute !important;
        top: 0 !important;
        left: 0 !important;
        width: 100% !important;
        height: 100% !important;
        border-radius: 0 !important;
        border: none !important;
      }

      /* Estilos para slideshow en preview */
      .preview-post-content .slideshow-wrapper {
        position: relative;
        width: 100%;
        margin: 20px 0;
      }
      .preview-post-content .slideshow-container {
        position: relative;
        width: 100%;
        overflow: hidden;
      }
      .preview-post-content .slideshow-slide {
        display: none;
        width: 100%;
      }
      .preview-post-content .slideshow-slide.active {
        display: block;
      }
      .preview-post-content .slideshow-slide img {
        max-width: 100%;
        height: auto;
        border-radius: 0;
        margin: 0;
        border: 1px solid #000000;
        display: block;
      }
      .preview-post-content .slideshow-caption {
        font-size: 12px;
        color: #666;
        margin-top: 8px;
        font-style: italic;
        text-align: center;
      }
      .preview-post-content .slideshow-arrow {
        position: absolute;
        top: 50%;
        transform: translateY(-50%);
        background: rgba(0, 0, 0, 0.7);
        color: #ffffff;
        border: 1px solid #000000;
        padding: 15px 20px;
        font-size: 24px;
        cursor: pointer;
        z-index: 10;
        transition: background 0.2s ease;
        border-radius: 0;
      }
      .preview-post-content .slideshow-arrow:hover {
        background: rgba(0, 0, 0, 0.9);
      }
      .preview-post-content .slideshow-prev {
        left: 10px;
      }
      .preview-post-content .slideshow-next {
        right: 10px;
      }
      .preview-post-content .slideshow-indicators {
        display: flex;
        justify-content: center;
        gap: 8px;
        margin-top: 15px;
      }
      .preview-post-content .slideshow-indicator {
        width: 12px;
        height: 12px;
        border-radius: 50%;
        border: 1px solid #000000;
        background: transparent;
        cursor: pointer;
        padding: 0;
        transition: background 0.2s ease;
      }
      .preview-post-content .slideshow-indicator.active {
        background: #000000;
      }
      .preview-post-content .slideshow-indicator:hover {
        background: #666666;
      }

      /* Sistema de bloques con columnas en preview (solo desktop) */
      .preview-blocks-container {
        display: flex;
        flex-direction: column;
        gap: 20px;
        width: 100%;
      }
      .preview-blocks-row {
        display: flex;
        flex-direction: column;
        gap: 20px;
        width: 100%;
      }
      .preview-block-item {
        width: 100%;
        box-sizing: border-box;
      }
      /* En desktop, aplicar layout de columnas */
      @media (min-width: 768px) {
        .preview-blocks-row {
          flex-direction: row;
          flex-wrap: nowrap;
          align-items: flex-start;
        }
        .preview-block-item[data-width="full"] {
          width: 100% !important;
        }
        .preview-block-item[data-width="half"] {
          width: calc(50% - 10px) !important;
          flex: 0 0 calc(50% - 10px) !important;
        }
        .preview-block-item[data-width="third"] {
          width: calc(33.333% - 14px) !important;
          flex: 0 0 calc(33.333% - 14px) !important;
        }
        .preview-block-item[data-width="two-thirds"] {
          width: calc(66.666% - 10px) !important;
          flex: 0 0 calc(66.666% - 10px) !important;
        }
      }

      /* Estilos para el editor de imágenes */
      #image-editor-container {
        max-height: 70vh;
        overflow: auto;
      }

      #image-editor-img {
        max-width: 100%;
        max-height: 70vh;
      }


      .section-submenu .section-menu-item {
        padding-left: 15px;
        font-size: 12px;
      }

      .main-content {
        flex: 1;
        min-width: 0;
      }

      .section-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 30px;
        padding-bottom: 20px;
        border-bottom: 1px solid #000000;
      }

      .section-header h2 {
        margin: 0;
        font-size: 24px;
        font-weight: 400;
        color: #000000;
      }

      /* Section Manager Panel */
      .section-manager-container {
        width: 100%;
      }

      .section-manager-content {
        max-height: 600px;
        overflow-y: auto;
      }

      .section-manager-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 15px;
        margin-bottom: 10px;
        background: #f5f5f5;
        border: 1px solid #000000;
        border-radius: 0;
      }

      .section-manager-item-info {
        flex: 1;
      }

      .section-manager-item-name {
        font-weight: 500;
        color: #000000;
        margin-bottom: 5px;
      }

      .section-manager-item-meta {
        font-size: 11px;
        color: #666666;
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }

      .section-manager-item-actions {
        display: flex;
        gap: 10px;
      }

      .section-manager-item-actions button {
        padding: 8px 16px;
        font-size: 10px;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        border-radius: 0;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .section-manager-item-actions .edit-btn {
        background: #ffffff;
        color: #000000;
        border: 1px solid #000000;
      }

      .section-manager-item-actions .edit-btn:hover {
        background: #000000;
        color: #ffffff;
      }

      .section-manager-item-actions .delete-btn {
        background: #ffffff;
        color: #000000;
        border: 1px solid #000000;
      }

      .section-manager-item-actions .delete-btn:hover {
        background: #000000;
        color: #ffffff;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 40px; padding-bottom: 20px; border-bottom: 1px solid #000000;">
        <h1 style="margin: 0; border: none; padding: 0;">Admin Panel</h1>
        <div style="display: flex; align-items: center; gap: 20px;">
          <span id="user-info" style="font-size: 12px; color: #666666; text-transform: uppercase; letter-spacing: 0.5px;"></span>
          <button id="view-user-mode-btn" style="display: none; background: #ffffff; color: #000000; padding: 10px 24px; font-size: 11px; border: 1px solid #000000; text-transform: uppercase; letter-spacing: 0.5px; cursor: pointer; transition: all 0.2s ease;" onmouseover="this.style.background='#000000'; this.style.color='#ffffff';" onmouseout="this.style.background='#ffffff'; this.style.color='#000000';">View as User</button>
          <button id="logout-btn" style="background: #000000; color: #ffffff; padding: 10px 24px; font-size: 11px; border: 1px solid #000000;">Sign Out</button>
        </div>
      </div>

      <div id="message" class="message"></div>

      <!-- Site Selector (only for admins) -->
      <div id="site-selector-container" style="display: none; margin-bottom: 30px; padding: 20px; background: #ffffff; border: 1px solid #000000;">
        <label for="site-selector" style="display: block; margin-bottom: 10px; font-size: 12px; text-transform: uppercase; letter-spacing: 0.5px; color: #000000;">Select Site:</label>
        <select id="site-selector" style="padding: 12px; border: 1px solid #000000; border-radius: 0; font-size: 13px; min-width: 200px; width: 100%; max-width: 400px;">
          <option value="">Loading sites...</option>
        </select>
      </div>

      <!-- Section Manager Panel (Collapsible) -->
      <div class="section-manager-container" style="margin-bottom: 30px;">
        <div class="section-manager-header" id="section-manager-header" style="display: flex; justify-content: space-between; align-items: center; padding: 15px 20px; background: #ffffff; border: 1px solid #000000; cursor: pointer; transition: all 0.2s ease;" onmouseover="this.style.background='#f5f5f5';" onmouseout="this.style.background='#ffffff';">
          <h3 style="margin: 0; font-size: 14px; font-weight: 400; color: #000000; text-transform: uppercase; letter-spacing: 0.5px;">Manage Sections</h3>
          <span id="section-manager-toggle" style="font-size: 18px; color: #000000;">+</span>
        </div>
        <div id="section-manager-content" class="section-manager-content" style="display: none; padding: 20px; background: #ffffff; border: 1px solid #000000; border-top: none;">
          <div id="create-section-container" style="margin-bottom: 20px; padding: 15px; background: #f5f5f5; border: 1px solid #000000;">
            <button type="button" id="create-section-btn" style="padding: 10px 20px; background: #000000; color: #ffffff; border: none; border-radius: 0; cursor: pointer; font-size: 11px; text-transform: uppercase; letter-spacing: 0.5px;">
              + Create New Section
            </button>
          </div>
          <div id="sections-manager-list"></div>
        </div>
      </div>

      <!-- Contenido principal -->
      <div class="main-content">

      <!-- UI para gestionar thumbnails (se muestra cuando la sección es de tipo "thumbnails") -->
      <div class="section" id="thumbnails-manager-container" style="display: none;">
        <h2 id="thumbnails-section-title">Manage Thumbnails</h2>
        <div style="margin-bottom: 20px; padding: 20px; background: #ffffff; border: 1px solid #000000;">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
            <label style="font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px;">Thumbnails</label>
            <button type="button" id="add-thumbnail-btn" style="padding: 8px 16px; background: #000000; color: #ffffff; border: none; border-radius: 0; cursor: pointer; font-size: 11px; text-transform: uppercase; letter-spacing: 0.5px;">
              + Add Thumbnail
            </button>
          </div>
          <div id="thumbnails-list" style="display: flex; flex-direction: column; gap: 15px;">
            <p style="color: #999; font-style: italic; padding: 20px; text-align: center;">Loading thumbnails...</p>
          </div>
          <small style="color: #666666; font-size: 11px; display: block; margin-top: 8px; text-transform: uppercase; letter-spacing: 0.5px;">
            Each thumbnail automatically creates a detail page with the predefined template. Click "Edit" to edit the thumbnail (image, title, caption) or "Edit Detail" to edit the detail page content.
          </small>
        </div>
      </div>

      <!-- Modal para editar thumbnail -->
      <div id="thumbnail-editor-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.7); z-index: 10000; overflow-y: auto;">
        <div style="position: relative; max-width: 600px; margin: 50px auto; background: #ffffff; border: 1px solid #000000; padding: 30px;">
          <button type="button" id="thumbnail-editor-close-btn" style="position: absolute; top: 10px; right: 10px; background: #ffffff; border: 1px solid #000000; padding: 5px 10px; cursor: pointer; font-size: 12px;">×</button>
          
          <h3 style="margin: 0 0 20px 0; font-size: 16px; font-weight: 400; text-transform: uppercase; letter-spacing: 0.5px;">Edit Thumbnail</h3>
          
          <form id="thumbnail-editor-form">
            <input type="hidden" id="thumbnail-editor-id" />
            
            <div class="form-group" style="margin-bottom: 20px;">
              <label for="thumbnail-editor-title" style="display: block; margin-bottom: 5px; font-size: 12px; text-transform: uppercase; letter-spacing: 0.5px;">Title *</label>
              <input type="text" id="thumbnail-editor-title" required style="width: 100%; padding: 10px; border: 1px solid #000000; border-radius: 0; font-size: 13px;" />
            </div>
            
            <div class="form-group" style="margin-bottom: 20px;">
              <label for="thumbnail-editor-image-url" style="display: block; margin-bottom: 5px; font-size: 12px; text-transform: uppercase; letter-spacing: 0.5px;">Image URL *</label>
              <div style="display: flex; gap: 10px; align-items: flex-start;">
                <input type="text" id="thumbnail-editor-image-url" required style="flex: 1; padding: 10px; border: 1px solid #000000; border-radius: 0; font-size: 13px;" />
                <button type="button" id="thumbnail-editor-edit-image-btn" style="padding: 10px 15px; background: #000000; color: #ffffff; border: none; border-radius: 0; cursor: pointer; font-size: 11px; text-transform: uppercase; letter-spacing: 0.5px; white-space: nowrap;">
                  Edit Image
                </button>
              </div>
              <div id="thumbnail-editor-image-preview" style="margin-top: 10px; width: 100%; max-width: 300px; height: 200px; background: #f0f0f0; border: 1px solid #ddd; display: flex; align-items: center; justify-content: center; overflow: hidden;">
                <span style="color: #999; font-size: 11px;">Image preview</span>
              </div>
            </div>
            
            <div class="form-group" style="margin-bottom: 20px;">
              <label for="thumbnail-editor-description" style="display: block; margin-bottom: 5px; font-size: 12px; text-transform: uppercase; letter-spacing: 0.5px;">Description / Caption (optional)</label>
              <textarea id="thumbnail-editor-description" rows="3" style="width: 100%; padding: 10px; border: 1px solid #000000; border-radius: 0; font-size: 13px; font-family: inherit; resize: vertical;"></textarea>
            </div>
            
            <div class="form-actions" style="display: flex; gap: 10px; justify-content: flex-end; margin-top: 30px;">
              <button type="button" id="thumbnail-editor-cancel-btn" style="padding: 10px 20px; background: #ffffff; color: #000000; border: 1px solid #000000; border-radius: 0; cursor: pointer; font-size: 11px; text-transform: uppercase; letter-spacing: 0.5px;">
                Cancel
              </button>
              <button type="submit" id="thumbnail-editor-save-btn" style="padding: 10px 20px; background: #000000; color: #ffffff; border: none; border-radius: 0; cursor: pointer; font-size: 11px; text-transform: uppercase; letter-spacing: 0.5px;">
                Save
              </button>
            </div>
          </form>
        </div>
      </div>

      <!-- Modal para reordenar thumbnails -->
      <div id="thumbnail-reorder-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.7); z-index: 10000; overflow-y: auto;">
        <div style="position: relative; max-width: 800px; margin: 50px auto; background: #ffffff; border: 1px solid #000000; padding: 30px;">
          <button type="button" id="thumbnail-reorder-close-btn" style="position: absolute; top: 10px; right: 10px; background: #ffffff; border: 1px solid #000000; padding: 5px 10px; cursor: pointer; font-size: 12px;">×</button>
          
          <h3 style="margin: 0 0 20px 0; font-size: 16px; font-weight: 400; text-transform: uppercase; letter-spacing: 0.5px;">Reorder Thumbnails</h3>
          
          <p style="font-size: 11px; color: #666; margin-bottom: 20px; font-style: italic;">
            Drag and drop thumbnails to reorder them. The order will be saved when you click "Save Order".
          </p>
          
          <div id="thumbnail-reorder-list" style="display: flex; flex-direction: column; gap: 15px; margin-bottom: 30px;">
            <!-- Los thumbnails se añadirán aquí dinámicamente -->
          </div>
          
          <div class="form-actions" style="display: flex; gap: 10px; justify-content: flex-end; margin-top: 30px;">
            <button type="button" id="thumbnail-reorder-cancel-btn" style="padding: 10px 20px; background: #ffffff; color: #000000; border: 1px solid #000000; border-radius: 0; cursor: pointer; font-size: 11px; text-transform: uppercase; letter-spacing: 0.5px;">
              Cancel
            </button>
            <button type="button" id="thumbnail-reorder-save-btn" style="padding: 10px 20px; background: #000000; color: #ffffff; border: none; border-radius: 0; cursor: pointer; font-size: 11px; text-transform: uppercase; letter-spacing: 0.5px;">
              Save Order
            </button>
          </div>
        </div>
      </div>

      <!-- Modal para crear sección desde schema -->
      <div id="create-section-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.7); z-index: 10000; overflow-y: auto;">
        <div style="position: relative; max-width: 600px; margin: 50px auto; background: #ffffff; border: 1px solid #000000; padding: 30px;">
          <button type="button" id="create-section-modal-close-btn" style="position: absolute; top: 10px; right: 10px; background: #ffffff; border: 1px solid #000000; padding: 5px 10px; cursor: pointer; font-size: 12px;">×</button>
          
          <h3 style="margin: 0 0 20px 0; font-size: 16px; font-weight: 400; text-transform: uppercase; letter-spacing: 0.5px;">Create New Section</h3>
          
          <form id="create-section-form">
            <div class="form-group" style="margin-bottom: 20px;">
              <label for="section-name" style="display: block; margin-bottom: 5px; font-size: 12px; text-transform: uppercase; letter-spacing: 0.5px;">Section Name *</label>
              <input type="text" id="section-name" required style="width: 100%; padding: 10px; border: 1px solid #000000; border-radius: 0; font-size: 13px;" />
            </div>

            <div class="form-group" style="margin-bottom: 20px;">
              <label for="section-schema" style="display: block; margin-bottom: 5px; font-size: 12px; text-transform: uppercase; letter-spacing: 0.5px;">Section Type (from Frontend Profile)</label>
              <select id="section-schema" style="width: 100%; padding: 10px; border: 1px solid #000000; border-radius: 0; font-size: 13px;">
                <option value="">-- Free Mode (No Template) --</option>
              </select>
              <small id="section-schema-info" style="color: #666666; font-size: 11px; display: block; margin-top: 5px; text-transform: uppercase; letter-spacing: 0.5px; font-style: italic;">
                Select a schema to use a predefined template, or leave empty for free mode.
              </small>
            </div>

            <div class="form-group" style="margin-bottom: 20px;">
              <label for="section-description" style="display: block; margin-bottom: 5px; font-size: 12px; text-transform: uppercase; letter-spacing: 0.5px;">Description (optional)</label>
              <textarea id="section-description" rows="3" style="width: 100%; padding: 10px; border: 1px solid #000000; border-radius: 0; font-size: 13px; font-family: inherit; resize: vertical;"></textarea>
            </div>

            <div class="form-actions" style="display: flex; gap: 10px; justify-content: flex-end; margin-top: 30px;">
              <button type="button" id="create-section-cancel-btn" style="padding: 10px 20px; background: #ffffff; color: #000000; border: 1px solid #000000; border-radius: 0; cursor: pointer; font-size: 11px; text-transform: uppercase; letter-spacing: 0.5px;">
                Cancel
              </button>
              <button type="submit" style="padding: 10px 20px; background: #000000; color: #ffffff; border: none; border-radius: 0; cursor: pointer; font-size: 11px; text-transform: uppercase; letter-spacing: 0.5px;">
                Create Section
              </button>
            </div>
          </form>
        </div>
      </div>

      <!-- Formulario para crear/editar post (oculto para secciones de thumbnails) -->
      <div class="section" id="post-form-container">
        <h2 id="form-title">Create New Post</h2>
        <form id="post-form">
          <input type="hidden" id="post-id" />
          
          <!-- Campos básicos -->
          <div class="form-group">
            <label for="title">Title *</label>
            <input type="text" id="title" required />
          </div>

          <div class="form-group">
            <label for="slug">Slug (URL-friendly, optional - auto-generated)</label>
            <input type="text" id="slug" />
          </div>

          <div class="form-group">
            <label for="post-order">Order (optional - lower appears first)</label>
            <input type="number" id="post-order" value="0" style="width: 120px;" />
            <small style="color: #666666; font-size: 11px; display: block; margin-top: 5px; text-transform: uppercase; letter-spacing: 0.5px;">
              Used to order items inside list/grid sections (e.g. releases, live, bio, contact).
            </small>
          </div>

          <div class="form-group">
            <label for="section">Section *</label>
            <select id="section" required>
              <option value="">Select a section</option>
            </select>
            <small id="section-type-info" style="color: #666666; font-size: 11px; display: block; margin-top: 5px; text-transform: uppercase; letter-spacing: 0.5px;">
              Posts must belong to a section. Post type will be set automatically.
            </small>
          </div>

          <div class="form-group">
            <label for="tags">Tags (optional)</label>
            <div id="tags-container" style="display: flex; flex-wrap: wrap; gap: 8px; margin-top: 5px;"></div>
            <input type="text" id="tag-input" placeholder="Type a tag and press Enter" style="margin-top: 8px; width: 100%; padding: 12px; border: 1px solid #000000; border-radius: 0; font-size: 13px;" />
            <small style="color: #666666; font-size: 11px; display: block; margin-top: 8px; text-transform: uppercase; letter-spacing: 0.5px;">
              Type tags and press Enter to add them. Click on a tag to remove it.
            </small>
          </div>

          <!-- Campos de Thumbnail (solo para secciones de tipo "thumbnails") -->
          <div class="form-group" id="thumbnail-fields-container" style="display: none; margin-top: 30px; padding: 20px; background: #f9f9f9; border: 1px solid #ddd;">
            <label style="font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; display: block; margin-bottom: 15px;">Thumbnail Information</label>
            <small style="color: #666666; font-size: 11px; display: block; margin-bottom: 15px; text-transform: uppercase; letter-spacing: 0.5px;">
              These fields appear on the thumbnails page. The detail page blocks are below.
            </small>
            
            <div class="form-group" style="margin-bottom: 20px;">
              <label for="thumbnail-image-url" style="display: block; margin-bottom: 5px; font-size: 12px; text-transform: uppercase; letter-spacing: 0.5px;">Thumbnail Image URL *</label>
              <div style="display: flex; gap: 10px; align-items: flex-start;">
                <input type="text" id="thumbnail-image-url" required style="flex: 1; padding: 10px; border: 1px solid #000000; border-radius: 0; font-size: 13px;" />
                <button type="button" id="thumbnail-image-edit-btn" style="padding: 10px 15px; background: #000000; color: #ffffff; border: none; border-radius: 0; cursor: pointer; font-size: 11px; text-transform: uppercase; letter-spacing: 0.5px; white-space: nowrap;">
                  Edit Image
                </button>
              </div>
              <div id="thumbnail-image-preview" style="margin-top: 10px; width: 100%; max-width: 300px; height: 200px; background: #f0f0f0; border: 1px solid #ddd; display: flex; align-items: center; justify-content: center; overflow: hidden;">
                <span style="color: #999; font-size: 11px;">Image preview</span>
              </div>
            </div>
            
            <div class="form-group" style="margin-bottom: 20px;">
              <label for="thumbnail-caption" style="display: block; margin-bottom: 5px; font-size: 12px; text-transform: uppercase; letter-spacing: 0.5px;">Thumbnail Caption (optional)</label>
              <textarea id="thumbnail-caption" rows="3" style="width: 100%; padding: 10px; border: 1px solid #000000; border-radius: 0; font-size: 13px; font-family: inherit; resize: vertical;"></textarea>
              <small style="color: #666666; font-size: 11px; display: block; margin-top: 5px; text-transform: uppercase; letter-spacing: 0.5px;">
                This caption appears below the thumbnail image on the thumbnails page.
              </small>
            </div>
          </div>

          <!-- Editor especializado para Slideshow -->
          <div class="form-group" id="slideshow-editor-container" style="display: none; margin-top: 30px;">
            <label style="font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; display: block; margin-bottom: 15px;">Slideshow Configuration</label>
            
            <!-- Lista de slides -->
            <div style="margin-bottom: 20px;">
              <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                <label style="font-size: 12px; text-transform: uppercase; font-weight: bold;">Slides</label>
                <button type="button" id="slideshow-add-slide-btn" style="padding: 8px 16px; background: #000000; color: #ffffff; border: none; border-radius: 0; cursor: pointer; font-size: 11px; text-transform: uppercase; letter-spacing: 0.5px;">
                  + Add Slide
                </button>
              </div>
              <div id="slideshow-slides-list" style="display: flex; flex-direction: column; gap: 15px;">
                <!-- Los slides se añadirán aquí dinámicamente -->
              </div>
            </div>
            
            <!-- Botón para abrir el editor completo de slideshow -->
            <div style="padding: 20px; background: #f9f9f9; border: 1px solid #ddd; margin-bottom: 20px;">
              <label style="font-size: 12px; text-transform: uppercase; font-weight: bold; display: block; margin-bottom: 15px;">Slideshow Management</label>
              <p style="font-size: 11px; color: #666; margin-bottom: 15px; font-style: italic;">
                Click the button below to open the full slideshow editor where you can configure settings, preview the slideshow, and edit individual images.
              </p>
              <button type="button" id="open-slideshow-editor-btn" style="padding: 12px 24px; background: #000000; color: #ffffff; border: 1px solid #000000; border-radius: 0; cursor: pointer; font-size: 11px; text-transform: uppercase; letter-spacing: 0.5px; width: 100%;">
                Open Slideshow Editor
              </button>
            </div>
          </div>

          <!-- Sistema de bloques flexibles (oculto para slideshow) -->
          <div class="form-group" id="blocks-container" style="margin-top: 30px;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
              <div style="flex: 1;">
                <label id="blocks-container-title" style="font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px;">Content Blocks</label>
                <div id="blocks-container-description" style="font-size: 11px; color: #666666; margin-top: 5px; text-transform: uppercase; letter-spacing: 0.5px; font-style: italic;"></div>
              </div>
              <button type="button" id="add-block-btn" style="padding: 8px 16px; background: #000000; color: #ffffff; border: none; border-radius: 0; cursor: pointer; font-size: 11px; text-transform: uppercase; letter-spacing: 0.5px;">
                + Add Block
              </button>
            </div>
            <div id="blocks-list" style="display: flex; flex-direction: column; gap: 15px;">
              <!-- Los bloques se añadirán aquí dinámicamente -->
            </div>
            <small id="blocks-container-help" style="color: #666666; font-size: 11px; display: block; margin-top: 8px; text-transform: uppercase; letter-spacing: 0.5px;">
              Add flexible content blocks: text, images, videos, embeds. Use the arrow buttons to reorder.
            </small>
          </div>

          <!-- Editor legacy (oculto por defecto, visible solo si no hay bloques) -->
          <div class="form-group" id="legacy-editor-container" style="display: none;">
            <label for="content">Content *</label>
            <div id="editor-container"></div>
            <input type="hidden" id="content" name="content" />
            <small style="color: #666666; font-size: 11px; display: block; margin-top: 8px; text-transform: uppercase; letter-spacing: 0.5px;">
              Use the toolbar to format text, insert images and videos.
            </small>
          </div>

          <div class="form-group">
            <div class="checkbox-group">
              <input type="checkbox" id="published" />
              <label for="published">Published</label>
            </div>
          </div>

          <!-- Botón para reordenar thumbnails (solo para secciones de tipo "thumbnails") -->
          <div class="form-group" id="thumbnail-reorder-container" style="display: none; margin-top: 30px; padding: 20px; background: #f9f9f9; border: 1px solid #ddd;">
            <label style="font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; display: block; margin-bottom: 15px;">Thumbnails Management</label>
            <p style="font-size: 11px; color: #666; margin-bottom: 15px; font-style: italic;">
              Click the button below to reorder all thumbnails in this section.
            </p>
            <button type="button" id="reorder-thumbnails-btn" style="padding: 12px 24px; background: #000000; color: #ffffff; border: 1px solid #000000; border-radius: 0; cursor: pointer; font-size: 11px; text-transform: uppercase; letter-spacing: 0.5px; width: 100%;">
              Reorder Thumbnails
            </button>
          </div>

          <div class="form-actions">
            <button type="button" id="preview-btn">Preview</button>
            <button type="submit" id="submit-btn">Save</button>
            <button type="button" id="cancel-btn" style="display: none;">Cancel</button>
          </div>
        </form>
      </div>

      <!-- Lista de posts -->
      <div class="section">
        <div class="section-header">
          <h2 id="section-title">All Posts</h2>
        </div>
        
        <!-- Search and Filters -->
        <div style="margin-bottom: 30px; padding: 25px; background: #ffffff; border: 1px solid #000000; border-radius: 0;">
          <div style="display: flex; gap: 12px; flex-wrap: wrap; align-items: center;">
            <input 
              type="text" 
              id="search-input" 
              placeholder="Search posts..." 
              style="flex: 1; min-width: 200px; padding: 12px; border: 1px solid #000000; border-radius: 0; font-size: 13px;"
            />
            <select id="filter-published" style="padding: 12px; border: 1px solid #000000; border-radius: 0; font-size: 13px; min-width: 150px;">
              <option value="">All</option>
              <option value="true">Published</option>
              <option value="false">Drafts</option>
            </select>
            <select id="filter-section" style="padding: 12px; border: 1px solid #000000; border-radius: 0; font-size: 13px; min-width: 150px;">
              <option value="">All sections</option>
            </select>
            <select id="filter-tag" style="padding: 12px; border: 1px solid #000000; border-radius: 0; font-size: 13px; min-width: 150px;">
              <option value="">All tags</option>
            </select>
            <button id="clear-filters" style="padding: 12px 24px; background: #ffffff; color: #000000; border: 1px solid #000000; border-radius: 0; cursor: pointer; font-size: 11px; text-transform: uppercase; letter-spacing: 0.5px; transition: all 0.2s ease;">Clear</button>
          </div>
        </div>
        
        <div id="posts-list" class="posts-list">
          <p>Loading posts...</p>
        </div>
        
        <!-- Paginación -->
        <div id="pagination" style="margin-top: 20px; display: flex; justify-content: center; align-items: center; gap: 10px;"></div>
        </div>
      </div>

      <!-- Audit Logs Section (oculta, solo se muestra en el modal) -->
      <div id="audit-logs-section" class="section" style="display: none;">
      </div>

      <!-- Modal de Audit Logs (solo para admins) -->
      <div id="audit-logs-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.7); z-index: 10000; overflow-y: auto;">
        <div style="position: relative; max-width: 1200px; margin: 50px auto; background: #ffffff; border: 1px solid #000000; padding: 30px; max-height: 90vh; overflow-y: auto;">
          <button type="button" id="audit-logs-modal-close-btn" style="position: absolute; top: 10px; right: 10px; background: #ffffff; border: 1px solid #000000; padding: 5px 10px; cursor: pointer; font-size: 12px;">×</button>
          
          <h3 style="margin: 0 0 20px 0; font-size: 16px; font-weight: 400; text-transform: uppercase; letter-spacing: 0.5px;">Audit Logs</h3>
          
          <!-- Filters -->
          <div style="margin-bottom: 30px; padding: 25px; background: #ffffff; border: 1px solid #000000; border-radius: 0;">
            <div style="display: flex; gap: 12px; flex-wrap: wrap; align-items: center;">
              <select id="audit-filter-action" style="padding: 12px; border: 1px solid #000000; border-radius: 0; font-size: 13px; min-width: 150px;">
                <option value="">All actions</option>
                <option value="login_success">Login Success</option>
                <option value="login_failed">Login Failed</option>
                <option value="logout">Logout</option>
                <option value="user_registered">User Registered</option>
                <option value="post_created">Post Created</option>
                <option value="post_updated">Post Updated</option>
                <option value="post_deleted">Post Deleted</option>
              </select>
              <select id="audit-filter-resource" style="padding: 12px; border: 1px solid #000000; border-radius: 0; font-size: 13px; min-width: 150px;">
                <option value="">All resources</option>
                <option value="user">User</option>
                <option value="post">Post</option>
                <option value="site">Site</option>
              </select>
              <input 
                type="date" 
                id="audit-filter-start-date" 
                style="padding: 12px; border: 1px solid #000000; border-radius: 0; font-size: 13px; min-width: 150px;"
              />
              <input 
                type="date" 
                id="audit-filter-end-date" 
                style="padding: 12px; border: 1px solid #000000; border-radius: 0; font-size: 13px; min-width: 150px;"
              />
              <button id="audit-apply-filters" style="padding: 12px 24px; background: #000000; color: #ffffff; border: 1px solid #000000; border-radius: 0; cursor: pointer; font-size: 11px; text-transform: uppercase; letter-spacing: 0.5px; transition: all 0.2s ease;">Apply Filters</button>
              <button id="audit-clear-filters" style="padding: 12px 24px; background: #ffffff; color: #000000; border: 1px solid #000000; border-radius: 0; cursor: pointer; font-size: 11px; text-transform: uppercase; letter-spacing: 0.5px; transition: all 0.2s ease;">Clear</button>
            </div>
          </div>

          <!-- Stats -->
          <div id="audit-stats" style="margin-bottom: 30px; padding: 20px; background: #f5f5f5; border: 1px solid #000000; display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px;">
            <div>
              <div style="font-size: 11px; text-transform: uppercase; letter-spacing: 0.5px; color: #666666; margin-bottom: 5px;">Total Logs</div>
              <div id="audit-total-logs" style="font-size: 24px; font-weight: 400; color: #000000;">-</div>
            </div>
            <div>
              <div style="font-size: 11px; text-transform: uppercase; letter-spacing: 0.5px; color: #666666; margin-bottom: 5px;">Last 24h</div>
              <div id="audit-logs-24h" style="font-size: 24px; font-weight: 400; color: #000000;">-</div>
            </div>
          </div>

          <!-- Logs List -->
          <div id="audit-logs-list" style="border: 1px solid #000000;">
            <p style="padding: 20px; text-align: center; color: #666666;">Loading audit logs...</p>
          </div>

          <!-- Pagination -->
          <div id="audit-pagination" style="margin-top: 20px; display: flex; justify-content: center; align-items: center; gap: 10px;"></div>
        </div>
      </div>
    </div>

    <!-- Modal de Preview -->
    <div id="preview-modal" class="preview-modal">
      <div class="preview-content">
        <div class="preview-header">
          <h3>Post Preview</h3>
          <button class="preview-close" id="preview-close-btn">Close</button>
        </div>
        <div id="preview-post" class="preview-post">
          <!-- El contenido del preview se insertará aquí -->
        </div>
      </div>
    </div>

    <!-- Modal de Editor de Imágenes -->
    <div id="image-editor-modal" class="preview-modal">
      <div class="preview-content" style="max-width: 900px;">
        <div class="preview-header">
          <h3>Edit Image</h3>
          <button class="preview-close" id="image-editor-close-btn">Close</button>
        </div>
        <div style="padding: 20px 0;">
          <div id="image-editor-container" style="max-width: 100%; margin: 0 auto;">
            <img id="image-editor-img" style="max-width: 100%; display: block;" />
          </div>
          <div style="margin-top: 20px; display: flex; gap: 10px; justify-content: center;">
            <button id="image-editor-crop-btn" style="padding: 12px 24px; background: #000000; color: #ffffff; border: 1px solid #000000; border-radius: 0; cursor: pointer; font-size: 11px; text-transform: uppercase; letter-spacing: 0.5px; transition: all 0.2s ease;">Crop & Upload</button>
            <button id="image-editor-cancel-btn" style="padding: 12px 24px; background: #ffffff; color: #000000; border: 1px solid #000000; border-radius: 0; cursor: pointer; font-size: 11px; text-transform: uppercase; letter-spacing: 0.5px; transition: all 0.2s ease;">Cancel</button>
          </div>
        </div>
      </div>
    </div>

    <!-- Modal de Editor de Slideshow -->
    <div id="slideshow-editor-modal" class="preview-modal">
      <div class="preview-content" style="max-width: 1200px; width: 95%;">
        <div class="preview-header">
          <h3>Slideshow Editor</h3>
          <button class="preview-close" id="slideshow-editor-close-btn">Close</button>
        </div>
        <div style="padding: 20px 0;">
          <!-- Configuración del slideshow -->
          <div style="margin-bottom: 30px; padding: 20px; background: #f9f9f9; border: 1px solid #ddd;">
            <label style="font-size: 12px; text-transform: uppercase; font-weight: bold; display: block; margin-bottom: 15px;">Slideshow Settings</label>
            
            <p style="font-size: 11px; color: #666; margin-bottom: 15px; font-style: italic;">
              Note: Image dimensions will be determined by the frontend based on layout (full, half, etc.).
            </p>
            
            <div style="margin-bottom: 15px;">
              <label style="display: flex; align-items: center; gap: 8px; font-size: 12px;">
                <input type="checkbox" id="slideshow-modal-show-arrows" style="width: auto;" />
                <span>Show navigation arrows</span>
              </label>
            </div>
            
            <div style="margin-bottom: 15px;">
              <label style="display: flex; align-items: center; gap: 8px; font-size: 12px;">
                <input type="checkbox" id="slideshow-modal-autoplay" style="width: auto;" />
                <span>Auto-play (automatic transition)</span>
              </label>
            </div>
            
            <div>
              <label style="display: block; margin-bottom: 5px; font-size: 11px; color: #666;">Interval (seconds)</label>
              <select id="slideshow-modal-interval" style="width: 100%; padding: 8px; border: 1px solid #000; font-size: 13px;">
                <option value="2">2 seconds</option>
                <option value="3">3 seconds</option>
                <option value="4">4 seconds</option>
                <option value="5" selected>5 seconds</option>
                <option value="6">6 seconds</option>
                <option value="8">8 seconds</option>
                <option value="10">10 seconds</option>
              </select>
            </div>
          </div>

          <!-- Preview del slideshow -->
          <div style="margin-bottom: 30px; padding: 20px; background: #ffffff; border: 1px solid #ddd;">
            <label style="font-size: 12px; text-transform: uppercase; font-weight: bold; display: block; margin-bottom: 15px;">Slideshow Preview</label>
            <div id="slideshow-preview-container" style="position: relative; width: 100%; max-width: 800px; margin: 0 auto; border: 1px solid #000; background: #f0f0f0;">
              <!-- El preview se generará dinámicamente -->
            </div>
          </div>

          <!-- Lista de imágenes para editar -->
          <div style="margin-bottom: 20px;">
            <label style="font-size: 12px; text-transform: uppercase; font-weight: bold; display: block; margin-bottom: 15px;">Edit Individual Images</label>
            <div id="slideshow-images-editor-list" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 20px;">
              <!-- Las imágenes se añadirán dinámicamente -->
            </div>
          </div>

          <!-- Botones de acción -->
          <div style="margin-top: 30px; display: flex; gap: 10px; justify-content: center;">
            <button id="slideshow-editor-save-btn" style="padding: 12px 24px; background: #000000; color: #ffffff; border: 1px solid #000000; border-radius: 0; cursor: pointer; font-size: 11px; text-transform: uppercase; letter-spacing: 0.5px; transition: all 0.2s ease;">Save Changes</button>
            <button id="slideshow-editor-cancel-btn" style="padding: 12px 24px; background: #ffffff; color: #000000; border: 1px solid #000000; border-radius: 0; cursor: pointer; font-size: 11px; text-transform: uppercase; letter-spacing: 0.5px; transition: all 0.2s ease;">Cancel</button>
          </div>
        </div>
      </div>
    </div>

    <!-- Cropper.js CSS and JS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.13/cropper.min.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.13/cropper.min.js"></script>
    
    <!-- Quill Editor JS -->
    <script src="https://cdn.quilljs.com/1.3.6/quill.js"></script>
    <script>
      // Detectar entorno y configurar URLs dinámicamente
      const isLocalhost = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
      const API_URL = isLocalhost ? "http://localhost:3000" : window.location.origin;
      const FRONTEND_BASE_URL = isLocalhost ? "http://localhost:5173" : window.location.origin;
      
      let editingPostId = null;
      let currentUser = null;
      let quillEditor = null;
      let tags = [];
      let sections = [];
      let selectedTags = [];
      let currentPage = 1;
      let selectedSectionId = null; // Sección seleccionada en el menú
      let sites = []; // Sitios disponibles para el usuario
      let currentSiteId = null; // ID del sitio actualmente seleccionado
      let isAdmin = false; // Si el usuario es administrador
      let userModeView = false; // Si está activada la vista de usuario normal (sin privilegios de admin)
      let currentFrontendProfile = null; // Frontend profile del site actual
      let isRedirecting = false; // Bandera para evitar múltiples redirecciones
      let currentFilters = {
        search: "",
        published: "",
        tagId: "",
        sectionId: "",
      };

      // Inicializar editor Quill
      function initQuillEditor() {
        const container = document.getElementById('editor-container');
        if (!container) {
          console.error('Editor container not found (#editor-container)');
          return;
        }
        
        if (typeof Quill === 'undefined') {
          console.error('Quill is not loaded. Check your internet connection or the CDN.');
          // Reintentar después de un momento
          setTimeout(initQuillEditor, 500);
          return;
        }
        
        try {
          // Registrar Blot personalizado para vídeos (YouTube/Vimeo)
          const BlockEmbed = Quill.import('blots/block/embed');
          
          class VideoBlot extends BlockEmbed {
            static create(value) {
              const node = super.create();
              node.setAttribute('contenteditable', 'false');
              // value es el HTML completo del iframe
              if (typeof value === 'string') {
                node.innerHTML = value;
              }
              return node;
            }
            
            static value(node) {
              return node.innerHTML;
            }
            
            static formats() {
              return true;
            }
            
            // Permitir que se pueda insertar contenido después del vídeo
            length() {
              return 1;
            }
            
            // Asegurar que el vídeo se comporte como un bloque
            static blotName = 'video';
            static tagName = 'div';
            static className = 'ql-video-embed';
          }
          
          VideoBlot.blotName = 'video';
          VideoBlot.tagName = 'div';
          VideoBlot.className = 'ql-video-embed';
          
          Quill.register(VideoBlot, true);
          
          // Registrar Blot personalizado para Instagram
          class InstagramBlot extends BlockEmbed {
            static create(value) {
              const node = super.create();
              node.setAttribute('contenteditable', 'false');
              if (typeof value === 'string') {
                node.innerHTML = value;
              }
              return node;
            }
            
            static value(node) {
              return node.innerHTML;
            }
            
            static formats() {
              return true;
            }
            
            length() {
              return 1;
            }
            
            static blotName = 'instagram';
            static tagName = 'div';
            static className = 'ql-instagram-embed';
          }
          
          InstagramBlot.blotName = 'instagram';
          InstagramBlot.tagName = 'div';
          InstagramBlot.className = 'ql-instagram-embed';
          
          Quill.register(InstagramBlot, true);
          
          // Registrar Blot personalizado para SoundCloud
          class SoundCloudBlot extends BlockEmbed {
            static create(value) {
              const node = super.create();
              node.setAttribute('contenteditable', 'false');
              if (typeof value === 'string') {
                node.innerHTML = value;
              }
              return node;
            }
            
            static value(node) {
              return node.innerHTML;
            }
            
            static formats() {
              return true;
            }
            
            length() {
              return 1;
            }
            
            static blotName = 'soundcloud';
            static tagName = 'div';
            static className = 'ql-soundcloud-embed';
          }
          
          SoundCloudBlot.blotName = 'soundcloud';
          SoundCloudBlot.tagName = 'div';
          SoundCloudBlot.className = 'ql-soundcloud-embed';
          
          Quill.register(SoundCloudBlot, true);
          
          // Añadir iconos personalizados para Instagram y SoundCloud
          const icons = Quill.import('ui/icons');
          icons['instagram'] = '<svg viewBox="0 0 24 24" width="18" height="18"><path fill="currentColor" d="M12 2.163c3.204 0 3.584.012 4.85.07 3.252.148 4.771 1.691 4.919 4.919.058 1.265.069 1.645.069 4.849 0 3.205-.012 3.584-.069 4.849-.149 3.225-1.664 4.771-4.919 4.919-1.266.058-1.644.07-4.85.07-3.204 0-3.584-.012-4.849-.07-3.26-.149-4.771-1.699-4.919-4.92-.058-1.265-.07-1.644-.07-4.849 0-3.204.013-3.583.07-4.849.149-3.227 1.664-4.771 4.919-4.919 1.266-.057 1.645-.069 4.849-.069zm0-2.163c-3.259 0-3.667.014-4.947.072-4.358.2-6.78 2.618-6.98 6.98-.059 1.281-.073 1.689-.073 4.948 0 3.259.014 3.668.072 4.948.2 4.358 2.618 6.78 6.98 6.98 1.281.058 1.689.072 4.948.072 3.259 0 3.668-.014 4.948-.072 4.354-.2 6.782-2.618 6.979-6.98.059-1.28.073-1.689.073-4.948 0-3.259-.014-3.667-.072-4.947-.196-4.354-2.617-6.78-6.979-6.98-1.281-.059-1.69-.073-4.949-.073zm0 5.838c-3.403 0-6.162 2.759-6.162 6.162s2.759 6.163 6.162 6.163 6.162-2.759 6.162-6.163c0-3.403-2.759-6.162-6.162-6.162zm0 10.162c-2.209 0-4-1.79-4-4 0-2.209 1.791-4 4-4s4 1.791 4 4c0 2.21-1.791 4-4 4zm6.406-11.845c-.796 0-1.441.645-1.441 1.44s.645 1.44 1.441 1.441c.795.001 1.439-.643 1.439-1.44.001-.795-.644-1.44-1.439-1.44z"/></svg>';
          icons['soundcloud'] = '<img src="soundcloud-icon.png" alt="SoundCloud" style="width: 18px; height: 18px; display: block;" />';
          
          quillEditor = new Quill('#editor-container', {
            theme: 'snow',
            modules: {
              toolbar: {
                container: [
                  [{ 'header': [1, 2, 3, 4, 5, 6, false] }],
                  ['bold', 'italic', 'underline', 'strike'],
                  [{ 'color': [] }, { 'background': [] }],
                  [{ 'list': 'ordered'}, { 'list': 'bullet' }],
                  [{ 'align': [] }],
                  ['link', 'image', 'video'],
                  ['clean']
                ],
                handlers: {
                  'image': function() {
                    // Personalizar el handler del botón de imagen
                    const url = prompt('Paste the image URL (Imgur or other hosting):\n\nExample: https://imgur.com/9S1xRRy or https://i.imgur.com/example.jpg');
                    
                    if (url && url.trim() !== '') {
                      // Validar y convertir URL de Imgur si es necesario
                      let imageUrl = url.trim();
                      
                      // Si es una URL de Imgur, convertirla a URL directa
                      if (imageUrl.includes('imgur.com') && !imageUrl.includes('i.imgur.com')) {
                        const imgurPatterns = [
                          /imgur\.com\/([a-zA-Z0-9]+)$/, // Post individual
                          /imgur\.com\/a\/([a-zA-Z0-9]+)/, // Álbum
                          /imgur\.com\/gallery\/([a-zA-Z0-9]+)/, // Gallery
                        ];
                        
                        for (const pattern of imgurPatterns) {
                          const match = imageUrl.match(pattern);
                          if (match) {
                            const imageId = match[1];
                            imageUrl = `https://i.imgur.com/${imageId}.jpg`;
                            break;
                          }
                        }
                      }
                      
                      // Validar que sea una URL válida
                      try {
                        new URL(imageUrl);
                        // Obtener el rango de selección actual
                        const range = quillEditor.getSelection(true);
                        const insertIndex = range.index;
                        
                        // Insertar la imagen en la posición del cursor
                        quillEditor.insertEmbed(insertIndex, 'image', imageUrl, 'user');
                        
                        // Abrir el modal de edición inmediatamente después de insertar
                        setTimeout(function() {
                          // Buscar el elemento img recién insertado
                          const images = quillEditor.root.querySelectorAll('img');
                          let insertedImg = null;
                          for (let img of images) {
                            if (img.src === imageUrl || img.src.includes(imageUrl.split('/').pop())) {
                              insertedImg = img;
                              break;
                            }
                          }
                          if (insertedImg) {
                            currentImageElement = insertedImg;
                          }
                          openImageEditor(imageUrl, insertIndex);
                        }, 100);
                      } catch (e) {
                        alert('Invalid URL. Please enter a valid URL (e.g., https://imgur.com/9S1xRRy)');
                      }
                    }
                  },
                  'video': function() {
                    // Handler personalizado para insertar vídeos (YouTube o Vimeo)
                    // Detecta automáticamente el tipo de vídeo desde la URL
                    const videoUrl = prompt('Paste the video URL (YouTube or Vimeo):\n\nExamples:\n• YouTube: https://www.youtube.com/watch?v=VIDEO_ID or https://youtu.be/VIDEO_ID\n• Vimeo: https://vimeo.com/VIDEO_ID or https://player.vimeo.com/video/VIDEO_ID');
                    
                    if (!videoUrl || videoUrl.trim() === '') {
                      return;
                    }
                    
                    const url = videoUrl.trim();
                    let embedHtml = '';
                    
                    // Intentar detectar YouTube primero
                    const youtubeId = extractYouTubeId(url);
                    if (youtubeId) {
                      embedHtml = createYouTubeEmbed(youtubeId, url);
                    } else {
                      // Si no es YouTube, intentar Vimeo
                      const vimeoId = extractVimeoId(url);
                      if (vimeoId) {
                        embedHtml = createVimeoEmbed(vimeoId, url);
                      } else {
                        // Si no es ni YouTube ni Vimeo, mostrar error
                        alert('Unrecognized URL. Please enter a valid YouTube or Vimeo URL.\n\nExamples:\n• YouTube: https://www.youtube.com/watch?v=VIDEO_ID\n• Vimeo: https://vimeo.com/VIDEO_ID');
                        return;
                      }
                    }
                    
                    if (embedHtml) {
                      // Obtener el rango de selección actual
                      const range = quillEditor.getSelection(true);
                      let index = range ? range.index : quillEditor.getLength();
                      
                      // Insertar un salto de línea antes del vídeo si no estamos al inicio y hay texto antes
                      if (index > 0) {
                        const textBefore = quillEditor.getText(Math.max(0, index - 1), 1);
                        if (textBefore && textBefore !== '\n') {
                          quillEditor.insertText(index, '\n', 'user');
                          index += 1; // Actualizar el índice después de insertar el salto de línea
                        }
                      }
                      
                      // Insertar el vídeo usando el Blot personalizado
                      quillEditor.insertEmbed(index, 'video', embedHtml, 'user');
                      
                      // Insertar un salto de línea después del vídeo para poder escribir texto
                      const newIndex = index + 1;
                      quillEditor.insertText(newIndex, '\n', 'user');
                      
                      // Mover el cursor después del vídeo y el salto de línea
                      quillEditor.setSelection(newIndex + 1);
                    }
                  },
                  'link': function(value) {
                    // Personalizar el handler del botón de enlace para mejor UX
                    // Usar quillEditor directamente en lugar de this.quill
                    const quill = quillEditor;
                    
                    if (value && typeof value === 'string') {
                      // Si ya hay un enlace seleccionado, editarlo
                      const url = prompt('Edit link URL:', value);
                      if (url && url.trim() !== '' && url !== 'https://') {
                        try {
                          new URL(url);
                          const range = quill.getSelection(true);
                          if (range) {
                            quill.formatText(range.index, range.length, 'link', url);
                          }
                        } catch (e) {
                          alert('Invalid URL. Please enter a valid URL (e.g., https://example.com)');
                        }
                      }
                    } else {
                      // Obtener el texto seleccionado
                      const range = quill.getSelection(true);
                      if (!range) {
                        // Si no hay selección, pedir texto y URL
                        const text = prompt('Link text:');
                        if (!text || text.trim() === '') {
                          return;
                        }
                        const url = prompt('Link URL:', 'https://');
                        if (url && url.trim() !== '' && url !== 'https://') {
                          try {
                            new URL(url);
                            const insertRange = quill.getSelection(true) || { index: quill.getLength() };
                            quill.insertText(insertRange.index, text, 'user');
                            quill.formatText(insertRange.index, text.length, 'link', url);
                            quill.setSelection(insertRange.index + text.length);
                          } catch (e) {
                            alert('Invalid URL. Please enter a valid URL (e.g., https://example.com)');
                          }
                        }
                        return;
                      }
                      
                      let text = quill.getText(range.index, range.length);
                      
                      // Si no hay texto seleccionado, pedir el texto también
                      if (!text || text.trim() === '') {
                        text = prompt('Texto del enlace:');
                        if (!text || text.trim() === '') {
                          return;
                        }
                      }
                      
                      // Pedir la URL
                      const url = prompt('URL del enlace:', 'https://');
                      
                      if (url && url.trim() !== '' && url !== 'https://') {
                        try {
                          // Validar URL
                          new URL(url);
                          
                          // Si no había texto seleccionado, insertar el texto y luego el enlace
                          if (range.length === 0) {
                            quill.insertText(range.index, text, 'user');
                            quill.formatText(range.index, text.length, 'link', url);
                            quill.setSelection(range.index + text.length);
                          } else {
                            // Si había texto seleccionado, solo aplicar el enlace
                            quill.formatText(range.index, range.length, 'link', url);
                          }
                        } catch (e) {
                          alert('Invalid URL. Please enter a valid URL (e.g., https://example.com)');
                        }
                      }
                    }
                  },
                  'instagram': function() {
                    // Handler personalizado para insertar embeds de Instagram
                    const instagramUrl = prompt('Paste the Instagram URL (post or reel):\n\nExamples:\n• https://www.instagram.com/p/POST_ID/\n• https://www.instagram.com/reel/REEL_ID/');
                    
                    if (!instagramUrl || instagramUrl.trim() === '') {
                      return;
                    }
                    
                    const url = instagramUrl.trim();
                    const embedHtml = createInstagramEmbed(url);
                    
                    if (embedHtml) {
                      const range = quillEditor.getSelection(true);
                      let index = range ? range.index : quillEditor.getLength();
                      
                      // Siempre insertar un salto de línea antes del embed
                      if (index > 0) {
                        const textBefore = quillEditor.getText(Math.max(0, index - 1), 1);
                        if (textBefore && textBefore !== '\n') {
                          quillEditor.insertText(index, '\n', 'user');
                          index += 1;
                        }
                      } else {
                        // Si estamos al inicio, insertar un salto de línea
                        quillEditor.insertText(index, '\n', 'user');
                        index += 1;
                      }
                      
                      // Insertar el embed
                      quillEditor.insertEmbed(index, 'instagram', embedHtml, 'user');
                      
                      // Siempre insertar un salto de línea después del embed
                      const newIndex = index + 1;
                      quillEditor.insertText(newIndex, '\n', 'user');
                      
                      // Posicionar el cursor después del salto de línea para poder escribir
                      quillEditor.setSelection(newIndex + 1);
                    }
                  },
                  'soundcloud': function() {
                    // Handler personalizado para insertar embeds de SoundCloud
                    const soundcloudUrl = prompt('Paste the SoundCloud URL:\n\nExamples:\n• Full profile (shows recent tracks): https://soundcloud.com/USER\n• Specific track: https://soundcloud.com/USER/TRACK_NAME');
                    
                    if (!soundcloudUrl || soundcloudUrl.trim() === '') {
                      return;
                    }
                    
                    const url = soundcloudUrl.trim();
                    const embedHtml = createSoundCloudEmbed(url);
                    
                    if (embedHtml) {
                      const range = quillEditor.getSelection(true);
                      let index = range ? range.index : quillEditor.getLength();
                      
                      // Siempre insertar un salto de línea antes del embed
                      if (index > 0) {
                        const textBefore = quillEditor.getText(Math.max(0, index - 1), 1);
                        if (textBefore && textBefore !== '\n') {
                          quillEditor.insertText(index, '\n', 'user');
                          index += 1;
                        }
                      } else {
                        // Si estamos al inicio, insertar un salto de línea
                        quillEditor.insertText(index, '\n', 'user');
                        index += 1;
                      }
                      
                      // Insertar el embed
                      quillEditor.insertEmbed(index, 'soundcloud', embedHtml, 'user');
                      
                      // Siempre insertar un salto de línea después del embed
                      const newIndex = index + 1;
                      quillEditor.insertText(newIndex, '\n', 'user');
                      
                      // Posicionar el cursor después del salto de línea para poder escribir
                      quillEditor.setSelection(newIndex + 1);
                    }
                  }
                }
              }
            },
            placeholder: 'Write your post content here...'
          });

          // Actualizar el campo hidden cuando el editor cambia
          quillEditor.on('text-change', function() {
            const content = quillEditor.root.innerHTML;
            const contentField = document.getElementById('content');
            if (contentField) {
              contentField.value = content;
            }
          });
          
          // Añadir botones personalizados manualmente al toolbar
          setTimeout(function() {
            const toolbar = quillEditor.container.previousElementSibling;
            if (toolbar && toolbar.classList.contains('ql-toolbar')) {
              // Buscar el grupo que contiene 'video' para añadir los botones después
              const videoButton = toolbar.querySelector('.ql-video');
              if (videoButton) {
                // Insertar los botones directamente después del botón de video
                // sin crear un nuevo grupo para evitar el recuadro gris
                
                // Crear botón de Instagram
                const instagramButton = document.createElement('button');
                instagramButton.type = 'button';
                instagramButton.className = 'ql-instagram';
                instagramButton.setAttribute('title', 'Instagram');
                instagramButton.setAttribute('aria-label', 'Instagram');
                instagramButton.innerHTML = '<svg viewBox="0 0 24 24" width="18" height="18"><path fill="currentColor" d="M12 2.163c3.204 0 3.584.012 4.85.07 3.252.148 4.771 1.691 4.919 4.919.058 1.265.069 1.645.069 4.849 0 3.205-.012 3.584-.069 4.849-.149 3.225-1.664 4.771-4.919 4.919-1.266.058-1.644.07-4.85.07-3.204 0-3.584-.012-4.849-.07-3.26-.149-4.771-1.699-4.919-4.92-.058-1.265-.07-1.644-.07-4.849 0-3.204.013-3.583.07-4.849.149-3.227 1.664-4.771 4.919-4.919 1.266-.057 1.645-.069 4.849-.069zm0-2.163c-3.259 0-3.667.014-4.947.072-4.358.2-6.78 2.618-6.98 6.98-.059 1.281-.073 1.689-.073 4.948 0 3.259.014 3.668.072 4.948.2 4.358 2.618 6.78 6.98 6.98 1.281.058 1.689.072 4.948.072 3.259 0 3.668-.014 4.948-.072 4.354-.2 6.782-2.618 6.979-6.98.059-1.28.073-1.689.073-4.948 0-3.259-.014-3.667-.072-4.947-.196-4.354-2.617-6.78-6.979-6.98-1.281-.059-1.69-.073-4.949-.073zm0 5.838c-3.403 0-6.162 2.759-6.162 6.162s2.759 6.163 6.162 6.163 6.162-2.759 6.162-6.163c0-3.403-2.759-6.162-6.162-6.162zm0 10.162c-2.209 0-4-1.79-4-4 0-2.209 1.791-4 4-4s4 1.791 4 4c0 2.21-1.791 4-4 4zm6.406-11.845c-.796 0-1.441.645-1.441 1.44s.645 1.44 1.441 1.441c.795.001 1.439-.643 1.439-1.44.001-.795-.644-1.44-1.439-1.44z"/></svg>';
                instagramButton.addEventListener('click', function(e) {
                  e.preventDefault();
                  e.stopPropagation();
                  const instagramUrl = prompt('Pega la URL de Instagram (post o reel):\n\nEjemplos:\n• https://www.instagram.com/p/POST_ID/\n• https://www.instagram.com/reel/REEL_ID/');
                  
                  if (!instagramUrl || instagramUrl.trim() === '') {
                    return;
                  }
                  
                  const url = instagramUrl.trim();
                  const embedHtml = createInstagramEmbed(url);
                  
                  if (embedHtml) {
                    const range = quillEditor.getSelection(true);
                    let index = range ? range.index : quillEditor.getLength();
                    
                    // Siempre insertar un salto de línea antes del embed
                    if (index > 0) {
                      const textBefore = quillEditor.getText(Math.max(0, index - 1), 1);
                      if (textBefore && textBefore !== '\n') {
                        quillEditor.insertText(index, '\n', 'user');
                        index += 1;
                      }
                    } else {
                      // Si estamos al inicio, insertar un salto de línea
                      quillEditor.insertText(index, '\n', 'user');
                      index += 1;
                    }
                    
                    // Insertar el embed
                    quillEditor.insertEmbed(index, 'instagram', embedHtml, 'user');
                    
                    // Siempre insertar un salto de línea después del embed
                    const newIndex = index + 1;
                    quillEditor.insertText(newIndex, '\n', 'user');
                    
                    // Posicionar el cursor después del salto de línea para poder escribir
                    quillEditor.setSelection(newIndex + 1);
                  }
                });
                
                // Crear botón de SoundCloud
                const soundcloudButton = document.createElement('button');
                soundcloudButton.type = 'button';
                soundcloudButton.className = 'ql-soundcloud';
                soundcloudButton.setAttribute('title', 'SoundCloud');
                soundcloudButton.setAttribute('aria-label', 'SoundCloud');
                soundcloudButton.innerHTML = '<img src="soundcloud-icon.png" alt="SoundCloud" style="width: 18px; height: 18px; display: block; margin: 0 auto;" />';
                soundcloudButton.addEventListener('click', function(e) {
                  e.preventDefault();
                  e.stopPropagation();
                  const soundcloudUrl = prompt('Pega la URL de SoundCloud:\n\nEjemplos:\n• Perfil completo (muestra tracks recientes): https://soundcloud.com/USER\n• Track específico: https://soundcloud.com/USER/TRACK_NAME');
                  
                  if (!soundcloudUrl || soundcloudUrl.trim() === '') {
                    return;
                  }
                  
                  const url = soundcloudUrl.trim();
                  const embedHtml = createSoundCloudEmbed(url);
                  
                  if (embedHtml) {
                    const range = quillEditor.getSelection(true);
                    let index = range ? range.index : quillEditor.getLength();
                    
                    // Siempre insertar un salto de línea antes del embed
                    if (index > 0) {
                      const textBefore = quillEditor.getText(Math.max(0, index - 1), 1);
                      if (textBefore && textBefore !== '\n') {
                        quillEditor.insertText(index, '\n', 'user');
                        index += 1;
                      }
                    } else {
                      // Si estamos al inicio, insertar un salto de línea
                      quillEditor.insertText(index, '\n', 'user');
                      index += 1;
                    }
                    
                    // Insertar el embed
                    quillEditor.insertEmbed(index, 'soundcloud', embedHtml, 'user');
                    
                    // Siempre insertar un salto de línea después del embed
                    const newIndex = index + 1;
                    quillEditor.insertText(newIndex, '\n', 'user');
                    
                    // Posicionar el cursor después del salto de línea para poder escribir
                    quillEditor.setSelection(newIndex + 1);
                  }
                });
                
                // Insertar los botones directamente después del botón de video en el mismo grupo
                videoButton.parentElement.insertBefore(instagramButton, videoButton.nextSibling);
                videoButton.parentElement.insertBefore(soundcloudButton, instagramButton.nextSibling);
                
                console.log('✅ Botones de Instagram y SoundCloud añadidos al toolbar');
              }
            }
          }, 100);
          
          console.log('✅ Editor Quill inicializado correctamente');
          
          // Detectar clicks en imágenes dentro del editor Quill
          quillEditor.root.addEventListener('click', function(e) {
            if (e.target.tagName === 'IMG') {
              e.preventDefault();
              e.stopPropagation();
              
              const imgElement = e.target;
              const imgUrl = imgElement.src;
              
              // Guardar referencia al elemento
              currentImageElement = imgElement;
              
              // Buscar la imagen en el contenido del editor
              const contents = quillEditor.getContents();
              let imageIndex = null;
              
              // Buscar la imagen en el contenido
              for (let i = 0; i < contents.length(); i++) {
                const op = quillEditor.getContents(i, 1);
                if (op.ops && op.ops[0] && op.ops[0].insert && typeof op.ops[0].insert === 'object' && op.ops[0].insert.image) {
                  const storedImgUrl = op.ops[0].insert.image;
                  // Comparar URLs (pueden tener parámetros diferentes)
                  if (storedImgUrl === imgUrl || 
                      storedImgUrl.includes(imgUrl.split('/').pop()) || 
                      imgUrl.includes(storedImgUrl.split('/').pop())) {
                    imageIndex = i;
                    break;
                  }
                }
              }
              
              openImageEditor(imgUrl, imageIndex);
            }
          });
        } catch (error) {
          console.error('Error al inicializar Quill:', error);
        }
      }

      // Esperar a que Quill se cargue desde el CDN
      function waitForQuill() {
        if (typeof Quill !== 'undefined') {
          // Quill está cargado, inicializar
          if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initQuillEditor);
          } else {
            initQuillEditor();
          }
        } else {
          // Quill aún no está cargado, esperar un poco más
          setTimeout(waitForQuill, 100);
        }
      }

      // Iniciar la espera de Quill
      waitForQuill();

      // Helper para obtener headers con JWT token
      function getAuthHeaders(additionalHeaders = {}) {
        const token = localStorage.getItem('auth_token');
        const headers = {
          'Content-Type': 'application/json',
          ...additionalHeaders,
        };
        if (token) {
          headers['Authorization'] = `Bearer ${token}`;
        }
        return headers;
      }

      // Helper para hacer fetch con autenticación JWT automática
      async function authFetch(url, options = {}) {
        const token = localStorage.getItem('auth_token');
        const headers = {
          'Content-Type': 'application/json',
          ...(options.headers || {}),
        };
        if (token) {
          headers['Authorization'] = `Bearer ${token}`;
          console.log("[authFetch] ✅ Adding Authorization header with token (length:", token.length, ")");
        } else {
          console.warn("[authFetch] ⚠️ No token found in localStorage");
        }
        
        console.log("[authFetch] Making request to:", url);
        console.log("[authFetch] Headers:", Object.keys(headers));
        
        return fetch(url, {
          ...options,
          headers,
          credentials: options.credentials !== undefined ? options.credentials : "include",
        });
      }

      // Cargar sitios del usuario
      async function loadSites() {
        try {
          console.log("[Load Sites] Fetching sites from API...");
          const res = await authFetch(`${API_URL}/sites`);
          console.log("[Load Sites] Response status:", res.status, res.statusText);
          
          if (res.ok) {
            sites = await res.json();
            console.log("[Load Sites] Sites received:", sites.length, sites);
            
            // Si es admin, mostrar selector de sitios (solo si no está en modo usuario)
            if (isAdmin && sites.length > 0) {
              // SIEMPRE establecer currentSiteId, incluso si está en modo usuario
              // Si hay un sitio guardado en localStorage, seleccionarlo
              const savedSiteId = localStorage.getItem("selectedSiteId");
              if (savedSiteId && sites.find(s => s.id === parseInt(savedSiteId))) {
                currentSiteId = parseInt(savedSiteId);
              } else if (sites.length > 0) {
                // Si no hay sitio guardado, seleccionar el primero
                currentSiteId = sites[0].id;
                localStorage.setItem("selectedSiteId", sites[0].id);
              }
              
              // Solo mostrar el selector si NO está en modo usuario
              if (!userModeView) {
                const container = document.getElementById("site-selector-container");
                const selector = document.getElementById("site-selector");
                
                container.style.display = "block";
                selector.innerHTML = '<option value="">Select a site...</option>';
                
                sites.forEach(site => {
                  const option = document.createElement("option");
                  option.value = site.id;
                  option.textContent = `${site.name} (${site.slug})`;
                  selector.appendChild(option);
                });
                
                // Establecer el valor del selector
                if (currentSiteId) {
                  selector.value = currentSiteId;
                }
                
                // Event listener para cambiar de sitio
                selector.addEventListener("change", async function(e) {
                  const newSiteId = parseInt(e.target.value);
                  if (newSiteId) {
                    currentSiteId = newSiteId;
                    localStorage.setItem("selectedSiteId", newSiteId);
                    // Recargar datos del nuevo sitio
                    await loadFrontendProfile(newSiteId);
                    loadSections();
                    loadTags();
                    loadPosts(1);
                  }
                });
              }
            } else if (!isAdmin && sites.length > 0) {
              // Si no es admin, usar su único sitio automáticamente
              currentSiteId = sites[0].id;
            }
            
            console.log("[Load Sites] currentSiteId set to:", currentSiteId);
            
            return sites.length > 0;
          } else {
            console.error("[Load Sites] Response not OK:", res.status, res.statusText);
            const errorText = await res.text();
            console.error("[Load Sites] Error response:", errorText);
          }
          return false;
        } catch (err) {
          console.error("[Load Sites] Error loading sites:", err);
          return false;
        }
      }

      // Verificar autenticación (con JWT)
      async function checkAuth() {
        // Evitar múltiples redirecciones simultáneas
        if (isRedirecting) {
          console.log("[checkAuth] Already redirecting, skipping...");
          return false;
        }
        
        try {
          console.log("[checkAuth] ========== STARTING AUTH CHECK ==========");
          const token = localStorage.getItem('auth_token');
          console.log("[checkAuth] JWT token present:", !!token);
          console.log("[checkAuth] Token value (first 20 chars):", token ? token.substring(0, 20) + "..." : "null");
          console.log("[checkAuth] API_URL:", API_URL);
          
          if (!authFetch) {
            console.error("[checkAuth] ❌ authFetch is not defined!");
            throw new Error("authFetch is not defined");
          }
          
          const res = await authFetch(`${API_URL}/auth/me`);
          
          console.log("[checkAuth] Response status:", res.status);
          console.log("[checkAuth] Response headers:", {
            'content-type': res.headers.get('content-type'),
            'authorization': res.headers.get('authorization')
          });
          
          if (!res.ok) {
            console.log("[checkAuth] Not authenticated (status not OK), redirecting to login...");
            if (!isRedirecting) {
              isRedirecting = true;
              // Usar replace en vez de href para evitar que se pueda volver atrás
              window.location.replace("login.html");
            }
            return false;
          }

          const data = await res.json();
          console.log("[checkAuth] ✅ Response data:", JSON.stringify(data, null, 2));
          console.log("[checkAuth] Authenticated:", data.authenticated);
          console.log("[checkAuth] User:", data.user?.email || "No user");
          
          if (!data.authenticated) {
            console.error("[checkAuth] ❌ Not authenticated (data.authenticated = false)");
            console.error("[checkAuth] ❌ Full response:", data);
            console.log("[checkAuth] Not authenticated (data.authenticated = false), redirecting to login...");
            if (!isRedirecting) {
              isRedirecting = true;
              console.log("[checkAuth] 🔄 REDIRECTING TO LOGIN...");
              window.location.replace("login.html");
            }
            return false;
          }
          
          console.log("[checkAuth] ✅ Authentication successful!");

          currentUser = data.user;
          isAdmin = data.user.isAdmin || false;
          
          // Configurar el email del usuario
          const userInfoElement = document.getElementById("user-info");
          if (isAdmin) {
            // Si es admin, hacer el email clickeable para abrir audit logs
            userInfoElement.innerHTML = `<span style="cursor: pointer; text-decoration: underline;" id="user-email-clickable">${data.user.email}</span>`;
            // Remover listeners anteriores si existen
            const newUserInfoElement = document.getElementById("user-info");
            const clickableEmail = document.getElementById("user-email-clickable");
            if (clickableEmail) {
              clickableEmail.onclick = function(e) {
                e.stopPropagation();
                openAuditLogsModal();
              };
            }
            // Mostrar botón de vista de usuario solo para admins
            const viewUserModeBtn = document.getElementById("view-user-mode-btn");
            if (viewUserModeBtn) {
              viewUserModeBtn.style.display = "block";
              // Restaurar estado de vista de usuario desde localStorage
              const savedUserMode = localStorage.getItem("admin_user_mode_view");
              if (savedUserMode === "true") {
                userModeView = true;
                viewUserModeBtn.textContent = "View as Admin";
                applyUserModeView(true);
              }
            }
            // Mostrar/ocultar botones de crear/eliminar secciones según si es admin y no está en modo usuario
            updateSectionManagerAdminControls();
          } else {
            userInfoElement.textContent = data.user.email;
            // Para usuarios no admin, ocultar controles de admin
            updateSectionManagerAdminControls();
          }
          
          // No mostrar la sección de audit logs en la vista principal (solo en el modal)
          // Los audit logs se cargarán cuando se abra el modal
          
          // Cargar sitios después de autenticación
          const sitesLoaded = await loadSites();
          if (!sitesLoaded || !currentSiteId) {
            console.warn("[checkAuth] ⚠️ No sites available or currentSiteId is null");
            showMessage("No sites available. Please contact an administrator.", "error");
            // No redirigir aquí, solo mostrar el mensaje y retornar false
            // El usuario puede estar autenticado pero sin sitios asignados
            // IMPORTANTE: No redirigir a login si el usuario está autenticado pero sin sitios
            return false;
          }
          
          // Cargar frontend profile del site actual
          await loadFrontendProfile(currentSiteId);
          
          console.log("[checkAuth] ✅ Authentication and initialization complete");
          return true;
        } catch (err) {
          console.error("[checkAuth] ❌ Error:", err);
          // Solo redirigir si es un error de autenticación explícito (401)
          // NO redirigir por errores de red, CORS, o errores al cargar datos
          const errorMessage = err.message || err.toString() || "";
          const isAuthError = errorMessage.includes("401") || 
                             errorMessage.includes("Unauthorized") ||
                             (err.name && err.name.includes("401"));
          
          if (isAuthError) {
            console.log("[checkAuth] Auth error detected, redirecting to login...");
            if (!isRedirecting) {
              isRedirecting = true;
              // Usar replace en vez de href para evitar que se pueda volver atrás
              window.location.replace("login.html");
            }
          } else {
            // Para otros errores (red, CORS, etc.), NO redirigir
            // El usuario podría estar autenticado pero tener problemas de conexión
            console.error("[checkAuth] Non-auth error, NOT redirecting:", err);
            console.log("[checkAuth] This might be a network/CORS error, staying on page");
          }
          return false;
        }
      }

      // Logout
      async function logout() {
        try {
          await fetch(`${API_URL}/auth/logout`, {
            method: "POST",
            credentials: "include",
          });
          window.location.href = "login.html";
        } catch (err) {
          window.location.href = "login.html";
        }
      }

      // Registrar event listeners (el script está al final del body, así que el DOM ya está listo)
      // Logout button
      const logoutBtn = document.getElementById("logout-btn");
      if (logoutBtn) {
        logoutBtn.addEventListener("click", logout);
      } else {
        console.error("Logout button not found");
      }
      
      // Función para aplicar/remover vista de usuario normal
      // Actualizar controles de admin en el section manager
      function updateSectionManagerAdminControls() {
        const createSectionContainer = document.getElementById("create-section-container");
        const shouldShowAdminControls = isAdmin && !userModeView;
        
        if (createSectionContainer) {
          createSectionContainer.style.display = shouldShowAdminControls ? "block" : "none";
        }
        
        // Actualizar visibilidad de botones de delete en las secciones
        const deleteButtons = document.querySelectorAll(".section-manager-item-actions .delete-btn");
        deleteButtons.forEach(btn => {
          btn.style.display = shouldShowAdminControls ? "block" : "none";
        });
      }

      function applyUserModeView(enable) {
        const siteSelectorContainer = document.getElementById("site-selector-container");
        const userInfoElement = document.getElementById("user-info");
        const viewUserModeBtn = document.getElementById("view-user-mode-btn");
        
        if (enable) {
          // Ocultar elementos de admin
          if (siteSelectorContainer) {
            siteSelectorContainer.style.display = "none";
          }
          // Cambiar email clickeable a texto normal
          if (userInfoElement && isAdmin) {
            const clickableEmail = document.getElementById("user-email-clickable");
            if (clickableEmail) {
              userInfoElement.textContent = currentUser.email;
            }
          }
          if (viewUserModeBtn) {
            viewUserModeBtn.textContent = "View as Admin";
          }
        } else {
          // Mostrar elementos de admin
          if (siteSelectorContainer && isAdmin) {
            siteSelectorContainer.style.display = "block";
          }
          // Restaurar email clickeable
          if (userInfoElement && isAdmin) {
            userInfoElement.innerHTML = `<span style="cursor: pointer; text-decoration: underline;" id="user-email-clickable">${currentUser.email}</span>`;
            const clickableEmail = document.getElementById("user-email-clickable");
            if (clickableEmail) {
              clickableEmail.onclick = function(e) {
                e.stopPropagation();
                openAuditLogsModal();
              };
            }
          }
          if (viewUserModeBtn) {
            viewUserModeBtn.textContent = "View as User";
          }
        }
        
        // Actualizar controles de admin en section manager
        updateSectionManagerAdminControls();
      }
      
      // View as User button (solo para admins)
      const viewUserModeBtn = document.getElementById("view-user-mode-btn");
      if (viewUserModeBtn) {
        viewUserModeBtn.addEventListener("click", function() {
          userModeView = !userModeView;
          localStorage.setItem("admin_user_mode_view", userModeView.toString());
          applyUserModeView(userModeView);
        });
      }
      
        // Section manager toggle
        const sectionManagerHeader = document.getElementById("section-manager-header");
        if (sectionManagerHeader) {
          sectionManagerHeader.addEventListener("click", toggleSectionManager);
        }
        
        // Add thumbnail button (se registra después de que las funciones estén definidas)
        // Este event listener se registra más abajo, después de que todas las funciones estén definidas

      // Mostrar mensaje
      function showMessage(text, type = "success") {
        const msgEl = document.getElementById("message");
        msgEl.textContent = text;
        msgEl.className = `message ${type} show`;
        setTimeout(() => {
          msgEl.classList.remove("show");
        }, 5000);
      }


      // Cargar tags
      async function loadTags() {
        if (!currentSiteId) return;
        
        try {
          const res = await fetch(`${API_URL}/tags?siteId=${currentSiteId}`, {
            credentials: "include",
          });
          if (res.ok) {
            tags = await res.json();
            const filterTagSelect = document.getElementById("filter-tag");
            
            // Limpiar opciones existentes (excepto la primera)
            filterTagSelect.innerHTML = '<option value="">All tags</option>';
            
            tags.forEach(tag => {
              const option = document.createElement("option");
              option.value = tag.id;
              option.textContent = tag.name;
              filterTagSelect.appendChild(option);
            });
          }
        } catch (err) {
          console.error("Error loading tags:", err);
        }
      }

      // Cargar secciones
      async function loadSections() {
        if (!currentSiteId) return;
        
        try {
          const res = await fetch(`${API_URL}/sections?siteId=${currentSiteId}`, {
            credentials: "include",
          });
          if (res.ok) {
            sections = await res.json();
            // Filtrar secciones "detailPage" por si acaso (aunque el backend ya las filtra)
            sections = sections.filter(s => s.postType !== "detailPage");
            renderSectionSelect();
            renderSectionFilterSelect();
            // Si el panel de gestión está abierto, actualizar la lista
            const content = document.getElementById("section-manager-content");
            if (content && content.style.display !== "none") {
              renderSectionsManager();
            }
          }
        } catch (err) {
          console.error("Error loading sections:", err);
        }
      }

      // Renderizar select de secciones en el filtro
      function renderSectionFilterSelect() {
        const select = document.getElementById("filter-section");
        if (!select) return;
        
        const currentValue = select.value; // Guardar valor actual
        
        select.innerHTML = '<option value="">All sections</option>';
        
        // Ordenar secciones: primero las que no tienen parent, luego las hijas
        const topLevelSections = sections.filter(s => !s.parentId).sort((a, b) => a.order - b.order);
        
        topLevelSections.forEach(section => {
          const option = document.createElement("option");
          option.value = section.id;
          option.textContent = section.name;
          select.appendChild(option);
          
          // Añadir hijos si existen
          const children = sections.filter(s => s.parentId === section.id).sort((a, b) => a.order - b.order);
          children.forEach(child => {
            const childOption = document.createElement("option");
            childOption.value = child.id;
            childOption.textContent = `  └ ${child.name}`;
            select.appendChild(childOption);
          });
        });
        
        // Restaurar valor si existía
        if (currentValue) {
          select.value = currentValue;
        }
      }

      // Renderizar select de secciones en el formulario
      function renderSectionSelect() {
        const select = document.getElementById("section");
        if (!select) return;
        
        const currentValue = select.value; // Guardar valor actual
        
        select.innerHTML = '<option value="">Select a section</option>';
        
        // Ordenar secciones: primero las que no tienen parent, luego las hijas
        const topLevelSections = sections.filter(s => !s.parentId).sort((a, b) => a.order - b.order);
        
        topLevelSections.forEach(section => {
          const option = document.createElement("option");
          option.value = section.id;
          option.textContent = section.name;
          select.appendChild(option);
          
          // Añadir hijos si existen
          const children = sections.filter(s => s.parentId === section.id).sort((a, b) => a.order - b.order);
          children.forEach(child => {
            const childOption = document.createElement("option");
            childOption.value = child.id;
            childOption.textContent = `  └ ${child.name}`;
            select.appendChild(childOption);
          });
        });
        
        // Restaurar valor si existía
        if (currentValue) {
          select.value = currentValue;
        }
        
        // Actualizar info de tipo
        updateSectionTypeInfo();
      }

      // Actualizar información del tipo de post según la sección seleccionada
      function updateSectionTypeInfo() {
        const sectionSelect = document.getElementById("section");
        const infoElement = document.getElementById("section-type-info");
        const thumbnailsContainer = document.getElementById("thumbnails-manager-container");
        const postFormContainer = document.getElementById("post-form-container");
        const thumbnailFieldsContainer = document.getElementById("thumbnail-fields-container");
        const thumbnailReorderContainer = document.getElementById("thumbnail-reorder-container");
        const blocksContainer = document.getElementById("blocks-container");
        
        if (!sectionSelect || !infoElement) return;
        
        const sectionId = sectionSelect.value;
        if (sectionId) {
          const section = sections.find(s => s.id === parseInt(sectionId));
          if (section && section.postType) {
            // Si la sección es de tipo "thumbnails", mostrar campos de thumbnail en el formulario
            if (section.postType === "thumbnails") {
              if (thumbnailsContainer) thumbnailsContainer.style.display = "none";
              if (postFormContainer) postFormContainer.style.display = "block";
              if (thumbnailFieldsContainer) thumbnailFieldsContainer.style.display = "block";
              if (thumbnailReorderContainer) thumbnailReorderContainer.style.display = "block";
              // Activar required cuando se muestra el contenedor
              const thumbnailImageUrlInput = document.getElementById("thumbnail-image-url");
              if (thumbnailImageUrlInput) thumbnailImageUrlInput.setAttribute("required", "required");
              if (blocksContainer) {
                blocksContainer.style.display = "block"; // Mostrar contenedor de bloques (pertenecen a la página de detalle)
                // Actualizar título y descripción para indicar que son bloques de la página de detalle
                const blocksTitle = document.getElementById("blocks-container-title");
                const blocksDescription = document.getElementById("blocks-container-description");
                const blocksHelp = document.getElementById("blocks-container-help");
                if (blocksTitle) blocksTitle.textContent = "Detail Page Blocks";
                if (blocksDescription) {
                  blocksDescription.textContent = "These blocks appear on the detail page (not on the thumbnails page)";
                  blocksDescription.style.display = "block";
                }
                if (blocksHelp) {
                  blocksHelp.textContent = "Add content blocks for the detail page: text, images, videos, embeds. Drag to reorder.";
                }
              }
              infoElement.textContent = `Post type: THUMBNAILS - This post will create both a thumbnail and a detail page.`;
              // Actualizar tipo de post actual
              updatePostType(section.postType);
            } else {
              if (thumbnailsContainer) thumbnailsContainer.style.display = "none";
              if (postFormContainer) postFormContainer.style.display = "block";
              if (thumbnailFieldsContainer) thumbnailFieldsContainer.style.display = "none";
              if (thumbnailReorderContainer) thumbnailReorderContainer.style.display = "none";
              // Remover required cuando se oculta el contenedor
              const thumbnailImageUrlInput = document.getElementById("thumbnail-image-url");
              if (thumbnailImageUrlInput) thumbnailImageUrlInput.removeAttribute("required");
              if (blocksContainer) {
                blocksContainer.style.display = "block"; // Mostrar contenedor de bloques
                // Restaurar título y descripción por defecto
                const blocksTitle = document.getElementById("blocks-container-title");
                const blocksDescription = document.getElementById("blocks-container-description");
                const blocksHelp = document.getElementById("blocks-container-help");
                if (blocksTitle) blocksTitle.textContent = "Content Blocks";
                if (blocksDescription) blocksDescription.style.display = "none";
                if (blocksHelp) {
                  blocksHelp.textContent = "Add flexible content blocks: text, images, videos, embeds. Drag to reorder.";
                }
              }
              infoElement.textContent = `Post type: ${section.postType.toUpperCase()} (automatically set from section)`;
              // Actualizar tipo de post actual
              updatePostType(section.postType);
            }
          } else {
            if (thumbnailsContainer) thumbnailsContainer.style.display = "none";
            if (postFormContainer) postFormContainer.style.display = "block";
            if (thumbnailFieldsContainer) thumbnailFieldsContainer.style.display = "none";
            if (thumbnailReorderContainer) thumbnailReorderContainer.style.display = "none";
            // Remover required cuando no hay sección seleccionada
            const thumbnailImageUrlInput = document.getElementById("thumbnail-image-url");
            if (thumbnailImageUrlInput) thumbnailImageUrlInput.removeAttribute("required");
            if (blocksContainer) {
              blocksContainer.style.display = "block"; // Mostrar contenedor de bloques por defecto
              // Restaurar título y descripción por defecto
              const blocksTitle = document.getElementById("blocks-container-title");
              const blocksDescription = document.getElementById("blocks-container-description");
              const blocksHelp = document.getElementById("blocks-container-help");
              if (blocksTitle) blocksTitle.textContent = "Content Blocks";
              if (blocksDescription) blocksDescription.style.display = "none";
              if (blocksHelp) {
                blocksHelp.textContent = "Add flexible content blocks: text, images, videos, embeds. Drag to reorder.";
              }
            }
            infoElement.textContent = "Posts must belong to a section. Post type will be set automatically.";
            updatePostType(null);
          }
        } else {
          if (thumbnailsContainer) thumbnailsContainer.style.display = "none";
          if (postFormContainer) postFormContainer.style.display = "block";
          infoElement.textContent = "Posts must belong to a section. Post type will be set automatically.";
          updatePostType(null);
        }
      }

      // Seleccionar sección
      function selectSection(sectionId) {
        selectedSectionId = sectionId;
        currentFilters.sectionId = sectionId ? sectionId.toString() : "";
        loadPosts(1);
      }

      // Toggle section manager panel
      function toggleSectionManager() {
        const content = document.getElementById("section-manager-content");
        const toggle = document.getElementById("section-manager-toggle");
        
        if (content.style.display === "none") {
          content.style.display = "block";
          toggle.textContent = "−";
          renderSectionsManager();
        } else {
          content.style.display = "none";
          toggle.textContent = "+";
        }
      }
      
      // Hacer toggleSectionManager disponible globalmente para onclick
      window.toggleSectionManager = toggleSectionManager;

      // ==================== GESTIÓN DE THUMBNAILS ====================
      
      // Cargar thumbnails de una sección
      async function loadThumbnails(sectionId) {
        try {
          const response = await fetch(`${API_URL}/thumbnails?sectionId=${sectionId}`, {
            credentials: 'include',
          });
          
          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }
          
          const thumbnails = await response.json();
          renderThumbnails(thumbnails);
        } catch (err) {
          console.error("Error loading thumbnails:", err);
          const list = document.getElementById("thumbnails-list");
          if (list) {
            list.innerHTML = `<p style="color: red;">Error loading thumbnails: ${err.message}</p>`;
          }
        }
      }
      
      // Renderizar lista de thumbnails
      function renderThumbnails(thumbnails) {
        const list = document.getElementById("thumbnails-list");
        if (!list) return;
        
        if (!thumbnails || thumbnails.length === 0) {
          list.innerHTML = '<p style="color: #999; font-style: italic; padding: 20px; text-align: center;">No thumbnails yet. Click "Add Thumbnail" to create one.</p>';
          return;
        }
        
        list.innerHTML = thumbnails.map((thumb, index) => `
          <div class="thumbnail-item" data-thumbnail-id="${thumb.id}" style="padding: 20px; background: #ffffff; border: 1px solid #000000; display: flex; gap: 20px; align-items: center;">
            <div style="flex: 0 0 100px; height: 100px; background: #f0f0f0; border: 1px solid #ddd; display: flex; align-items: center; justify-content: center; overflow: hidden;">
              <img src="${thumb.imageUrl}" alt="${escapeHtml(thumb.title)}" style="max-width: 100%; max-height: 100%; object-fit: cover;" onerror="this.style.display='none'; this.parentElement.innerHTML='<span style=\\'color: #999; font-size: 11px;\\'>No image</span>';" />
            </div>
            <div style="flex: 1;">
              <h3 style="margin: 0 0 5px 0; font-size: 14px; font-weight: 400;">${escapeHtml(thumb.title)}</h3>
              ${thumb.description ? `<p style="margin: 0; font-size: 12px; color: #666;">${escapeHtml(thumb.description)}</p>` : ''}
              <div style="margin-top: 10px; display: flex; gap: 10px;">
                <button type="button" class="edit-thumbnail-btn" data-thumbnail-id="${thumb.id}" style="padding: 6px 12px; background: #000000; color: #ffffff; border: none; border-radius: 0; cursor: pointer; font-size: 11px; text-transform: uppercase; letter-spacing: 0.5px;">
                  Edit
                </button>
                ${thumb.detailPost ? `
                  <button type="button" class="edit-detail-btn" data-thumbnail-id="${thumb.id}" style="padding: 6px 12px; background: #ffffff; color: #000000; border: 1px solid #000000; border-radius: 0; cursor: pointer; font-size: 11px; text-transform: uppercase; letter-spacing: 0.5px;">
                    Edit Detail
                  </button>
                ` : ''}
                <button type="button" class="delete-thumbnail-btn" data-thumbnail-id="${thumb.id}" style="padding: 6px 12px; background: #ffffff; color: #ff0000; border: 1px solid #ff0000; border-radius: 0; cursor: pointer; font-size: 11px; text-transform: uppercase; letter-spacing: 0.5px;">
                  Delete
                </button>
              </div>
            </div>
            <div style="flex: 0 0 40px; display: flex; flex-direction: column; gap: 5px;">
              <button type="button" class="move-thumbnail-up" data-thumbnail-id="${thumb.id}" ${index === 0 ? 'disabled' : ''} style="padding: 5px; background: #f0f0f0; border: 1px solid #ddd; cursor: pointer; font-size: 12px;">↑</button>
              <button type="button" class="move-thumbnail-down" data-thumbnail-id="${thumb.id}" ${index === thumbnails.length - 1 ? 'disabled' : ''} style="padding: 5px; background: #f0f0f0; border: 1px solid #ddd; cursor: pointer; font-size: 12px;">↓</button>
            </div>
          </div>
        `).join('');
        
        // Añadir event listeners
        list.querySelectorAll('.edit-thumbnail-btn').forEach(btn => {
          btn.addEventListener('click', (e) => {
            const id = parseInt(e.target.dataset.thumbnailId);
            editThumbnail(id);
          });
        });
        
        list.querySelectorAll('.edit-detail-btn').forEach(btn => {
          btn.addEventListener('click', async (e) => {
            const id = parseInt(e.target.dataset.thumbnailId);
            await editThumbnailDetail(id);
          });
        });
        
        list.querySelectorAll('.delete-thumbnail-btn').forEach(btn => {
          btn.addEventListener('click', (e) => {
            const id = parseInt(e.target.dataset.thumbnailId);
            deleteThumbnail(id);
          });
        });
        
        list.querySelectorAll('.move-thumbnail-up').forEach(btn => {
          btn.addEventListener('click', async (e) => {
            const id = parseInt(e.target.dataset.thumbnailId);
            await moveThumbnail(id, 'up');
          });
        });
        
        list.querySelectorAll('.move-thumbnail-down').forEach(btn => {
          btn.addEventListener('click', async (e) => {
            const id = parseInt(e.target.dataset.thumbnailId);
            await moveThumbnail(id, 'down');
          });
        });
      }
      
      // Añadir nueva miniatura (abre el modal en modo creación)
      async function addThumbnail() {
        const sectionSelect = document.getElementById("section");
        const sectionId = sectionSelect ? parseInt(sectionSelect.value) : null;
        
        if (!sectionId) {
          alert("Please select a section first");
          return;
        }
        
        // Limpiar el formulario y abrir modal en modo creación
        currentEditingThumbnail = { sectionId: sectionId, id: null };
        document.getElementById("thumbnail-editor-id").value = "";
        document.getElementById("thumbnail-editor-title").value = "";
        document.getElementById("thumbnail-editor-image-url").value = "";
        document.getElementById("thumbnail-editor-description").value = "";
        document.getElementById("thumbnail-editor-image-preview").innerHTML = '<span style="color: #999; font-size: 11px;">Image preview</span>';
        
        // Cambiar el título del modal
        const modalTitle = document.querySelector("#thumbnail-editor-modal h3");
        if (modalTitle) {
          modalTitle.textContent = "Add New Thumbnail";
        }
        
        // Mostrar modal
        const modal = document.getElementById("thumbnail-editor-modal");
        modal.style.display = "block";
      }
      
      // Variable para almacenar el thumbnail actual que se está editando
      let currentEditingThumbnail = null;
      
      // Abrir modal para editar miniatura
      async function editThumbnail(id) {
        try {
          const response = await fetch(`${API_URL}/thumbnails?sectionId=${document.getElementById("section").value}`, {
            credentials: 'include',
          });
          
          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }
          
          const thumbnails = await response.json();
          const thumbnail = thumbnails.find(t => t.id === id);
          
          if (!thumbnail) {
            alert("Thumbnail not found");
            return;
          }
          
          currentEditingThumbnail = thumbnail;
          
          // Llenar el formulario del modal
          document.getElementById("thumbnail-editor-id").value = thumbnail.id;
          document.getElementById("thumbnail-editor-title").value = thumbnail.title || "";
          document.getElementById("thumbnail-editor-image-url").value = thumbnail.imageUrl || "";
          document.getElementById("thumbnail-editor-description").value = thumbnail.description || "";
          
          // Actualizar preview de imagen
          updateThumbnailImagePreview(thumbnail.imageUrl);
          
          // Mostrar modal
          const modal = document.getElementById("thumbnail-editor-modal");
          modal.style.display = "block";
        } catch (err) {
          console.error("Error loading thumbnail:", err);
          alert(`Error loading thumbnail: ${err.message}`);
        }
      }
      
      // Actualizar preview de imagen del thumbnail
      function updateThumbnailImagePreview(imageUrl) {
        const preview = document.getElementById("thumbnail-editor-image-preview");
        if (!preview) return;
        
        if (imageUrl) {
          const convertedUrl = convertImgurUrl(imageUrl);
          preview.innerHTML = `<img src="${convertedUrl}" alt="Preview" style="max-width: 100%; max-height: 100%; object-fit: cover;" onerror="this.style.display='none'; this.parentElement.innerHTML='<span style=\\'color: #999; font-size: 11px;\\'>Error loading image</span>';" />`;
        } else {
          preview.innerHTML = '<span style="color: #999; font-size: 11px;">Image preview</span>';
        }
      }
      
      // Cerrar modal de edición de thumbnail
      function closeThumbnailEditor() {
        const modal = document.getElementById("thumbnail-editor-modal");
        modal.style.display = "none";
        currentEditingThumbnail = null;
        document.getElementById("thumbnail-editor-form").reset();
        document.getElementById("thumbnail-editor-image-preview").innerHTML = '<span style="color: #999; font-size: 11px;">Image preview</span>';
      }
      
      // Guardar cambios del thumbnail (crear nuevo o actualizar existente)
      async function saveThumbnailChanges() {
        const form = document.getElementById("thumbnail-editor-form");
        if (!form.checkValidity()) {
          form.reportValidity();
          return;
        }
        
        const id = document.getElementById("thumbnail-editor-id").value;
        const title = document.getElementById("thumbnail-editor-title").value.trim();
        const imageUrl = document.getElementById("thumbnail-editor-image-url").value.trim();
        const description = document.getElementById("thumbnail-editor-description").value.trim() || null;
        
        if (!title || !imageUrl) {
          alert("Please fill in all required fields");
          return;
        }
        
        const sectionSelect = document.getElementById("section");
        const sectionId = sectionSelect ? parseInt(sectionSelect.value) : null;
        
        if (!sectionId) {
          alert("Please select a section first");
          return;
        }
        
        try {
          if (id) {
            // Actualizar thumbnail existente
            const updateResponse = await fetch(`${API_URL}/thumbnails/${id}`, {
              method: 'PUT',
              headers: {
                'Content-Type': 'application/json',
              },
              credentials: 'include',
              body: JSON.stringify({
                title: title,
                imageUrl: imageUrl,
                description: description,
              }),
            });
            
            if (!updateResponse.ok) {
              const error = await updateResponse.json();
              throw new Error(error.error || `HTTP error! status: ${updateResponse.status}`);
            }
          } else {
            // Crear nuevo thumbnail
            const createResponse = await fetch(`${API_URL}/thumbnails`, {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
              },
              credentials: 'include',
              body: JSON.stringify({
                title: title,
                imageUrl: imageUrl,
                description: description,
                sectionId: sectionId,
              }),
            });
            
            if (!createResponse.ok) {
              const error = await createResponse.json();
              throw new Error(error.error || `HTTP error! status: ${createResponse.status}`);
            }
            
            const thumbnail = await createResponse.json();
            if (thumbnail.detailPost) {
              alert(`Thumbnail created! A detail page has been automatically created. Click "Edit Detail" to edit it.`);
            }
          }
          
          // Recargar thumbnails
          await loadThumbnails(sectionId);
          
          // Cerrar modal
          closeThumbnailEditor();
        } catch (err) {
          console.error("Error saving thumbnail:", err);
          alert(`Error saving thumbnail: ${err.message}`);
        }
      }
      
      // Abrir editor de imágenes para el thumbnail
      function openThumbnailImageEditor() {
        const imageUrl = document.getElementById("thumbnail-editor-image-url").value.trim();
        if (!imageUrl) {
          alert("Please enter an image URL first");
          return;
        }
        
        // Usar el editor de imágenes existente
        currentImageUrl = imageUrl;
        currentImageIndex = null;
        currentImageElement = null;
        currentBlockContext = {
          type: 'thumbnail',
          thumbnailId: currentEditingThumbnail ? currentEditingThumbnail.id : null,
        };
        
        const img = document.getElementById('image-editor-img');
        const modal = document.getElementById('image-editor-modal');
        
        if (!img || !modal) {
          console.error('Image editor elements not found');
          return;
        }
        
        // Limpiar cropper anterior si existe
        if (imageCropper) {
          imageCropper.destroy();
          imageCropper = null;
        }
        
        // Resetear la imagen
        img.src = '';
        
        // Cargar la imagen
        const convertedUrl = convertImgurUrl(imageUrl);
        img.src = convertedUrl;
        
        img.onload = function() {
          // Mostrar modal
          modal.classList.add('show');
          
          // Esperar un momento para que el modal se renderice
          setTimeout(function() {
            // Inicializar Cropper.js
            if (imageCropper) {
              imageCropper.destroy();
            }
            
            const cropperOptions = {
              aspectRatio: NaN, // Permite cualquier proporción
              viewMode: 1,
              dragMode: 'move',
              autoCropArea: 0.8,
              restore: false,
              guides: true,
              center: true,
              highlight: true,
              cropBoxMovable: true,
              cropBoxResizable: true,
              toggleable: true,
            };
            
            imageCropper = new Cropper(img, cropperOptions);
          }, 100);
        };
        
        img.onerror = function() {
          console.error('Error loading image:', convertedUrl);
          alert('Error loading image. Please check the URL.');
        };
      }
      
      // Editar página de detalle de una miniatura
      async function editThumbnailDetail(thumbnailId) {
        try {
          const response = await fetch(`${API_URL}/thumbnails/${thumbnailId}/detail`, {
            credentials: 'include',
          });
          
          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }
          
          const detailPost = await response.json();
          
          // Cargar el post en el editor normal
          await editPost(detailPost.id);
          
          // Cambiar a la sección del post de detalle para que se muestre correctamente
          const sectionSelect = document.getElementById("section");
          if (sectionSelect && detailPost.sectionId) {
            sectionSelect.value = detailPost.sectionId;
            updateSectionTypeInfo();
          }
        } catch (err) {
          console.error("Error loading detail post:", err);
          alert(`Error loading detail post: ${err.message}`);
        }
      }
      
      // Eliminar miniatura
      async function deleteThumbnail(id) {
        if (!confirm("Are you sure you want to delete this thumbnail? The detail page will also be deleted.")) {
          return;
        }
        
        try {
          const response = await fetch(`${API_URL}/thumbnails/${id}?deleteDetailPost=true`, {
            method: 'DELETE',
            credentials: 'include',
          });
          
          if (!response.ok) {
            const error = await response.json();
            throw new Error(error.error || `HTTP error! status: ${response.status}`);
          }
          
          // Recargar thumbnails
          const sectionSelect = document.getElementById("section");
          if (sectionSelect) {
            await loadThumbnails(parseInt(sectionSelect.value));
          }
        } catch (err) {
          console.error("Error deleting thumbnail:", err);
          alert(`Error deleting thumbnail: ${err.message}`);
        }
      }
      
      // Mover miniatura (reordenar)
      async function moveThumbnail(id, direction) {
        try {
          const sectionSelect = document.getElementById("section");
          const sectionId = sectionSelect ? parseInt(sectionSelect.value) : null;
          
          if (!sectionId) return;
          
          // Obtener thumbnails actuales
          const response = await fetch(`${API_URL}/thumbnails?sectionId=${sectionId}`, {
            credentials: 'include',
          });
          
          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }
          
          const thumbnails = await response.json();
          const currentIndex = thumbnails.findIndex(t => t.id === id);
          
          if (currentIndex === -1) return;
          
          const newIndex = direction === 'up' ? currentIndex - 1 : currentIndex + 1;
          
          if (newIndex < 0 || newIndex >= thumbnails.length) return;
          
          // Intercambiar posiciones
          [thumbnails[currentIndex], thumbnails[newIndex]] = [thumbnails[newIndex], thumbnails[currentIndex]];
          
          // Actualizar orden
          const thumbnailIds = thumbnails.map(t => t.id);
          
          const reorderResponse = await fetch(`${API_URL}/thumbnails/reorder`, {
            method: 'PUT',
            headers: {
              'Content-Type': 'application/json',
            },
            credentials: 'include',
            body: JSON.stringify({ thumbnailIds }),
          });
          
          if (!reorderResponse.ok) {
            throw new Error(`HTTP error! status: ${reorderResponse.status}`);
          }
          
          // Recargar thumbnails
          await loadThumbnails(sectionId);
        } catch (err) {
          console.error("Error moving thumbnail:", err);
          alert(`Error moving thumbnail: ${err.message}`);
        }
      }

      // Registrar event listener para el botón de añadir thumbnail (después de que las funciones estén definidas)
      const addThumbnailBtn = document.getElementById("add-thumbnail-btn");
      if (addThumbnailBtn) {
        addThumbnailBtn.addEventListener("click", addThumbnail);
      }
      
      // Event listeners para el modal de edición de thumbnail
      const thumbnailEditorForm = document.getElementById("thumbnail-editor-form");
      if (thumbnailEditorForm) {
        thumbnailEditorForm.addEventListener("submit", (e) => {
          e.preventDefault();
          saveThumbnailChanges();
        });
      }
      
      const thumbnailEditorCloseBtn = document.getElementById("thumbnail-editor-close-btn");
      if (thumbnailEditorCloseBtn) {
        thumbnailEditorCloseBtn.addEventListener("click", closeThumbnailEditor);
      }
      
      const thumbnailEditorCancelBtn = document.getElementById("thumbnail-editor-cancel-btn");
      if (thumbnailEditorCancelBtn) {
        thumbnailEditorCancelBtn.addEventListener("click", closeThumbnailEditor);
      }
      
      const thumbnailEditorEditImageBtn = document.getElementById("thumbnail-editor-edit-image-btn");
      if (thumbnailEditorEditImageBtn) {
        thumbnailEditorEditImageBtn.addEventListener("click", openThumbnailImageEditor);
      }
      
      // Actualizar preview cuando cambia la URL de imagen
      const thumbnailEditorImageUrl = document.getElementById("thumbnail-editor-image-url");
      if (thumbnailEditorImageUrl) {
        thumbnailEditorImageUrl.addEventListener("input", (e) => {
          updateThumbnailImagePreview(e.target.value);
        });
      }
      
      // Cerrar modal al hacer click fuera
      const thumbnailEditorModal = document.getElementById("thumbnail-editor-modal");
      if (thumbnailEditorModal) {
        thumbnailEditorModal.addEventListener("click", (e) => {
          if (e.target === thumbnailEditorModal) {
            closeThumbnailEditor();
          }
        });
      }
      
      // Event listeners para campos de thumbnail en el formulario de posts
      const thumbnailImageEditBtn = document.getElementById("thumbnail-image-edit-btn");
      if (thumbnailImageEditBtn) {
        thumbnailImageEditBtn.addEventListener("click", () => {
          const imageUrl = document.getElementById("thumbnail-image-url")?.value || "";
          if (imageUrl) {
            const convertedUrl = convertImgurUrl(imageUrl);
            currentBlockContext = {
              type: 'thumbnail',
              field: 'thumbnail-image-url'
            };
            openImageEditor(convertedUrl, null);
          } else {
            alert("Please enter an image URL first");
          }
        });
      }
      
      const thumbnailImageUrl = document.getElementById("thumbnail-image-url");
      if (thumbnailImageUrl) {
        thumbnailImageUrl.addEventListener("input", (e) => {
          const preview = document.getElementById("thumbnail-image-preview");
          if (preview && e.target.value) {
            const img = preview.querySelector("img");
            if (img) {
              img.src = convertImgurUrl(e.target.value);
              img.style.display = "block";
            } else {
              preview.innerHTML = `<img src="${convertImgurUrl(e.target.value)}" style="max-width: 100%; max-height: 100%; object-fit: contain;" onerror="this.style.display='none'; this.parentElement.innerHTML='<span style=\\'color: #999; font-size: 11px;\\'>Invalid image</span>';" />`;
            }
          }
        });
        
        // Detectar cuando se pega una URL de Imgur y abrir editor
        thumbnailImageUrl.addEventListener("blur", (e) => {
          const url = e.target.value.trim();
          if (url && (url.includes("imgur.com") || url.includes("i.imgur.com"))) {
            const imageUrl = convertImgurUrl(url);
            setTimeout(() => {
              currentBlockContext = {
                type: 'thumbnail',
                field: 'thumbnail-image-url'
              };
              openImageEditor(imageUrl, null);
            }, 300);
          }
        });
      }
      
      // Event listeners para el modal de reordenamiento de thumbnails
      const reorderThumbnailsBtn = document.getElementById("reorder-thumbnails-btn");
      console.log("[Thumbnail Reorder] reorder-thumbnails-btn element:", reorderThumbnailsBtn);
      if (reorderThumbnailsBtn) {
        console.log("[Thumbnail Reorder] ✅ Adding click listener to reorder button");
        reorderThumbnailsBtn.addEventListener("click", () => {
          console.log("[Thumbnail Reorder] ========== REORDER BUTTON CLICKED ==========");
          const sectionSelect = document.getElementById("section");
          console.log("[Thumbnail Reorder] Section select element:", sectionSelect);
          const sectionId = sectionSelect?.value;
          console.log("[Thumbnail Reorder] Section ID from select:", sectionId);
          if (!sectionId) {
            console.error("[Thumbnail Reorder] ❌ No section selected");
            alert("Please select a section first");
            return;
          }
          console.log("[Thumbnail Reorder] Opening modal with sectionId:", parseInt(sectionId));
          openThumbnailReorderModal(parseInt(sectionId));
        });
      } else {
        console.error("[Thumbnail Reorder] ❌ reorder-thumbnails-btn element not found!");
      }
      
      const thumbnailReorderCloseBtn = document.getElementById("thumbnail-reorder-close-btn");
      if (thumbnailReorderCloseBtn) {
        thumbnailReorderCloseBtn.addEventListener("click", closeThumbnailReorderModal);
      }
      
      const thumbnailReorderCancelBtn = document.getElementById("thumbnail-reorder-cancel-btn");
      if (thumbnailReorderCancelBtn) {
        thumbnailReorderCancelBtn.addEventListener("click", closeThumbnailReorderModal);
      }
      
      const thumbnailReorderSaveBtn = document.getElementById("thumbnail-reorder-save-btn");
      if (thumbnailReorderSaveBtn) {
        thumbnailReorderSaveBtn.addEventListener("click", saveThumbnailReorder);
      }
      
      const thumbnailReorderModal = document.getElementById("thumbnail-reorder-modal");
      if (thumbnailReorderModal) {
        thumbnailReorderModal.addEventListener("click", (e) => {
          if (e.target === thumbnailReorderModal) {
            closeThumbnailReorderModal();
          }
        });
      }
      
      // Funciones para el modal de reordenamiento
      let currentReorderSectionId = null;
      let reorderThumbnailsList = [];
      let draggedElement = null;
      let draggedIndex = null;
      
      // Handler para clicks en botones de reordenamiento (event delegation)
      function handleThumbnailReorderClick(e) {
        const target = e.target;
        if (!target.classList.contains("move-thumb-up") && !target.classList.contains("move-thumb-down")) {
          return;
        }
        
        e.preventDefault();
        e.stopPropagation();
        
        const thumbId = parseInt(target.dataset.thumbId);
        console.log("[Thumbnail Reorder] ========== BUTTON CLICKED ==========");
        console.log("[Thumbnail Reorder] Button class:", target.classList.contains("move-thumb-up") ? "UP" : "DOWN");
        console.log("[Thumbnail Reorder] Thumb ID:", thumbId);
        
        if (isNaN(thumbId)) {
          console.error("[Thumbnail Reorder] ❌ Invalid thumb ID!");
          return;
        }
        
        const index = reorderThumbnailsList.findIndex(t => t.id === thumbId);
        console.log("[Thumbnail Reorder] Current index:", index, "of", reorderThumbnailsList.length);
        
        if (target.classList.contains("move-thumb-up")) {
          if (index > 0) {
            console.log("[Thumbnail Reorder] Moving UP: swapping index", index, "with", index - 1);
            // Intercambiar elementos
            [reorderThumbnailsList[index], reorderThumbnailsList[index - 1]] = 
              [reorderThumbnailsList[index - 1], reorderThumbnailsList[index]];
            // Actualizar los campos order para reflejar la nueva posición
            reorderThumbnailsList[index].order = index;
            reorderThumbnailsList[index - 1].order = index - 1;
            console.log("[Thumbnail Reorder] After swap:", reorderThumbnailsList.map(t => ({ id: t.id, order: t.order, title: t.title })));
            renderThumbnailReorderList();
          } else {
            console.log("[Thumbnail Reorder] Cannot move up (already at top)");
          }
        } else if (target.classList.contains("move-thumb-down")) {
          if (index < reorderThumbnailsList.length - 1) {
            console.log("[Thumbnail Reorder] Moving DOWN: swapping index", index, "with", index + 1);
            // Intercambiar elementos
            [reorderThumbnailsList[index], reorderThumbnailsList[index + 1]] = 
              [reorderThumbnailsList[index + 1], reorderThumbnailsList[index]];
            // Actualizar los campos order para reflejar la nueva posición
            reorderThumbnailsList[index].order = index;
            reorderThumbnailsList[index + 1].order = index + 1;
            console.log("[Thumbnail Reorder] After swap:", reorderThumbnailsList.map(t => ({ id: t.id, order: t.order, title: t.title })));
            renderThumbnailReorderList();
          } else {
            console.log("[Thumbnail Reorder] Cannot move down (already at bottom)");
          }
        }
      }
      
      async function openThumbnailReorderModal(sectionId) {
        console.log("[Thumbnail Reorder] ========== OPEN MODAL ==========");
        console.log("[Thumbnail Reorder] Section ID:", sectionId);
        currentReorderSectionId = sectionId;
        draggedElement = null;
        draggedIndex = null;
        try {
          console.log("[Thumbnail Reorder] Fetching thumbnails from:", `${API_URL}/thumbnails?sectionId=${sectionId}`);
          const res = await fetch(`${API_URL}/thumbnails?sectionId=${sectionId}`, {
            credentials: "include"
          });
          console.log("[Thumbnail Reorder] Response status:", res.status, res.ok);
          if (!res.ok) throw new Error("Failed to load thumbnails");
          const thumbnails = await res.json();
          console.log("[Thumbnail Reorder] Thumbnails received:", thumbnails);
          console.log("[Thumbnail Reorder] Thumbnails count:", thumbnails.length);
          reorderThumbnailsList = thumbnails;
          renderThumbnailReorderList();
          const modal = document.getElementById("thumbnail-reorder-modal");
          if (modal) {
            modal.style.display = "block";
            console.log("[Thumbnail Reorder] Modal displayed");
          } else {
            console.error("[Thumbnail Reorder] Modal element not found!");
          }
        } catch (err) {
          console.error("[Thumbnail Reorder] Error:", err);
          alert(`Error loading thumbnails: ${err.message}`);
        }
      }
      
      function renderThumbnailReorderList() {
        console.log("[Thumbnail Reorder] ========== RENDER LIST ==========");
        const container = document.getElementById("thumbnail-reorder-list");
        if (!container) {
          console.error("[Thumbnail Reorder] ❌ Container not found!");
          return;
        }
        console.log("[Thumbnail Reorder] ✅ Container found");
        
        if (!reorderThumbnailsList || reorderThumbnailsList.length === 0) {
          console.log("[Thumbnail Reorder] No thumbnails to render");
          container.innerHTML = "<p style='color: #666; font-size: 11px; text-align: center; padding: 20px;'>No thumbnails to reorder.</p>";
          return;
        }
        
        console.log("[Thumbnail Reorder] Rendering", reorderThumbnailsList.length, "thumbnails");
        console.log("[Thumbnail Reorder] Thumbnails before sort:", reorderThumbnailsList.map(t => ({ id: t.id, order: t.order, title: t.title })));
        
        // Actualizar los campos order para que coincidan con el índice actual del array
        // Esto asegura que el orden del array se mantenga correcto
        reorderThumbnailsList.forEach((thumb, idx) => {
          thumb.order = idx;
        });
        
        console.log("[Thumbnail Reorder] Thumbnails with updated order:", reorderThumbnailsList.map(t => ({ id: t.id, order: t.order, title: t.title })));
        
        container.innerHTML = reorderThumbnailsList.map((thumb, index) => `
          <div class="thumbnail-reorder-item" data-thumb-id="${thumb.id}" draggable="true" style="display: flex; gap: 15px; align-items: center; padding: 15px; border: 1px solid #000000; background: #ffffff; cursor: move; margin-bottom: 10px;">
            <div style="font-size: 12px; color: #666; min-width: 30px; text-align: center;">${index + 1}</div>
            <div style="width: 80px; height: 60px; background: #f0f0f0; border: 1px solid #ddd; overflow: hidden; display: flex; align-items: center; justify-content: center; flex-shrink: 0;">
              <img src="${escapeHtml(thumb.imageUrl)}" alt="${escapeHtml(thumb.title)}" style="max-width: 100%; max-height: 100%; object-fit: cover; pointer-events: none;" onerror="this.style.display='none'; this.parentElement.innerHTML='<span style=\\'color: #999; font-size: 9px;\\'>No image</span>';" />
            </div>
            <div style="flex: 1;">
              <div style="font-weight: 500; font-size: 13px; margin-bottom: 5px;">${escapeHtml(thumb.title)}</div>
              ${thumb.description ? `<div style="font-size: 11px; color: #666;">${escapeHtml(thumb.description)}</div>` : ''}
            </div>
            <div style="display: flex; flex-direction: column; gap: 5px;">
              <button type="button" class="move-thumb-up" data-thumb-id="${thumb.id}" style="padding: 5px 10px; background: #000; color: #fff; border: none; cursor: pointer; font-size: 10px;">↑</button>
              <button type="button" class="move-thumb-down" data-thumb-id="${thumb.id}" style="padding: 5px 10px; background: #000; color: #fff; border: none; cursor: pointer; font-size: 10px;">↓</button>
            </div>
          </div>
        `).join("");
        
        // Usar event delegation para evitar problemas con múltiples listeners
        // Remover listeners anteriores si existen
        container.removeEventListener("click", handleThumbnailReorderClick);
        container.addEventListener("click", handleThumbnailReorderClick);
        
        // Implementar drag and drop
        const items = container.querySelectorAll(".thumbnail-reorder-item");
        console.log("[Thumbnail Reorder] Found", items.length, "thumbnail items for drag & drop");
        items.forEach((item) => {
          const thumbId = parseInt(item.dataset.thumbId);
          console.log("[Thumbnail Reorder] Setting up drag & drop for item thumbId:", thumbId);
          
          // Prevenir que los botones activen el drag
          const buttons = item.querySelectorAll("button");
          console.log("[Thumbnail Reorder] Found", buttons.length, "buttons in item");
          buttons.forEach((btn) => {
            btn.addEventListener("mousedown", (e) => {
              console.log("[Thumbnail Reorder] Button mousedown prevented drag");
              e.stopPropagation();
            });
          });
          
          item.addEventListener("dragstart", (e) => {
            console.log("[Thumbnail Reorder] ========== DRAG START ==========");
            console.log("[Thumbnail Reorder] Event target:", e.target);
            console.log("[Thumbnail Reorder] Event target tagName:", e.target.tagName);
            console.log("[Thumbnail Reorder] Closest button:", e.target.closest("button"));
            
            // Si el click fue en un botón, no iniciar drag
            if (e.target.tagName === "BUTTON" || e.target.closest("button")) {
              console.log("[Thumbnail Reorder] Drag prevented (clicked on button)");
              e.preventDefault();
              return false;
            }
            draggedElement = item;
            // Calcular el índice real basándose en el thumbId del elemento arrastrado
            const dragThumbId = parseInt(item.dataset.thumbId);
            draggedIndex = reorderThumbnailsList.findIndex(t => t.id === dragThumbId);
            e.dataTransfer.effectAllowed = "move";
            e.dataTransfer.setData("text/plain", dragThumbId.toString());
            item.style.opacity = "0.5";
            console.log("[Thumbnail Reorder] ✅ Drag started, index:", draggedIndex, "thumbId:", dragThumbId);
          });
          
          item.addEventListener("dragend", (e) => {
            console.log("[Thumbnail Reorder] ========== DRAG END ==========");
            item.style.opacity = "1";
            draggedElement = null;
            draggedIndex = null;
            // Limpiar estilos de todos los elementos
            container.querySelectorAll(".thumbnail-reorder-item").forEach(el => {
              el.style.borderColor = "#000000";
              el.style.backgroundColor = "#ffffff";
            });
            console.log("[Thumbnail Reorder] Drag ended, styles cleaned");
          });
          
          item.addEventListener("dragover", (e) => {
            e.preventDefault();
            e.dataTransfer.dropEffect = "move";
            
            // Resaltar el elemento sobre el que estamos
            if (item !== draggedElement) {
              item.style.borderColor = "#0000ff";
              item.style.backgroundColor = "#f0f0ff";
            }
          });
          
          item.addEventListener("dragleave", (e) => {
            if (item !== draggedElement) {
              item.style.borderColor = "#000000";
              item.style.backgroundColor = "#ffffff";
            }
          });
          
          item.addEventListener("drop", (e) => {
            console.log("[Thumbnail Reorder] ========== DROP ==========");
            console.log("[Thumbnail Reorder] draggedElement:", draggedElement);
            console.log("[Thumbnail Reorder] draggedIndex:", draggedIndex);
            console.log("[Thumbnail Reorder] item:", item);
            e.preventDefault();
            e.stopPropagation();
            
            if (draggedElement && draggedElement !== item && draggedIndex !== null && draggedIndex !== -1) {
              // Calcular el índice de destino basándose en el thumbId del elemento sobre el que se hace drop
              const dropThumbId = parseInt(item.dataset.thumbId);
              const dropIndex = reorderThumbnailsList.findIndex(t => t.id === dropThumbId);
              const dragIndex = draggedIndex;
              
              console.log("[Thumbnail Reorder] ✅ Drop valid: dragIndex=", dragIndex, "dropIndex=", dropIndex);
              console.log("[Thumbnail Reorder] Before move:", reorderThumbnailsList.map(t => ({ id: t.id, order: t.order, title: t.title })));
              
              if (dragIndex !== dropIndex && dragIndex !== -1 && dropIndex !== -1) {
                // Mover el elemento en el array
                const [movedItem] = reorderThumbnailsList.splice(dragIndex, 1);
                reorderThumbnailsList.splice(dropIndex, 0, movedItem);
                
                // Actualizar los campos order de todos los elementos para reflejar la nueva posición
                reorderThumbnailsList.forEach((thumb, idx) => {
                  thumb.order = idx;
                });
                
                console.log("[Thumbnail Reorder] After move:", reorderThumbnailsList.map(t => ({ id: t.id, order: t.order, title: t.title })));
                
                // Re-renderizar la lista
                renderThumbnailReorderList();
              } else {
                console.log("[Thumbnail Reorder] ❌ Drop invalid: same position or invalid indices");
              }
            } else {
              console.log("[Thumbnail Reorder] ❌ Drop invalid: missing draggedElement or invalid draggedIndex");
            }
            
            // Limpiar estilos
            container.querySelectorAll(".thumbnail-reorder-item").forEach(el => {
              el.style.borderColor = "#000000";
              el.style.backgroundColor = "#ffffff";
            });
          });
        });
        
        console.log("[Thumbnail Reorder] ========== RENDER COMPLETE ==========");
      }
      
      async function saveThumbnailReorder() {
        console.log("[Thumbnail Reorder] ========== SAVE REORDER ==========");
        console.log("[Thumbnail Reorder] currentReorderSectionId:", currentReorderSectionId);
        console.log("[Thumbnail Reorder] reorderThumbnailsList:", reorderThumbnailsList);
        console.log("[Thumbnail Reorder] reorderThumbnailsList length:", reorderThumbnailsList ? reorderThumbnailsList.length : 0);
        
        if (!currentReorderSectionId || !reorderThumbnailsList || reorderThumbnailsList.length === 0) {
          console.error("[Thumbnail Reorder] ❌ Cannot save: missing data");
          return;
        }
        
        try {
          // El backend espera un array de IDs en el orden deseado
          const thumbnailIds = reorderThumbnailsList.map((thumb) => thumb.id);
          
          console.log("[Thumbnail Reorder] Thumbnail IDs to send (in order):", thumbnailIds);
          console.log("[Thumbnail Reorder] Sending to:", `${API_URL}/thumbnails/reorder`);
          
          const res = await fetch(`${API_URL}/thumbnails/reorder`, {
            method: "PUT",
            headers: { "Content-Type": "application/json" },
            credentials: "include",
            body: JSON.stringify({ thumbnailIds: thumbnailIds })
          });
          
          console.log("[Thumbnail Reorder] Response status:", res.status, res.ok);
          
          if (!res.ok) {
            const errorText = await res.text();
            console.error("[Thumbnail Reorder] ❌ Error response:", errorText);
            throw new Error("Failed to save order");
          }
          
          const result = await res.json();
          console.log("[Thumbnail Reorder] ✅ Save successful:", result);
          
          showMessage("Thumbnails reordered successfully", "success");
          closeThumbnailReorderModal();
        } catch (err) {
          console.error("[Thumbnail Reorder] ❌ Error saving:", err);
          alert(`Error saving order: ${err.message}`);
        }
      }
      
      function closeThumbnailReorderModal() {
        document.getElementById("thumbnail-reorder-modal").style.display = "none";
        currentReorderSectionId = null;
        reorderThumbnailsList = [];
      }

      // Renderizar lista de secciones en el manager
      function renderSectionsManager() {
        const container = document.getElementById("sections-manager-list");
        if (!container) return;
        
        if (!sections || sections.length === 0) {
          container.innerHTML = "<p style='color: #666666; font-size: 12px;'>No sections found. Sections are created manually.</p>";
          return;
        }
        
        // Ordenar secciones: primero las que no tienen parent, luego las hijas
        const topLevelSections = sections.filter(s => !s.parentId).sort((a, b) => a.order - b.order);
        
        let html = "";
        topLevelSections.forEach(section => {
          const count = section._count?.posts || 0;
          html += `
            <div class="section-manager-item">
              <div class="section-manager-item-info">
                <div class="section-manager-item-name">${escapeHtml(section.name)}</div>
                <div class="section-manager-item-meta">
                  Type: ${escapeHtml(section.postType)} | Posts: ${count} | Slug: ${escapeHtml(section.slug)}
                </div>
              </div>
              <div class="section-manager-item-actions">
                <button class="delete-btn" type="button" onclick="deleteSection(${section.id})" style="display: ${isAdmin && !userModeView ? 'block' : 'none'};">Delete</button>
              </div>
            </div>
          `;
          
          // Renderizar hijos si existen
          const children = sections.filter(s => s.parentId === section.id).sort((a, b) => a.order - b.order);
          children.forEach(child => {
            const childCount = child._count?.posts || 0;
            html += `
              <div class="section-manager-item" style="margin-left: 30px; border-left: 3px solid #000000;">
                <div class="section-manager-item-info">
                  <div class="section-manager-item-name">└ ${escapeHtml(child.name)}</div>
                  <div class="section-manager-item-meta">
                    Type: ${escapeHtml(child.postType)} | Posts: ${childCount} | Slug: ${escapeHtml(child.slug)}
                  </div>
                </div>
                <div class="section-manager-item-actions">
                  <button class="delete-btn" type="button" onclick="deleteSection(${child.id})" style="display: ${isAdmin && !userModeView ? 'block' : 'none'};">Delete</button>
                </div>
              </div>
            `;
          });
        });
        
        container.innerHTML = html;
      }

      // Cargar frontend profile del site actual
      async function loadFrontendProfile(siteId) {
        try {
          const response = await authFetch(`${API_URL}/sites/${siteId}/frontend-profile`);
          
          if (!response.ok) {
            console.log("[Load Frontend Profile] No profile found or error:", response.status);
            currentFrontendProfile = null;
            return;
          }
          
          const data = await response.json();
          currentFrontendProfile = data;
          console.log("[Load Frontend Profile] Profile loaded:", data.frontendProfile?.name || "None");
          
          // Actualizar selector de schemas en el modal de crear sección
          updateSectionSchemaSelect(data.sectionSchemas);
        } catch (err) {
          console.error("[Load Frontend Profile] Error:", err);
          currentFrontendProfile = null;
        }
      }

      // Actualizar selector de schemas en el modal
      function updateSectionSchemaSelect(schemas) {
        const select = document.getElementById("section-schema");
        if (!select) return;
        
        // Limpiar opciones existentes excepto "Free Mode"
        select.innerHTML = '<option value="">-- Free Mode (No Template) --</option>';
        
        if (schemas && schemas.length > 0) {
          schemas.forEach(schema => {
            const option = document.createElement("option");
            option.value = schema.key;
            option.textContent = `${schema.label} (${schema.postType})`;
            option.dataset.postType = schema.postType;
            select.appendChild(option);
          });
        }
      }

      // Abrir modal de crear sección
      function openCreateSectionModal() {
        const modal = document.getElementById("create-section-modal");
        if (modal) {
          modal.style.display = "block";
          // Asegurar que los schemas estén actualizados
          if (currentFrontendProfile && currentFrontendProfile.sectionSchemas) {
            updateSectionSchemaSelect(currentFrontendProfile.sectionSchemas);
          }
        }
      }

      // Cerrar modal de crear sección
      function closeCreateSectionModal() {
        const modal = document.getElementById("create-section-modal");
        if (modal) {
          modal.style.display = "none";
          const form = document.getElementById("create-section-form");
          if (form) form.reset();
        }
      }

      // Crear sección desde el formulario
      async function createSection(event) {
        event.preventDefault();
        
        if (!currentSiteId) {
          showMessage("No site selected.", "error");
          return;
        }
        
        const name = document.getElementById("section-name").value.trim();
        const schemaKey = document.getElementById("section-schema").value;
        const description = document.getElementById("section-description").value.trim();
        
        if (!name) {
          showMessage("Section name is required.", "error");
          return;
        }
        
        try {
          const response = await fetch(`${API_URL}/sections`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            credentials: 'include',
            body: JSON.stringify({
              name: name,
              slug: name.toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9-]/g, ''),
              description: description || null,
              siteId: currentSiteId,
              schemaKey: schemaKey || null,
            }),
          });
          
          if (!response.ok) {
            const error = await response.json();
            throw new Error(error.error || "Failed to create section");
          }
          
          const section = await response.json();
          showMessage("Section created successfully!", "success");
          closeCreateSectionModal();
          
          // Recargar secciones
          await loadSections();
          renderSectionsManager();
        } catch (err) {
          console.error("Error creating section:", err);
          showMessage(`Error: ${err.message}`, "error");
        }
      }

      // Editar sección (solo visualización, no se permite editar)
      function editSection(id) {
        const section = sections.find(s => s.id === id);
        if (!section) return;
        alert(`Section: ${section.name}\nType: ${section.postType}\nSlug: ${section.slug}\nPosts: ${section._count?.posts || 0}\n\nSections are managed manually. Contact the developer to modify sections.`);
      }

      // Eliminar sección (deshabilitado - las secciones se gestionan manualmente)
      async function deleteSection(id) {
        const section = sections.find(s => s.id === id);
        const name = section ? section.name : `#${id}`;
        if (!confirm(`Delete section "${name}"?\n\nThis will delete the section AND all posts that belong to it.`)) {
          return;
        }

        try {
          const res = await fetch(`${API_URL}/sections/${id}`, {
            method: "DELETE",
            credentials: "include",
          });

          if (res.status === 401) {
            window.location.href = "login.html";
            return;
          }

          if (!res.ok) {
            let msg = "Failed to delete section";
            try {
              const data = await res.json();
              msg = data.error || msg;
            } catch (_) {}
            throw new Error(msg);
          }

          showMessage("Section deleted successfully", "success");
          await loadSections();
          renderSectionsManager();
        } catch (err) {
          console.error("Error deleting section:", err);
          showMessage(`Error: ${err.message}`, "error");
        }
      }

      // Cargar todos los posts con filtros y paginación
      async function loadPosts(page = 1) {
        if (!currentSiteId) {
          console.warn("[Load Posts] ⚠️ currentSiteId is null, cannot load posts");
          return;
        }
        
        console.log("[Load Posts] Loading posts for siteId:", currentSiteId, "page:", page);
        
        try {
          currentPage = page;
          const params = new URLSearchParams({
            page: page.toString(),
            limit: "20",
            siteId: currentSiteId.toString(),
          });
          
          if (currentFilters.search) params.append("search", currentFilters.search);
          if (currentFilters.published) params.append("published", currentFilters.published);
          if (currentFilters.tagId) params.append("tagId", currentFilters.tagId);
          if (currentFilters.sectionId) params.append("sectionId", currentFilters.sectionId);
          
          console.log("[Load Posts] Fetching from:", `${API_URL}/posts/all?${params.toString()}`);
          const res = await authFetch(`${API_URL}/posts/all?${params.toString()}`);
          
          console.log("[Load Posts] Response status:", res.status);
          
          if (res.status === 401) {
            window.location.href = "login.html";
            return;
          }
          
          if (!res.ok) {
            const errorText = await res.text();
            console.error("[Load Posts] Response not OK:", res.status, errorText);
            throw new Error(`Failed to load posts: ${res.status} ${errorText}`);
          }
          
          const data = await res.json();
          console.log("[Load Posts] Posts received:", data.posts ? data.posts.length : data.length, "posts");
          renderPosts(data.posts || data);
          renderPagination(data.pagination);
        } catch (err) {
          console.error("[Load Posts] ❌ Error:", err);
          const postsList = document.getElementById("posts-list");
          if (postsList) {
            postsList.innerHTML = 
              `<p style="color: #000000; border: 1px solid #000000; padding: 15px;">Error loading posts: ${err.message}</p>`;
          }
        }
      }

      // Función helper para renderizar previsualización de bloques
      function renderBlocksPreview(blocks) {
        if (!blocks || blocks.length === 0) {
          return "";
        }
        
        // Buscar el primer bloque de imagen para mostrar
        const imageBlock = blocks.find(b => b.type === 'image');
        if (imageBlock && imageBlock.content) {
          // Para bloques de imagen, el content es directamente la URL
          const imageUrl = imageBlock.content.trim();
          if (imageUrl && (imageUrl.startsWith('http') || imageUrl.startsWith('//'))) {
            return `<div style="margin-bottom: 15px;">
              <div style="font-size: 10px; text-transform: uppercase; letter-spacing: 0.5px; color: #666666; margin-bottom: 5px;">Block Preview (Image):</div>
              ${createImageWithFallback(imageUrl, "Block preview", "max-width: 100%; height: auto; border-radius: 0; border: 1px solid #000000;")}
            </div>`;
          }
        }
        
        // Buscar bloques de slideshow que pueden tener imágenes
        const slideshowBlock = blocks.find(b => b.type === 'slideshow');
        if (slideshowBlock && slideshowBlock.metadata) {
          let metadata = slideshowBlock.metadata;
          if (typeof metadata === 'string') {
            try {
              metadata = JSON.parse(metadata);
            } catch (e) {
              metadata = null;
            }
          }
          if (metadata && metadata.images && Array.isArray(metadata.images) && metadata.images.length > 0) {
            const firstImage = metadata.images[0];
            const imageUrl = firstImage.imageUrl || firstImage.url || firstImage;
            if (imageUrl) {
              return `<div style="margin-bottom: 15px;">
                <div style="font-size: 10px; text-transform: uppercase; letter-spacing: 0.5px; color: #666666; margin-bottom: 5px;">Block Preview (Slideshow - First Image):</div>
                ${createImageWithFallback(imageUrl, "Slideshow preview", "max-width: 100%; height: auto; border-radius: 0; border: 1px solid #000000;")}
              </div>`;
            }
          }
        }
        
        // Si no hay imagen, buscar el primer bloque de texto
        const textBlock = blocks.find(b => b.type === 'text');
        if (textBlock && textBlock.content) {
          // Extraer texto plano del HTML (primeros 200 caracteres)
          const textContent = textBlock.content.replace(/<[^>]*>/g, '').trim();
          if (textContent) {
            const preview = textContent.length > 200 ? textContent.substring(0, 200) + '...' : textContent;
            return `<div style="margin-bottom: 15px; padding: 10px; background: #f5f5f5; border: 1px solid #ddd;">
              <div style="font-size: 10px; text-transform: uppercase; letter-spacing: 0.5px; color: #666666; margin-bottom: 5px;">Block Preview (Text):</div>
              <div style="font-size: 12px; color: #333; line-height: 1.5;">${escapeHtml(preview)}</div>
            </div>`;
          }
        }
        
        // Si hay bloques pero no se puede previsualizar, mostrar info
        return `<div style="margin-bottom: 15px; padding: 10px; background: #f5f5f5; border: 1px solid #ddd;">
          <div style="font-size: 10px; text-transform: uppercase; letter-spacing: 0.5px; color: #666666;">Post has ${blocks.length} block(s)</div>
        </div>`;
      }

      // Renderizar lista de posts
      function renderPosts(posts) {
        const container = document.getElementById("posts-list");
        
        if (!posts || posts.length === 0) {
          container.innerHTML = "<p>No posts. Create a new one above.</p>";
          return;
        }

        container.innerHTML = posts
          .map(
            (post) => {
              const sectionBadge = post.section 
                ? `<span style="display: inline-block; padding: 4px 10px; background: #ffffff; color: #000000; border: 1px solid #000000; border-radius: 0; font-size: 10px; text-transform: uppercase; letter-spacing: 0.5px; transition: all 0.2s ease;" onmouseover="this.style.background='#000000'; this.style.color='#ffffff';" onmouseout="this.style.background='#ffffff'; this.style.color='#000000';">${escapeHtml(post.section.name)}</span>`
                : "";
              const tagsBadges = post.tags && post.tags.length > 0
                ? post.tags.map(tag => `<span style="display: inline-block; padding: 4px 10px; background: #ffffff; color: #000000; border: 1px solid #666666; border-radius: 0; font-size: 10px; text-transform: uppercase; letter-spacing: 0.5px; transition: all 0.2s ease;" onmouseover="this.style.background='#000000'; this.style.color='#ffffff'; this.style.borderColor='#000000';" onmouseout="this.style.background='#ffffff'; this.style.color='#000000'; this.style.borderColor='#666666';">${escapeHtml(tag.name)}</span>`).join("")
                : "";
              
              return `
            <div class="post-card">
              <div class="post-header">
                <div>
                  <div class="post-title">${escapeHtml(post.title)}</div>
                  <div class="post-meta">
                    ID ${post.id} | 
                    <code>${escapeHtml(post.slug)}</code> | 
                    ${new Date(post.createdAt).toLocaleDateString()}
                    ${post.updatedAt ? ` | ${new Date(post.updatedAt).toLocaleDateString()}` : ""}
                  </div>
                  ${sectionBadge || tagsBadges ? `<div style="margin-top: 12px; display: flex; flex-wrap: wrap; gap: 8px;">${sectionBadge}${tagsBadges}</div>` : ""}
                </div>
                <span class="badge ${post.published ? "published" : "draft"}">
                  ${post.published ? "Published" : "Draft"}
                </span>
              </div>
              <div class="post-actions" style="margin-top: 20px; padding-top: 20px; border-top: 1px solid #000000;">
                <button class="edit" onclick="editPost(${post.id})">Edit</button>
                <button class="delete" onclick="deletePost(${post.id})" style="margin-left: 10px;">Delete</button>
              </div>
            </div>
          `;
            }
          )
          .join("");
        
        // Añadir event listeners a todos los iframes de YouTube después de insertar el HTML
        setTimeout(function() {
          const youtubeIframes = document.querySelectorAll('iframe[data-video-id]');
          console.log("[YouTube Debug] Found", youtubeIframes.length, "YouTube iframes in admin");
          youtubeIframes.forEach(function(iframe) {
            const videoId = iframe.getAttribute('data-video-id');
            const originalUrl = iframe.getAttribute('data-original-url');
            const iframeId = iframe.id;
            
            // Asegurar que referrerPolicy esté establecido
            iframe.setAttribute('referrerpolicy', 'strict-origin-when-cross-origin');
            
            console.log('[YouTube Debug] Setting up listeners for iframe:', {
              id: iframeId,
              videoId: videoId,
              src: iframe.src,
              origin: window.location.origin,
              href: window.location.href,
              referrerPolicy: iframe.referrerPolicy || iframe.getAttribute('referrerpolicy')
            });
            
            iframe.addEventListener('load', function() {
              console.log('[YouTube Debug] Iframe loaded successfully:', iframeId);
              try {
                console.log('[YouTube Debug] Iframe contentWindow:', iframe.contentWindow ? 'available' : 'not available');
                console.log('[YouTube Debug] Iframe current src:', iframe.src);
                console.log('[YouTube Debug] Iframe referrerPolicy:', iframe.referrerPolicy);
              } catch(e) {
                console.log('[YouTube Debug] Error accessing contentWindow (normal for cross-origin):', e.message);
              }
              
              // Intentar detectar si hay un error 153 dentro del iframe
              setTimeout(function() {
                const rect = iframe.getBoundingClientRect();
                console.log('[YouTube Debug] Iframe dimensiones:', {
                  width: rect.width,
                  height: rect.height,
                  visible: rect.width > 0 && rect.height > 0
                });
                
                if (rect.width < 100 || rect.height < 100) {
                  console.warn('[YouTube Debug] Iframe appears to have anomalous dimensions - possible error 153');
                }
              }, 2000);
            });
            
            iframe.addEventListener('error', function(e) {
              console.error('[YouTube Debug] Error in iframe:', iframeId, e);
            });
            
            // Verificar después de 3 segundos si hay algún problema
            setTimeout(function() {
              try {
                if (iframe.contentWindow) {
                  console.log('[YouTube Debug] Iframe verified after 3s: OK', iframeId);
                  const rect = iframe.getBoundingClientRect();
                  console.log('[YouTube Debug] Final iframe dimensions:', {
                    width: rect.width,
                    height: rect.height
                  });
                }
              } catch(e) {
                console.warn('[YouTube Debug] Iframe verified after 3s: Cross-origin error (normal)', iframeId);
              }
            }, 3000);
          });
        }, 100);
      }

      // Escapar HTML para seguridad
      function escapeHtml(text) {
        const div = document.createElement("div");
        div.textContent = text;
        return div.innerHTML;
      }

      // Función para extraer ID de YouTube
      function extractYouTubeId(url) {
        if (!url) {
          console.log("[YouTube Debug] extractYouTubeId: Empty URL");
          return null;
        }
        console.log("[YouTube Debug] extractYouTubeId: URL received:", url);
        const patterns = [
          /(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/)([a-zA-Z0-9_-]{11})/,
          /youtube\.com\/watch\?.*v=([a-zA-Z0-9_-]{11})/,
        ];
        for (const pattern of patterns) {
          const match = url.match(pattern);
          if (match) {
            console.log("[YouTube Debug] extractYouTubeId: ID extracted:", match[1]);
            return match[1];
          }
        }
        console.log("[YouTube Debug] extractYouTubeId: Could not extract ID from:", url);
        return null;
      }

      // Función para crear iframe de YouTube con configuración correcta
      function createYouTubeEmbed(videoId, originalUrl) {
        console.log("[YouTube Debug] createYouTubeEmbed called with:", { videoId, originalUrl });
        
        if (!videoId) {
          console.warn("[YouTube Debug] createYouTubeEmbed: Empty videoId");
          return "";
        }
        
        // Construir URL del embed - usar youtube-nocookie.com que es más permisivo
        // y añadir parámetros para evitar error 153
        const embedUrl = `https://www.youtube-nocookie.com/embed/${videoId}?rel=0&modestbranding=1&origin=${encodeURIComponent(window.location.origin)}`;
        const currentOrigin = window.location.origin;
        const currentHref = window.location.href;
        
        console.log("[YouTube Debug] createYouTubeEmbed:", {
          videoId,
          embedUrl,
          currentOrigin,
          currentHref,
          referrerPolicy: "strict-origin-when-cross-origin",
          userAgent: navigator.userAgent,
          referrer: document.referrer
        });
        
        // Generar ID único para el iframe
        const iframeId = `youtube-iframe-${videoId}-${Date.now()}`;
        
        // Retornar HTML del iframe con referrerpolicy para evitar error 153
        // Usar data attributes para pasar información al callback
        return `
          <div id="youtube-container-${iframeId}" style="position: relative; width: 100%; max-width: 560px; margin: 15px 0; padding-bottom: 56.25%; height: 0; overflow: hidden;">
            <iframe 
              id="${iframeId}"
              data-video-id="${videoId}"
              data-original-url="${originalUrl || ''}"
              src="${embedUrl}" 
              frameborder="0" 
              allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" 
              allowfullscreen 
              referrerpolicy="strict-origin-when-cross-origin"
              style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border-radius: 4px; border: none;"
            ></iframe>
          </div>
        `;
      }

      // Función para extraer ID de Vimeo
      function extractVimeoId(url) {
        if (!url) return null;
        const patterns = [
          /vimeo\.com\/(?:channels\/[^\/]+\/|groups\/[^\/]+\/videos\/|)(\d+)/, // Cualquier formato de vimeo.com
          /player\.vimeo\.com\/video\/(\d+)/, // URL directa del player
        ];
        for (const pattern of patterns) {
          const match = url.match(pattern);
          if (match) return match[1];
        }
        return null;
      }

      // Función para crear iframe de Vimeo
      function createVimeoEmbed(videoId, originalUrl) {
        if (!videoId) return "";
        
        const embedUrl = `https://player.vimeo.com/video/${videoId}`;
        const fallbackUrl = originalUrl || `https://vimeo.com/${videoId}`;
        
        return `
          <div style="position: relative; width: 100%; max-width: 560px; margin: 15px 0; padding-bottom: 56.25%; height: 0; overflow: hidden;">
            <iframe 
              src="${embedUrl}" 
              frameborder="0" 
              allow="autoplay; fullscreen; picture-in-picture" 
              allowfullscreen 
              style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border-radius: 4px; border: none;"
            ></iframe>
          </div>
        `;
      }

      // Función para extraer ID de Instagram
      function extractInstagramId(url) {
        if (!url) return null;
        // Patrones para posts y reels de Instagram
        const patterns = [
          /instagram\.com\/p\/([a-zA-Z0-9_-]+)/, // Post: /p/POST_ID
          /instagram\.com\/reel\/([a-zA-Z0-9_-]+)/, // Reel: /reel/REEL_ID
          /instagram\.com\/tv\/([a-zA-Z0-9_-]+)/, // IGTV: /tv/VIDEO_ID
        ];
        for (const pattern of patterns) {
          const match = url.match(pattern);
          if (match) return match[1];
        }
        return null;
      }

      // Función para crear embed de Instagram
      function createInstagramEmbed(url) {
        if (!url) return "";
        
        // Validar que sea una URL de Instagram
        if (!url.includes('instagram.com')) {
          alert('URL de Instagram inválida. Por favor, ingresa una URL válida de Instagram.');
          return "";
        }
        
        // Normalizar la URL para asegurar que termine con /
        let normalizedUrl = url.trim();
        if (!normalizedUrl.endsWith('/')) {
          normalizedUrl += '/';
        }
        
        // Crear URL de embed
        const embedUrl = normalizedUrl + 'embed/';
        
        return `
          <div style="position: relative; width: 100%; max-width: 540px; margin: 15px 0; min-height: 400px; height: auto; overflow: visible;">
            <iframe 
              src="${embedUrl}" 
              frameborder="0" 
              allow="encrypted-media" 
              style="position: absolute; top: 0; left: 0; width: 100%; min-height: 400px; height: auto; border-radius: 4px; border: none;"
            ></iframe>
          </div>
        `;
      }

      // Función para crear embed de SoundCloud
      function createSoundCloudEmbed(url) {
        if (!url) return "";
        
        // Validar que sea una URL de SoundCloud
        if (!url.includes('soundcloud.com')) {
          alert('URL de SoundCloud inválida. Por favor, ingresa una URL válida de SoundCloud.');
          return "";
        }
        
        // Detectar si es un perfil de usuario o un track específico
        const isProfile = /soundcloud\.com\/[^\/]+$/.test(url) || /soundcloud\.com\/[^\/]+\/?$/.test(url);
        const isTrack = /soundcloud\.com\/[^\/]+\/[^\/]+/.test(url);
        
        // Si es un perfil, usar el widget de perfil completo que muestra tracks recientes
        // Si es un track, usar el widget de track individual
        let embedUrl;
        if (isProfile && !isTrack) {
          // Widget de perfil completo - muestra tracks recientes como reproductor
          const encodedUrl = encodeURIComponent(url);
          embedUrl = `https://w.soundcloud.com/player/?url=${encodedUrl}&color=%23ff5500&auto_play=false&hide_related=false&show_comments=true&show_user=true&show_reposts=true&show_teaser=true&visual=true&sharing=true&download=true&buying=true`;
        } else {
          // Widget de track individual
          const encodedUrl = encodeURIComponent(url);
          embedUrl = `https://w.soundcloud.com/player/?url=${encodedUrl}&color=%23ff5500&auto_play=false&hide_related=false&show_comments=true&show_user=true&show_reposts=false&show_teaser=true&visual=true`;
        }
        
        // Usar altura mayor para el widget de perfil que muestra múltiples tracks
        const height = isProfile && !isTrack ? '450px' : '166px';
        const containerHeight = isProfile && !isTrack ? '450px' : '166px';
        
        return `
          <div style="position: relative; width: 100%; max-width: 100%; margin: 15px 0; height: ${containerHeight}; overflow: visible;">
            <iframe 
              src="${embedUrl}" 
              frameborder="0" 
              allow="autoplay" 
              style="position: absolute; top: 0; left: 0; width: 100%; height: ${height}; border-radius: 4px; border: none;"
            ></iframe>
          </div>
        `;
      }

      // Función para convertir URLs de Imgur a URLs directas
      function convertImgurUrl(url) {
        try {
          if (!url || typeof url !== 'string') return null;
          
          // Si ya es una URL completa (http/https), devolverla tal cual
          if (url.startsWith("http://") || url.startsWith("https://")) {
            // Si es Imgur, asegurar que sea URL directa
            if (url.includes("i.imgur.com")) {
              return url;
            }
            
            // Convertir URLs de Imgur a URL directa
            const imgurPatterns = [
              /imgur\.com\/([a-zA-Z0-9]+)$/, // Post individual: /ID (sin /a/ ni /gallery/) - PRIORIDAD
              /imgur\.com\/a\/([a-zA-Z0-9]+)/, // Álbum: /a/ID
              /imgur\.com\/gallery\/([a-zA-Z0-9]+)/, // Gallery: /gallery/ID
            ];

            for (const pattern of imgurPatterns) {
              const match = url.match(pattern);
              if (match) {
                const imageId = match[1];
                // Intentar con .jpg primero (formato más común)
                return `https://i.imgur.com/${imageId}.jpg`;
              }
            }
            
            return url;
          }
          
          // Si es una ruta local (relativa), convertirla a URL del frontend React
          // Usar la variable global FRONTEND_BASE_URL que se define dinámicamente según el entorno
          const frontendBaseUrl = typeof FRONTEND_BASE_URL !== 'undefined' ? FRONTEND_BASE_URL : (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1' ? "http://localhost:5173" : window.location.origin);
          
          // Si la ruta no empieza con /, asumir que está en /images/
          if (!url.startsWith("/")) {
            // Si parece un nombre de archivo simple (ej: landing-1.jpg), asumir que está en /images/landing/
            if (/^[^\/]+\.(jpg|jpeg|png|gif|webp)$/i.test(url)) {
              const filename = url;
              // Intentar primero en /images/landing/ (común para landing images)
              return `${frontendBaseUrl}/images/landing/${filename}`;
            }
            // Si no, asumir que está en /images/
            return `${frontendBaseUrl}/images/${url}`;
          }
          
          // Si ya empieza con /, solo agregar el base URL
          return `${frontendBaseUrl}${url}`;
        } catch (err) {
          // Si hay algún error, devolver la URL original o null
          console.error("[convertImgurUrl] Error converting URL:", err, "Original URL:", url);
          return url || null;
        }
      }

      // Función para crear imagen con fallback a múltiples formatos
      function createImageWithFallback(imageUrl, alt, styles) {
        if (!imageUrl) return "";
        
        // Si es un álbum de Imgur, intentar múltiples formatos
        if (imageUrl.includes("imgur.com/a/") || imageUrl.includes("imgur.com/gallery/")) {
          const match = imageUrl.match(/imgur\.com\/(?:a|gallery)\/([a-zA-Z0-9]+)/);
          if (match) {
            const imageId = match[1];
            // Crear múltiples sources para intentar diferentes formatos
            return `<img src="https://i.imgur.com/${imageId}.jpg" alt="${escapeHtml(alt)}" style="${styles}" onerror="this.onerror=null; this.src='https://i.imgur.com/${imageId}.png'; this.onerror=function(){this.onerror=null; this.src='https://i.imgur.com/${imageId}.gif'; this.onerror=function(){this.style.display='none'; console.error('No se pudo cargar la imagen del álbum. Usa la URL directa de la imagen específica.');};};" />`;
          }
        }
        
        // Para URLs directas o otras, usar directamente
        const convertedUrl = convertImgurUrl(imageUrl);
        return `<img src="${escapeHtml(convertedUrl)}" alt="${escapeHtml(alt)}" style="${styles}" onerror="this.style.display='none'; console.error('Error loading image:', '${escapeHtml(convertedUrl)}');" />`;
      }

      // ==================== GESTIÓN DE BLOQUES ====================
      let postBlocks = []; // Array de bloques del post actual
      let currentPostType = null; // Tipo de post actual (para mostrar campos predefinidos)

      // Función para actualizar tipo de post actual
      // Variables para el editor de slideshow
      let slideshowSlides = []; // Array de slides: [{ imageUrl, caption }]
      
      function updatePostType(postType) {
        currentPostType = postType;
        
        // Mostrar/ocultar editores según el tipo
        const blocksContainer = document.getElementById('blocks-container');
        const slideshowEditor = document.getElementById('slideshow-editor-container');
        const legacyEditor = document.getElementById('legacy-editor-container');
        
        // Nota: el proyecto migra a "slideshow como bloque", no como tipo de post.
        // Mantenemos el render legacy en el frontend, pero en el admin siempre editamos vía bloques.
        if (blocksContainer) blocksContainer.style.display = 'block';
        if (slideshowEditor) slideshowEditor.style.display = 'none';
        // El editor legacy se muestra solo si no hay bloques (lógica existente en editPost/renderBlocks)
      }
      
      // Inicializar editor de slideshow
      function initSlideshowEditor() {
        // Event listener para añadir slide
        document.getElementById('slideshow-add-slide-btn')?.addEventListener('click', () => {
          addSlideshowSlide();
        });
        
        // Event listener para abrir el editor completo de slideshow
        document.getElementById('open-slideshow-editor-btn')?.addEventListener('click', () => {
          openSlideshowEditorForPost();
        });
        
        // Event listeners para configuración (en el modal)
        document.getElementById('slideshow-modal-show-arrows')?.addEventListener('change', () => {
          updateSlideshowPreviewInModal();
        });
        document.getElementById('slideshow-modal-autoplay')?.addEventListener('change', () => {
          updateSlideshowPreviewInModal();
        });
        document.getElementById('slideshow-modal-interval')?.addEventListener('change', () => {
          updateSlideshowPreviewInModal();
        });
      }
      
      // Añadir un nuevo slide
      function addSlideshowSlide() {
        const slide = {
          imageUrl: '',
          caption: ''
        };
        slideshowSlides.push(slide);
        renderSlideshowSlides();
      }
      
      // Renderizar lista de slides
      function renderSlideshowSlides() {
        const container = document.getElementById('slideshow-slides-list');
        if (!container) return;
        
        if (slideshowSlides.length === 0) {
          container.innerHTML = '<p style="color: #999; font-style: italic; padding: 20px; text-align: center;">No slides yet. Click "Add Slide" to start.</p>';
          return;
        }
        
        let html = '';
        slideshowSlides.forEach((slide, index) => {
          html += `
            <div class="slideshow-slide-item" data-slide-index="${index}" style="padding: 15px; border: 1px solid #ddd; background: #fff;">
              <div style="display: flex; gap: 15px; align-items: flex-start;">
                <div style="flex: 1;">
                  <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                    <label style="font-size: 11px; text-transform: uppercase; font-weight: bold;">Slide ${index + 1}</label>
                    <button type="button" class="slideshow-remove-slide" data-slide-index="${index}" style="padding: 4px 8px; background: #d00; color: #fff; border: none; cursor: pointer; font-size: 10px;">× Remove</button>
                  </div>
                  <label style="display: block; margin-bottom: 5px; font-size: 11px; color: #666;">Image URL (Imgur)</label>
                  <input type="text" class="slideshow-slide-image-url" data-slide-index="${index}" value="${escapeHtml(slide.imageUrl || '')}" placeholder="Imgur URL..." style="width: 100%; padding: 8px; border: 1px solid #000; margin-bottom: 10px; font-size: 12px;" />
                  <label style="display: block; margin-bottom: 5px; font-size: 11px; color: #666;">Caption (optional)</label>
                  <input type="text" class="slideshow-slide-caption" data-slide-index="${index}" value="${escapeHtml(slide.caption || '')}" placeholder="Image caption..." style="width: 100%; padding: 8px; border: 1px solid #000; font-size: 12px;" />
                  ${slide.imageUrl ? `<img src="${escapeHtml(convertImgurUrl(slide.imageUrl))}" style="max-width: 200px; margin-top: 10px; border: 1px solid #ddd; cursor: pointer;" onerror="this.style.display='none';" title="Click to edit" />` : ''}
                </div>
                <div style="display: flex; flex-direction: column; gap: 5px;">
                  <button type="button" class="slideshow-move-slide-up" data-slide-index="${index}" style="padding: 5px 10px; background: #000; color: #fff; border: none; cursor: pointer; font-size: 10px;">↑</button>
                  <button type="button" class="slideshow-move-slide-down" data-slide-index="${index}" style="padding: 5px 10px; background: #000; color: #fff; border: none; cursor: pointer; font-size: 10px;">↓</button>
                </div>
              </div>
            </div>
          `;
        });
        
        container.innerHTML = html;
        
        // Event listeners
        container.querySelectorAll('.slideshow-remove-slide').forEach(btn => {
          btn.addEventListener('click', (e) => {
            const index = parseInt(e.target.dataset.slideIndex);
            slideshowSlides.splice(index, 1);
            renderSlideshowSlides();
            updateSlideshowPreview();
          });
        });
        
        container.querySelectorAll('.slideshow-move-slide-up').forEach(btn => {
          btn.addEventListener('click', (e) => {
            const index = parseInt(e.target.dataset.slideIndex);
            if (index > 0) {
              [slideshowSlides[index], slideshowSlides[index - 1]] = [slideshowSlides[index - 1], slideshowSlides[index]];
              renderSlideshowSlides();
              updateSlideshowPreview();
            }
          });
        });
        
        container.querySelectorAll('.slideshow-move-slide-down').forEach(btn => {
          btn.addEventListener('click', (e) => {
            const index = parseInt(e.target.dataset.slideIndex);
            if (index < slideshowSlides.length - 1) {
              [slideshowSlides[index], slideshowSlides[index + 1]] = [slideshowSlides[index + 1], slideshowSlides[index]];
              renderSlideshowSlides();
              updateSlideshowPreview();
            }
          });
        });
        
        container.querySelectorAll('.slideshow-slide-image-url').forEach(input => {
          input.addEventListener('input', (e) => {
            const index = parseInt(e.target.dataset.slideIndex);
            slideshowSlides[index].imageUrl = e.target.value;
            // Actualizar preview
            const slideItem = e.target.closest('.slideshow-slide-item');
            if (slideItem) {
              const preview = slideItem.querySelector('img');
              if (preview && e.target.value) {
                preview.src = convertImgurUrl(e.target.value);
                preview.style.display = 'block';
              }
            }
            updateSlideshowPreview();
          });
          
          // Detectar cuando se pega una URL de Imgur y abrir editor
          input.addEventListener('blur', (e) => {
            const url = e.target.value.trim();
            if (url && (url.includes("imgur.com") || url.includes("i.imgur.com"))) {
              const index = parseInt(e.target.dataset.slideIndex);
              const imageUrl = convertImgurUrl(url);
              setTimeout(() => {
                openImageEditorForSlideshow(imageUrl, index);
              }, 300);
            }
          });
        });
        
        container.querySelectorAll('.slideshow-slide-caption').forEach(input => {
          input.addEventListener('input', (e) => {
            const index = parseInt(e.target.dataset.slideIndex);
            slideshowSlides[index].caption = e.target.value;
            updateSlideshowPreview();
          });
        });
        
        // Permitir editar imagen haciendo click en la preview
        container.querySelectorAll('.slideshow-slide-item img').forEach(img => {
          img.style.cursor = 'pointer';
          img.addEventListener('click', (e) => {
            const slideItem = e.target.closest('.slideshow-slide-item');
            if (slideItem) {
              const index = parseInt(slideItem.dataset.slideIndex);
              const urlInput = slideItem.querySelector('.slideshow-slide-image-url');
              if (urlInput && urlInput.value) {
                const imageUrl = convertImgurUrl(urlInput.value);
                openImageEditorForSlideshow(imageUrl, index);
              }
            }
          });
        });
      }
      
      // Función para abrir editor de imágenes para bloques
      function openImageEditorForBlock(imageUrl, blockIndex, block) {
        currentImageUrl = imageUrl;
        currentImageIndex = null;
        currentImageElement = null;
        currentBlockContext = {
          type: block.type,
          blockIndex: blockIndex,
          block: block
        };
        
        const img = document.getElementById('image-editor-img');
        const modal = document.getElementById('image-editor-modal');
        
        if (!img || !modal) {
          console.error('Image editor elements not found');
          return;
        }
        
        // Limpiar cropper anterior si existe
        if (imageCropper) {
          imageCropper.destroy();
          imageCropper = null;
        }
        
        // Resetear la imagen
        img.src = '';
        
        // Cargar la imagen
        img.src = imageUrl;
        
        img.onload = function() {
          // Mostrar modal
          modal.classList.add('show');
          
          // Esperar un momento para que el modal se renderice
          setTimeout(function() {
            // Inicializar Cropper.js
            if (imageCropper) {
              imageCropper.destroy();
            }
            
            const cropperOptions = {
              aspectRatio: NaN, // Permite cualquier proporción por defecto
              viewMode: 1,
              dragMode: 'move',
              autoCropArea: 0.8,
              restore: false,
              guides: true,
              center: true,
              highlight: true,
              cropBoxMovable: true,
              cropBoxResizable: true,
              toggleable: true,
            };
            
            imageCropper = new Cropper(img, cropperOptions);
          }, 100);
        };
        
        img.onerror = function() {
          console.error('Error loading image:', imageUrl);
          alert('Error loading image. Please check the URL.');
        };
      }
      
      // Abrir editor de imágenes para slideshow
      function openImageEditorForSlideshow(imageUrl, slideIndex) {
        currentImageUrl = imageUrl;
        currentImageIndex = null;
        currentImageElement = null;
        currentBlockContext = {
          type: 'slideshow-post',
          slideIndex: slideIndex
        };
        
        const img = document.getElementById('image-editor-img');
        const modal = document.getElementById('image-editor-modal');
        
        if (!img || !modal) {
          console.error('Image editor elements not found');
          return;
        }
        
        // Limpiar cropper anterior si existe
        if (imageCropper) {
          imageCropper.destroy();
          imageCropper = null;
        }
        
        // Resetear la imagen
        img.src = '';
        
        // Cargar la imagen
        img.src = imageUrl;
        
        img.onload = function() {
          // Mostrar modal
          modal.classList.add('show');
          
          // Esperar un momento para que el modal se renderice
          setTimeout(function() {
            // Inicializar Cropper.js
            if (imageCropper) {
              imageCropper.destroy();
            }
            
            // El frontend decidirá las dimensiones, aquí usamos un aspect ratio por defecto para el cropper
            // Puedes cambiar este valor según tus necesidades de diseño
            const defaultAspectRatio = 1200 / 800; // Aspect ratio por defecto (3:2)
            
            imageCropper = new Cropper(img, {
              aspectRatio: defaultAspectRatio,
              viewMode: 1,
              dragMode: 'move',
              autoCropArea: 0.8,
              restore: false,
              guides: true,
              center: true,
              highlight: false,
              cropBoxMovable: true,
              cropBoxResizable: true,
              toggleable: true,
              minCropBoxWidth: 50,
              minCropBoxHeight: 50,
            });
          }, 100);
        };
        
        img.onerror = function() {
          alert('Error loading image. Please check the URL.');
          modal.classList.remove('show');
        };
      }
      
      // Actualizar preview del slideshow (ya no se usa, el preview está en el modal)
      function updateSlideshowPreview() {
        // Esta función ya no se usa porque el preview está en el modal
        // Se mantiene para compatibilidad con código legacy que aún la llama
      }

      // Función para calcular el ancho requerido del siguiente bloque basado en la lógica espacial
      function calculateRequiredNextWidth(currentWidth, currentIndex) {
        // Si el bloque actual es "full", completa la fila, siguiente puede ser cualquier cosa
        if (currentWidth === 'full') {
          return null;
        }
        
        // Calcular el ancho acumulado desde el último bloque "full" hasta el bloque anterior al actual
        let accumulatedWidth = 0;
        let startIndex = 0;
        
        // Buscar el último bloque "full" antes del bloque actual
        for (let i = currentIndex - 1; i >= 0; i--) {
          const prevWidth = (postBlocks[i].metadata && postBlocks[i].metadata.width) || 'full';
          if (prevWidth === 'full') {
            startIndex = i + 1;
            break;
          }
        }
        
        // Calcular ancho acumulado desde startIndex hasta currentIndex - 1 (sin incluir el actual)
        for (let i = startIndex; i < currentIndex; i++) {
          const width = (postBlocks[i].metadata && postBlocks[i].metadata.width) || 'full';
          if (width === 'half') accumulatedWidth += 0.5;
          else if (width === 'third') accumulatedWidth += 1/3;
          else if (width === 'two-thirds') accumulatedWidth += 2/3;
          else if (width === 'full') {
            accumulatedWidth = 0; // Reinicia si hay un full (no debería pasar)
            startIndex = i + 1;
          }
        }
        
        // Añadir el ancho del bloque actual
        if (currentWidth === 'half') {
          accumulatedWidth += 0.5;
        } else if (currentWidth === 'third') {
          accumulatedWidth += 1/3;
        } else if (currentWidth === 'two-thirds') {
          accumulatedWidth += 2/3;
        }
        
        // Determinar qué ancho necesita el siguiente bloque para completar la fila
        const remaining = 1 - accumulatedWidth;
        const tolerance = 0.01; // Tolerancia para comparaciones de punto flotante
        
        if (Math.abs(remaining) < tolerance) {
          // La fila está completa, siguiente puede ser cualquier cosa
          return null;
        } else if (Math.abs(remaining - 0.5) < tolerance) {
          // Necesita half para completar
          return 'half';
        } else if (Math.abs(remaining - 1/3) < tolerance) {
          // Necesita third para completar
          return 'third';
        } else if (Math.abs(remaining - 2/3) < tolerance) {
          // Necesita two-thirds para completar
          return 'two-thirds';
        }
        
        // Si no hay coincidencia exacta, no hay restricción
        return null;
      }
      
      // Función para aplicar lógica espacial a todos los bloques antes de renderizar
      function applySpatialLogicToBlocks() {
        console.log("[Spatial Logic] ========== APPLYING SPATIAL LOGIC ==========");
        console.log("[Spatial Logic] Total blocks:", postBlocks.length);
        
        // Procesar todos los bloques en orden para aplicar la lógica espacial
        for (let i = 0; i < postBlocks.length; i++) {
          const block = postBlocks[i];
          if (!block.metadata) block.metadata = {};
          
          // Si el bloque no tiene ancho definido, usar 'full' por defecto
          if (!block.metadata.width) {
            block.metadata.width = 'full';
          }
          
          console.log(`[Spatial Logic] Block ${i}: width=${block.metadata.width}`);
          
          // Si no es el primer bloque, verificar si debe estar bloqueado
          if (i > 0) {
            const prevWidth = (postBlocks[i - 1].metadata && postBlocks[i - 1].metadata.width) || 'full';
            const requiredWidth = calculateRequiredNextWidth(prevWidth, i - 1);
            
            console.log(`[Spatial Logic] Block ${i}: prevWidth=${prevWidth}, requiredWidth=${requiredWidth}`);
            
            if (requiredWidth) {
              // El ancho está bloqueado por la lógica espacial
              block.metadata.width = requiredWidth;
              block.metadata.lockedWidth = true;
              console.log(`[Spatial Logic] Block ${i}: ✅ LOCKED to ${requiredWidth}`);
            } else {
              // No hay restricción, desbloquear si estaba bloqueado
              block.metadata.lockedWidth = false;
              console.log(`[Spatial Logic] Block ${i}: ✅ UNLOCKED`);
            }
          } else {
            // Primer bloque nunca está bloqueado
            block.metadata.lockedWidth = false;
            console.log(`[Spatial Logic] Block ${i}: ✅ UNLOCKED (first block)`);
          }
        }
        console.log("[Spatial Logic] ========== SPATIAL LOGIC APPLIED ==========");
      }
      
      // Función para renderizar bloques
      function renderBlocks() {
        const container = document.getElementById("blocks-list");
        container.innerHTML = "";

        if (postBlocks.length === 0) {
          container.innerHTML = '<p style="color: #999; font-style: italic; padding: 20px; text-align: center;">No blocks yet. Click "Add Block" to start.</p>';
          return;
        }

        // Aplicar lógica espacial antes de renderizar
        applySpatialLogicToBlocks();

        postBlocks.forEach((block, index) => {
          const blockElement = createBlockElement(block, index);
          container.appendChild(blockElement);
        });
      }

      // Función para crear elemento de bloque
      function createBlockElement(block, index) {
        const div = document.createElement("div");
        div.className = "block-item";
        div.dataset.index = index;
        div.style.cssText = "padding: 15px; border: 1px solid #ddd; background: #fff; position: relative;";

        const blockType = block.type || "text";
        let content = "";

        if (blockType === "slideshow_image") {
          // Bloque especial para slideshow
          content = `
            <div style="display: flex; gap: 15px; align-items: flex-start;">
              <div style="flex: 1;">
                <label style="display: block; margin-bottom: 5px; font-size: 11px; text-transform: uppercase;">Image URL</label>
                <input type="text" class="block-content-input" data-field="content" value="${escapeHtml(block.content || "")}" placeholder="Imgur URL..." style="width: 100%; padding: 8px; border: 1px solid #000; margin-bottom: 10px;" />
                <label style="display: block; margin-bottom: 5px; font-size: 11px; text-transform: uppercase;">Caption (optional)</label>
                <input type="text" class="block-metadata-input" data-field="caption" value="${escapeHtml((block.metadata && block.metadata.caption) || "")}" placeholder="Image caption..." style="width: 100%; padding: 8px; border: 1px solid #000;" />
                ${block.content ? `<img src="${escapeHtml(convertImgurUrl(block.content))}" style="max-width: 200px; margin-top: 10px; border: 1px solid #ddd;" onerror="this.style.display='none';" />` : ""}
              </div>
              <div style="display: flex; flex-direction: column; gap: 5px;">
                <button type="button" class="move-block-up" style="padding: 5px 10px; background: #000; color: #fff; border: none; cursor: pointer; font-size: 10px;">↑</button>
                <button type="button" class="move-block-down" style="padding: 5px 10px; background: #000; color: #fff; border: none; cursor: pointer; font-size: 10px;">↓</button>
                <button type="button" class="delete-block" style="padding: 5px 10px; background: #d00; color: #fff; border: none; cursor: pointer; font-size: 10px;">×</button>
              </div>
            </div>
          `;
        } else if (blockType === "image") {
          content = `
            <div style="display: flex; gap: 15px; align-items: flex-start;">
              <div style="flex: 1;">
                <label style="display: block; margin-bottom: 5px; font-size: 11px; text-transform: uppercase;">Image URL</label>
                <input type="text" class="block-content-input block-image-url-input" data-field="content" data-block-index="${index}" value="${escapeHtml(block.content || "")}" placeholder="Imgur URL..." style="width: 100%; padding: 8px; border: 1px solid #000; margin-bottom: 10px;" />
                <label style="display: block; margin-bottom: 5px; font-size: 11px; text-transform: uppercase;">Caption (optional)</label>
                <input type="text" class="block-metadata-input" data-field="caption" value="${escapeHtml((block.metadata && block.metadata.caption) || "")}" placeholder="Image caption..." style="width: 100%; padding: 8px; border: 1px solid #000;" />
                ${block.content ? `<img src="${escapeHtml(convertImgurUrl(block.content))}" class="block-image-preview" style="max-width: 200px; margin-top: 10px; border: 1px solid #ddd; cursor: pointer;" onerror="this.style.display='none';" title="Click to edit" />` : ""}
              </div>
              <div style="display: flex; flex-direction: column; gap: 5px;">
                <button type="button" class="move-block-up" style="padding: 5px 10px; background: #000; color: #fff; border: none; cursor: pointer; font-size: 10px;">↑</button>
                <button type="button" class="move-block-down" style="padding: 5px 10px; background: #000; color: #fff; border: none; cursor: pointer; font-size: 10px;">↓</button>
                <button type="button" class="delete-block" style="padding: 5px 10px; background: #d00; color: #fff; border: none; cursor: pointer; font-size: 10px;">×</button>
              </div>
            </div>
          `;
        } else if (blockType === "text") {
          // Para texto, usar Quill completo
          const editorId = `quill-editor-${index}`;
          content = `
            <div style="display: flex; gap: 15px; align-items: flex-start;">
              <div style="flex: 1;">
                <label style="display: block; margin-bottom: 5px; font-size: 11px; text-transform: uppercase;">Text Content</label>
                <div id="${editorId}" class="block-quill-editor" style="min-height: 200px; margin-bottom: 10px;"></div>
                <input type="hidden" class="block-content-input" data-field="content" data-editor-id="${editorId}" />
              </div>
              <div style="display: flex; flex-direction: column; gap: 5px;">
                <button type="button" class="move-block-up" style="padding: 5px 10px; background: #000; color: #fff; border: none; cursor: pointer; font-size: 10px;">↑</button>
                <button type="button" class="move-block-down" style="padding: 5px 10px; background: #000; color: #fff; border: none; cursor: pointer; font-size: 10px;">↓</button>
                <button type="button" class="delete-block" style="padding: 5px 10px; background: #d00; color: #fff; border: none; cursor: pointer; font-size: 10px;">×</button>
              </div>
            </div>
          `;
        } else if (blockType === "slideshow") {
          // Bloque completo de slideshow con múltiples imágenes
          const slideshowId = `slideshow-${index}`;
          const images = (block.metadata && block.metadata.images) || [];
          const config = (block.metadata && block.metadata.slideshowConfig) || {};
          const showArrows = config.showArrows !== undefined ? config.showArrows : true;
          const arrowStyle = config.arrowStyle || 'arrows';
          const autoPlay = config.autoPlay !== undefined ? config.autoPlay : false;
          const slideDuration = config.slideDuration || 3;
          // Usar dimensiones por defecto si no están definidas
          const imageWidth = config.imageWidth || 1200;
          const imageHeight = config.imageHeight || 800;
          
          const imagesHtml = images.map((img, imgIndex) => {
            // Aplicar dimensiones si están definidas
            const config = (block.metadata && block.metadata.slideshowConfig) || {};
            const imageWidth = config.imageWidth;
            const imageHeight = config.imageHeight;
            const previewStyle = imageWidth && imageHeight 
              ? `max-width: 150px; max-height: ${150 * (imageHeight / imageWidth)}px; margin-top: 8px; border: 1px solid #ddd; object-fit: cover;`
              : `max-width: 150px; margin-top: 8px; border: 1px solid #ddd;`;
            
            return `
            <div class="slideshow-image-item" data-img-index="${imgIndex}" style="padding: 10px; border: 1px solid #ddd; margin-bottom: 10px; background: #f9f9f9;">
              <div style="display: flex; gap: 10px; align-items: flex-start;">
                <div style="flex: 1;">
                  <label style="display: block; margin-bottom: 5px; font-size: 10px; text-transform: uppercase;">Image ${imgIndex + 1} URL</label>
                  <input type="text" class="slideshow-image-url" data-img-index="${imgIndex}" value="${escapeHtml(img.url || "")}" placeholder="Imgur URL..." style="width: 100%; padding: 6px; border: 1px solid #000; margin-bottom: 8px; font-size: 12px;" />
                  <label style="display: block; margin-bottom: 5px; font-size: 10px; text-transform: uppercase;">Caption (optional)</label>
                  <input type="text" class="slideshow-image-caption" data-img-index="${imgIndex}" value="${escapeHtml(img.caption || "")}" placeholder="Image caption..." style="width: 100%; padding: 6px; border: 1px solid #000; font-size: 12px;" />
                  ${img.url ? `<img src="${escapeHtml(convertImgurUrl(img.url))}" style="${previewStyle}" onerror="this.style.display='none';" />` : ""}
                  ${imageWidth && imageHeight ? `<div style="font-size: 9px; color: #999; margin-top: 4px;">Target: ${imageWidth}×${imageHeight}px</div>` : ''}
                </div>
                <div style="display: flex; flex-direction: column; gap: 5px;">
                  <button type="button" class="move-slide-up" data-img-index="${imgIndex}" style="padding: 4px 8px; background: #000; color: #fff; border: none; cursor: pointer; font-size: 9px;">↑</button>
                  <button type="button" class="move-slide-down" data-img-index="${imgIndex}" style="padding: 4px 8px; background: #000; color: #fff; border: none; cursor: pointer; font-size: 9px;">↓</button>
                  <button type="button" class="remove-slide" data-img-index="${imgIndex}" style="padding: 4px 8px; background: #d00; color: #fff; border: none; cursor: pointer; font-size: 9px;">×</button>
                </div>
              </div>
            </div>
          `;
          }).join("");
          
          content = `
            <div style="display: flex; gap: 15px; align-items: flex-start;">
              <div style="flex: 1;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                  <label style="font-size: 11px; text-transform: uppercase; font-weight: bold;">Slideshow Images</label>
                  <button type="button" class="add-slide-btn" data-slideshow-id="${slideshowId}" style="padding: 6px 12px; background: #000; color: #fff; border: none; cursor: pointer; font-size: 10px; text-transform: uppercase;">+ Add Image</button>
                </div>
                <div id="${slideshowId}" class="slideshow-images-container" style="min-height: 50px; margin-bottom: 20px;">
                  ${imagesHtml || '<p style="color: #999; font-style: italic; padding: 10px; text-align: center; font-size: 11px;">No images yet. Click "Add Image" to start.</p>'}
                </div>
                
                <!-- Botón para abrir el editor completo de slideshow -->
                <div style="padding: 15px; border: 1px solid #ddd; background: #f9f9f9; margin-top: 15px;">
                  <button type="button" class="open-slideshow-editor-btn" style="width: 100%; padding: 10px 16px; background: #000000; color: #ffffff; border: 1px solid #000000; border-radius: 0; cursor: pointer; font-size: 11px; text-transform: uppercase; letter-spacing: 0.5px;">
                    Open Slideshow Editor
                  </button>
                  <p style="font-size: 10px; color: #666; margin-top: 8px; font-style: italic; text-align: center;">
                    Configure settings, preview, and edit individual images
                  </p>
                </div>
                
                <input type="hidden" class="block-content-input" data-field="content" value="" />
              </div>
              <div style="display: flex; flex-direction: column; gap: 5px;">
                <button type="button" class="move-block-up" style="padding: 5px 10px; background: #000; color: #fff; border: none; cursor: pointer; font-size: 10px;">↑</button>
                <button type="button" class="move-block-down" style="padding: 5px 10px; background: #000; color: #fff; border: none; cursor: pointer; font-size: 10px;">↓</button>
                <button type="button" class="delete-block" style="padding: 5px 10px; background: #d00; color: #fff; border: none; cursor: pointer; font-size: 10px;">×</button>
              </div>
            </div>
          `;
        } else if (blockType === "video") {
          // Bloque de video (detecta automáticamente YouTube o Vimeo)
          const placeholder = "YouTube or Vimeo URL (e.g., https://www.youtube.com/watch?v=... or https://vimeo.com/...)";
          content = `
            <div style="display: flex; gap: 15px; align-items: flex-start;">
              <div style="flex: 1;">
                <label style="display: block; margin-bottom: 5px; font-size: 11px; text-transform: uppercase;">Video URL (YouTube/Vimeo)</label>
                <input type="text" class="block-content-input" data-field="content" value="${escapeHtml(block.content || "")}" placeholder="${placeholder}" style="width: 100%; padding: 8px; border: 1px solid #000; margin-bottom: 10px;" />
                ${block.content ? `
                  <div style="margin-top: 10px; padding: 10px; background: #f9f9f9; border: 1px solid #ddd;">
                    <small style="font-size: 10px; color: #666;">Preview:</small>
                    ${block.content.includes('youtube') || block.content.includes('youtu.be') ? 
                      `<div style="margin-top: 5px; color: #c00; font-size: 11px;">✓ YouTube video detected</div>` :
                      block.content.includes('vimeo') ?
                      `<div style="margin-top: 5px; color: #1ab7ea; font-size: 11px;">✓ Vimeo video detected</div>` :
                      `<div style="margin-top: 5px; color: #999; font-size: 11px;">Enter a YouTube or Vimeo URL</div>`
                    }
                  </div>
                ` : ""}
              </div>
              <div style="display: flex; flex-direction: column; gap: 5px;">
                <button type="button" class="move-block-up" style="padding: 5px 10px; background: #000; color: #fff; border: none; cursor: pointer; font-size: 10px;">↑</button>
                <button type="button" class="move-block-down" style="padding: 5px 10px; background: #000; color: #fff; border: none; cursor: pointer; font-size: 10px;">↓</button>
                <button type="button" class="delete-block" style="padding: 5px 10px; background: #d00; color: #fff; border: none; cursor: pointer; font-size: 10px;">×</button>
              </div>
            </div>
          `;
        } else {
          // Para otros tipos (embeds de Instagram, SoundCloud, etc.)
          const labelMap = {
            'embed_instagram': 'Instagram URL',
            'embed_soundcloud': 'SoundCloud URL',
            'link': 'Link URL'
          };
          const label = labelMap[blockType] || `${blockType} URL`;
          content = `
            <div style="display: flex; gap: 15px; align-items: flex-start;">
              <div style="flex: 1;">
                <label style="display: block; margin-bottom: 5px; font-size: 11px; text-transform: uppercase;">${label}</label>
                <input type="text" class="block-content-input" data-field="content" value="${escapeHtml(block.content || "")}" placeholder="URL..." style="width: 100%; padding: 8px; border: 1px solid #000;" />
              </div>
              <div style="display: flex; flex-direction: column; gap: 5px;">
                <button type="button" class="move-block-up" style="padding: 5px 10px; background: #000; color: #fff; border: none; cursor: pointer; font-size: 10px;">↑</button>
                <button type="button" class="move-block-down" style="padding: 5px 10px; background: #000; color: #fff; border: none; cursor: pointer; font-size: 10px;">↓</button>
                <button type="button" class="delete-block" style="padding: 5px 10px; background: #d00; color: #fff; border: none; cursor: pointer; font-size: 10px;">×</button>
              </div>
            </div>
          `;
        }

        // Obtener ancho del bloque (default: full)
        const blockWidth = (block.metadata && block.metadata.width) || 'full';
        // Verificar si el bloque es obligatorio
        const isRequired = (block.metadata && block.metadata.required === true);
        // Verificar si el ancho está bloqueado por la lógica espacial
        const isWidthLocked = (block.metadata && block.metadata.lockedWidth === true);
        
        const widthSelectStyle = isWidthLocked 
          ? "padding: 4px 8px; border: 1px solid #999; font-size: 10px; background: #f5f5f5; opacity: 0.7; cursor: not-allowed;"
          : "padding: 4px 8px; border: 1px solid #000; font-size: 10px; background: #fff;";
        
        div.innerHTML = `
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; ${isRequired ? 'background: #fff3cd; padding: 8px; border: 1px solid #ffc107;' : ''}">
            <div style="display: flex; align-items: center; gap: 8px;">
              <span style="font-size: 11px; text-transform: uppercase; font-weight: bold;">${blockType}</span>
              ${isRequired ? '<span style="font-size: 9px; color: #856404; background: #ffc107; padding: 2px 6px; border-radius: 2px; font-weight: bold;">REQUIRED</span>' : ''}
              ${isWidthLocked ? '<span style="font-size: 9px; color: #666; background: #e0e0e0; padding: 2px 6px; border-radius: 2px; font-weight: bold;">LOCKED</span>' : ''}
            </div>
            <div style="display: flex; gap: 10px; align-items: center;">
              <label style="font-size: 10px; color: #666; margin-right: 5px;">Width:</label>
              <select class="block-width-select" ${isWidthLocked ? 'disabled' : ''} style="${widthSelectStyle}" title="${isWidthLocked ? 'Width is locked by spatial logic' : 'Select block width'}">
                <option value="full" ${blockWidth === 'full' ? 'selected' : ''}>Full</option>
                <option value="half" ${blockWidth === 'half' ? 'selected' : ''}>Half</option>
                <option value="third" ${blockWidth === 'third' ? 'selected' : ''}>Third</option>
                <option value="two-thirds" ${blockWidth === 'two-thirds' ? 'selected' : ''}>Two Thirds</option>
              </select>
              <span style="font-size: 10px; color: #999;">Block ${index + 1}</span>
            </div>
          </div>
          ${content}
        `;
        
        // Marcar el bloque como obligatorio en el dataset
        if (isRequired) {
          div.dataset.required = 'true';
        }

        // Event listeners
        const deleteBtn = div.querySelector(".delete-block");
        if (deleteBtn) {
          // Si el bloque es obligatorio, deshabilitar o prevenir eliminación
          if (isRequired) {
            deleteBtn.style.opacity = "0.5";
            deleteBtn.style.cursor = "not-allowed";
            deleteBtn.title = "This block is required and cannot be deleted";
            deleteBtn.addEventListener("click", (e) => {
              e.preventDefault();
              showMessage("This block is required and cannot be deleted", "error");
            });
          } else {
            deleteBtn.addEventListener("click", () => {
              postBlocks.splice(index, 1);
              renderBlocks();
            });
          }
        }

        div.querySelector(".move-block-up")?.addEventListener("click", () => {
          if (index > 0) {
            [postBlocks[index], postBlocks[index - 1]] = [postBlocks[index - 1], postBlocks[index]];
            renderBlocks();
          }
        });

        div.querySelector(".move-block-down")?.addEventListener("click", () => {
          if (index < postBlocks.length - 1) {
            [postBlocks[index], postBlocks[index + 1]] = [postBlocks[index + 1], postBlocks[index]];
            renderBlocks();
          }
        });

        // Actualizar bloque cuando cambia el contenido
        div.querySelectorAll(".block-content-input, .block-metadata-input").forEach(input => {
          input.addEventListener("input", (e) => {
            const field = e.target.dataset.field;
            if (field === "content") {
              block.content = e.target.value;
            } else if (field === "caption") {
              if (!block.metadata) block.metadata = {};
              block.metadata.caption = e.target.value;
            }
          });
        });

        // Detectar URLs de Imgur en bloques de imagen y abrir editor automáticamente
        if (blockType === "image") {
          const imageInput = div.querySelector(".block-image-url-input");
          const imagePreview = div.querySelector(".block-image-preview");
          
          if (imageInput) {
            // Detectar cuando se pega o escribe una URL de Imgur
            imageInput.addEventListener("blur", (e) => {
              const url = e.target.value.trim();
              if (url && (url.includes("imgur.com") || url.includes("i.imgur.com"))) {
                // Convertir URL de Imgur a URL directa
                let imageUrl = convertImgurUrl(url);
                // Abrir editor de imágenes
                setTimeout(() => {
                  openImageEditorForBlock(imageUrl, index, block);
                }, 300);
              }
            });

            // También detectar cuando se actualiza la preview
            imageInput.addEventListener("input", (e) => {
              const url = e.target.value.trim();
              if (url && (url.includes("imgur.com") || url.includes("i.imgur.com"))) {
                const imageUrl = convertImgurUrl(url);
                const preview = div.querySelector(".block-image-preview");
                if (preview) {
                  preview.src = imageUrl;
                  preview.style.display = "block";
                }
              }
            });
          }

          // Permitir editar imagen haciendo click en la preview
          if (imagePreview) {
            imagePreview.addEventListener("click", () => {
              if (block.content) {
                const imageUrl = convertImgurUrl(block.content);
                openImageEditorForBlock(imageUrl, index, block);
              }
            });
          }
        }

        // Actualizar ancho del bloque con lógica espacial
        const widthSelect = div.querySelector(".block-width-select");
        if (widthSelect) {
          // Deshabilitar selector si el ancho está bloqueado
          if (isWidthLocked) {
            widthSelect.disabled = true;
            widthSelect.title = "Width is locked by spatial logic";
            widthSelect.style.opacity = "0.6";
            widthSelect.style.cursor = "not-allowed";
          } else {
            widthSelect.addEventListener("change", (e) => {
              if (!block.metadata) block.metadata = {};
              const newWidth = e.target.value;
              block.metadata.width = newWidth;
              block.metadata.lockedWidth = false; // Este bloque ya no está bloqueado
              
              // Re-renderizar para aplicar la lógica espacial a todos los bloques
              renderBlocks();
            });
          }
        }

        // Inicializar Quill para bloques de texto
        if (blockType === "text") {
          setTimeout(() => {
            const editorId = `quill-editor-${index}`;
            const editorContainer = div.querySelector(`#${editorId}`);
            const hiddenInput = div.querySelector(`input[data-editor-id="${editorId}"]`);
            
            if (editorContainer && typeof Quill !== 'undefined') {
              // Crear editor Quill con todas las herramientas (igual que el editor principal)
              const blockQuill = new Quill(editorContainer, {
                theme: 'snow',
                modules: {
                  toolbar: {
                    container: [
                      [{ 'header': [1, 2, 3, 4, 5, 6, false] }],
                      ['bold', 'italic', 'underline', 'strike'],
                      [{ 'color': [] }, { 'background': [] }],
                      [{ 'list': 'ordered'}, { 'list': 'bullet' }],
                      [{ 'align': [] }],
                      ['link', 'image', 'video', 'instagram', 'soundcloud'],
                      ['clean']
                    ],
                    handlers: {
                      'image': function() {
                        const url = prompt('Paste the image URL (Imgur or other hosting):\n\nExample: https://imgur.com/9S1xRRy or https://i.imgur.com/example.jpg');
                        if (url && url.trim() !== '') {
                          let imageUrl = url.trim();
                          if (imageUrl.includes('imgur.com') && !imageUrl.includes('i.imgur.com')) {
                            const imgurPatterns = [
                              /imgur\.com\/([a-zA-Z0-9]+)$/,
                              /imgur\.com\/a\/([a-zA-Z0-9]+)/,
                              /imgur\.com\/gallery\/([a-zA-Z0-9]+)/,
                            ];
                            for (const pattern of imgurPatterns) {
                              const match = imageUrl.match(pattern);
                              if (match) {
                                const imageId = match[1];
                                imageUrl = `https://i.imgur.com/${imageId}.jpg`;
                                break;
                              }
                            }
                          }
                          try {
                            new URL(imageUrl);
                            const range = blockQuill.getSelection(true);
                            const insertIndex = range.index;
                            blockQuill.insertEmbed(insertIndex, 'image', imageUrl, 'user');
                            setTimeout(() => openImageEditor(imageUrl, insertIndex, blockQuill), 100);
                          } catch (e) {
                            alert('Invalid URL. Please enter a valid URL (e.g., https://imgur.com/9S1xRRy)');
                          }
                        }
                      },
                      'video': function() {
                        const videoUrl = prompt('Paste the video URL (YouTube or Vimeo):\n\nExamples:\n• YouTube: https://www.youtube.com/watch?v=VIDEO_ID\n• Vimeo: https://vimeo.com/VIDEO_ID');
                        if (!videoUrl || videoUrl.trim() === '') return;
                        const url = videoUrl.trim();
                        let embedHtml = '';
                        const youtubeId = extractYouTubeId(url);
                        if (youtubeId) {
                          embedHtml = createYouTubeEmbed(youtubeId, url);
                        } else {
                          const vimeoId = extractVimeoId(url);
                          if (vimeoId) {
                            embedHtml = createVimeoEmbed(vimeoId, url);
                          } else {
                            alert('Unrecognized URL. Please enter a valid YouTube or Vimeo URL.');
                            return;
                          }
                        }
                        if (embedHtml) {
                          const range = blockQuill.getSelection(true);
                          let index = range ? range.index : blockQuill.getLength();
                          if (index > 0) {
                            const textBefore = blockQuill.getText(Math.max(0, index - 1), 1);
                            if (textBefore && textBefore !== '\n') {
                              blockQuill.insertText(index, '\n', 'user');
                              index += 1;
                            }
                          }
                          blockQuill.insertEmbed(index, 'video', embedHtml, 'user');
                          const newIndex = index + 1;
                          blockQuill.insertText(newIndex, '\n', 'user');
                          blockQuill.setSelection(newIndex + 1);
                        }
                      },
                      'link': function(value) {
                        const quill = blockQuill;
                        if (value && typeof value === 'string') {
                          const url = prompt('Edit link URL:', value);
                          if (url && url.trim() !== '' && url !== 'https://') {
                            try {
                              new URL(url);
                              const range = quill.getSelection(true);
                              if (range) {
                                quill.formatText(range.index, range.length, 'link', url);
                              }
                            } catch (e) {
                              alert('Invalid URL. Please enter a valid URL.');
                            }
                          }
                        } else {
                          const range = quill.getSelection(true);
                          if (!range) {
                            const text = prompt('Link text:');
                            if (!text || text.trim() === '') return;
                            const url = prompt('Link URL:', 'https://');
                            if (url && url.trim() !== '' && url !== 'https://') {
                              try {
                                new URL(url);
                                const insertRange = quill.getSelection(true) || { index: quill.getLength() };
                                quill.insertText(insertRange.index, text, 'user');
                                quill.formatText(insertRange.index, text.length, 'link', url);
                                quill.setSelection(insertRange.index + text.length);
                              } catch (e) {
                                alert('Invalid URL. Please enter a valid URL.');
                              }
                            }
                            return;
                          }
                          let text = quill.getText(range.index, range.length);
                          if (!text || text.trim() === '') {
                            text = prompt('Link text:');
                            if (!text || text.trim() === '') return;
                          }
                          const url = prompt('Link URL:', 'https://');
                          if (url && url.trim() !== '' && url !== 'https://') {
                            try {
                              new URL(url);
                              if (range.length === 0) {
                                quill.insertText(range.index, text, 'user');
                                quill.formatText(range.index, text.length, 'link', url);
                                quill.setSelection(range.index + text.length);
                              } else {
                                quill.formatText(range.index, range.length, 'link', url);
                              }
                            } catch (e) {
                              alert('Invalid URL. Please enter a valid URL.');
                            }
                          }
                        }
                      },
                      'instagram': function() {
                        const instagramUrl = prompt('Paste the Instagram URL (post or reel):\n\nExamples:\n• https://www.instagram.com/p/POST_ID/\n• https://www.instagram.com/reel/REEL_ID/');
                        if (!instagramUrl || instagramUrl.trim() === '') return;
                        const url = instagramUrl.trim();
                        const embedHtml = createInstagramEmbed(url);
                        if (embedHtml) {
                          const range = blockQuill.getSelection(true);
                          let index = range ? range.index : blockQuill.getLength();
                          if (index > 0) {
                            const textBefore = blockQuill.getText(Math.max(0, index - 1), 1);
                            if (textBefore && textBefore !== '\n') {
                              blockQuill.insertText(index, '\n', 'user');
                              index += 1;
                            }
                          } else {
                            blockQuill.insertText(index, '\n', 'user');
                            index += 1;
                          }
                          blockQuill.insertEmbed(index, 'instagram', embedHtml, 'user');
                          const newIndex = index + 1;
                          blockQuill.insertText(newIndex, '\n', 'user');
                          blockQuill.setSelection(newIndex + 1);
                        }
                      },
                      'soundcloud': function() {
                        const soundcloudUrl = prompt('Paste the SoundCloud URL:\n\nExamples:\n• Full profile: https://soundcloud.com/USER\n• Specific track: https://soundcloud.com/USER/TRACK_NAME');
                        if (!soundcloudUrl || soundcloudUrl.trim() === '') return;
                        const url = soundcloudUrl.trim();
                        const embedHtml = createSoundCloudEmbed(url);
                        if (embedHtml) {
                          const range = blockQuill.getSelection(true);
                          let index = range ? range.index : blockQuill.getLength();
                          if (index > 0) {
                            const textBefore = blockQuill.getText(Math.max(0, index - 1), 1);
                            if (textBefore && textBefore !== '\n') {
                              blockQuill.insertText(index, '\n', 'user');
                              index += 1;
                            }
                          } else {
                            blockQuill.insertText(index, '\n', 'user');
                            index += 1;
                          }
                          blockQuill.insertEmbed(index, 'soundcloud', embedHtml, 'user');
                          const newIndex = index + 1;
                          blockQuill.insertText(newIndex, '\n', 'user');
                          blockQuill.setSelection(newIndex + 1);
                        }
                      }
                    }
                  }
                },
                placeholder: 'Write your text here...'
              });

              // Cargar contenido existente
              if (block.content) {
                console.log(`[Block Quill Init] Loading content for block ${index}:`, {
                  contentLength: block.content.length,
                  contentPreview: block.content.substring(0, 150)
                });
                blockQuill.root.innerHTML = block.content;
                console.log(`[Block Quill Init] ✅ Content loaded into Quill editor ${index}`);
              } else {
                console.log(`[Block Quill Init] ⚠️ Block ${index} has no content to load`);
              }

              // Actualizar bloque cuando cambia el contenido
              blockQuill.on('text-change', function() {
                const newContent = blockQuill.root.innerHTML;
                block.content = newContent;
                if (hiddenInput) {
                  hiddenInput.value = newContent;
                }
                console.log(`[Block Quill] Text changed for block ${index}, content length: ${newContent.length}`);
              });

              // Guardar referencia al editor en el bloque
              block._quillEditor = blockQuill;
            }
          }, 100);
        }

        // Gestionar slideshow
        if (blockType === "slideshow") {
          const slideshowId = `slideshow-${index}`;
          
          // Botón añadir imagen
          div.querySelector(`.add-slide-btn`)?.addEventListener("click", () => {
            if (!block.metadata) block.metadata = {};
            if (!block.metadata.images) block.metadata.images = [];
            
            block.metadata.images.push({ url: "", caption: "" });
            renderBlocks();
          });

          // Botones de gestión de imágenes
          div.querySelectorAll(".remove-slide").forEach(btn => {
            btn.addEventListener("click", (e) => {
              const imgIndex = parseInt(e.target.dataset.imgIndex);
              if (block.metadata && block.metadata.images) {
                block.metadata.images.splice(imgIndex, 1);
                renderBlocks();
              }
            });
          });

          div.querySelectorAll(".move-slide-up").forEach(btn => {
            btn.addEventListener("click", (e) => {
              const imgIndex = parseInt(e.target.dataset.imgIndex);
              if (block.metadata && block.metadata.images && imgIndex > 0) {
                [block.metadata.images[imgIndex], block.metadata.images[imgIndex - 1]] = 
                  [block.metadata.images[imgIndex - 1], block.metadata.images[imgIndex]];
                renderBlocks();
              }
            });
          });

          div.querySelectorAll(".move-slide-down").forEach(btn => {
            btn.addEventListener("click", (e) => {
              const imgIndex = parseInt(e.target.dataset.imgIndex);
              if (block.metadata && block.metadata.images && imgIndex < block.metadata.images.length - 1) {
                [block.metadata.images[imgIndex], block.metadata.images[imgIndex + 1]] = 
                  [block.metadata.images[imgIndex + 1], block.metadata.images[imgIndex]];
                renderBlocks();
              }
            });
          });

          // Actualizar URLs y captions
          div.querySelectorAll(".slideshow-image-url").forEach(input => {
            input.addEventListener("input", (e) => {
              const imgIndex = parseInt(e.target.dataset.imgIndex);
              if (block.metadata && block.metadata.images) {
                if (!block.metadata.images[imgIndex]) block.metadata.images[imgIndex] = {};
                block.metadata.images[imgIndex].url = e.target.value;
                // Actualizar preview
                const imgItem = e.target.closest(".slideshow-image-item");
                if (imgItem) {
                  const preview = imgItem.querySelector("img");
                  if (preview && e.target.value) {
                    preview.src = convertImgurUrl(e.target.value);
                    preview.style.display = "block";
                  }
                }
              }
            });
            
            // Detectar cuando se pega una URL de Imgur y abrir editor
            input.addEventListener("blur", (e) => {
              const url = e.target.value.trim();
              if (url && (url.includes("imgur.com") || url.includes("i.imgur.com"))) {
                const imgIndex = parseInt(e.target.dataset.imgIndex);
                const imageUrl = convertImgurUrl(url);
                setTimeout(() => {
                  currentBlockContext = {
                    type: 'slideshow',
                    blockIndex: index,
                    imageIndex: imgIndex,
                    block: block
                  };
                  openImageEditor(imageUrl, null);
                }, 300);
              }
            });
          });
          
          // Permitir editar imagen haciendo click en la preview
          div.querySelectorAll(".slideshow-image-item img").forEach(img => {
            img.style.cursor = "pointer";
            img.title = "Click to edit";
            img.addEventListener("click", (e) => {
              const imgItem = e.target.closest(".slideshow-image-item");
              if (imgItem) {
                const imgIndex = parseInt(imgItem.dataset.imgIndex);
                const urlInput = imgItem.querySelector(".slideshow-image-url");
                if (urlInput && urlInput.value) {
                  const imageUrl = convertImgurUrl(urlInput.value);
                  currentBlockContext = {
                    type: 'slideshow',
                    blockIndex: index,
                    imageIndex: imgIndex,
                    block: block
                  };
                  openImageEditor(imageUrl, null);
                }
              }
            });
          });
          
          // Event listener para abrir el editor de slideshow
          div.querySelector(".open-slideshow-editor-btn")?.addEventListener("click", () => {
            openSlideshowEditor(block, index);
          });

          div.querySelectorAll(".slideshow-image-caption").forEach(input => {
            input.addEventListener("input", (e) => {
              const imgIndex = parseInt(e.target.dataset.imgIndex);
              if (block.metadata && block.metadata.images) {
                if (!block.metadata.images[imgIndex]) block.metadata.images[imgIndex] = {};
                block.metadata.images[imgIndex].caption = e.target.value;
              }
            });
          });

          // Event listeners para configuración del slideshow
          div.querySelectorAll(".slideshow-config-checkbox").forEach(checkbox => {
            checkbox.addEventListener("change", (e) => {
              const configKey = e.target.dataset.config;
              if (!block.metadata) block.metadata = {};
              if (!block.metadata.slideshowConfig) block.metadata.slideshowConfig = {};
              block.metadata.slideshowConfig[configKey] = e.target.checked;
              console.log('[Slideshow Config] Updated', configKey, 'to', e.target.checked, 'in block', index);
            });
          });

          div.querySelectorAll(".slideshow-config-select").forEach(select => {
            select.addEventListener("change", (e) => {
              const configKey = e.target.dataset.config;
              if (!block.metadata) block.metadata = {};
              if (!block.metadata.slideshowConfig) block.metadata.slideshowConfig = {};
              const value = configKey === 'slideDuration' ? parseInt(e.target.value) : e.target.value;
              block.metadata.slideshowConfig[configKey] = value;
              console.log('[Slideshow Config] Updated', configKey, 'to', value, 'in block', index);
              console.log('[Slideshow Config] Full config:', block.metadata.slideshowConfig);
            });
          });
        }

        return div;
      }

      // Botón para añadir bloque
      document.getElementById("add-block-btn")?.addEventListener("click", () => {
        const postType = currentPostType;
        let blockType = "text";

        // No forzar tipo según postType, permitir elegir
        if (false) { // Deshabilitado: ya no forzamos slideshow_image
          blockType = "slideshow_image";
        } else {
          // Crear modal simple para elegir tipo de bloque
          const types = [
            { value: "text", label: "Text (Rich Editor)" },
            { value: "image", label: "Image" },
            { value: "link", label: "Link (URL)" },
            { value: "slideshow", label: "Slideshow (Multiple Images)" },
            { value: "video", label: "Video (YouTube/Vimeo)" },
            { value: "embed_instagram", label: "Instagram Embed" },
            { value: "embed_soundcloud", label: "SoundCloud Embed" },
          ];

          // Crear select temporal
          const select = document.createElement("select");
          select.style.cssText = "padding: 8px; border: 1px solid #000; font-size: 13px; width: 100%;";
          types.forEach(type => {
            const option = document.createElement("option");
            option.value = type.value;
            option.textContent = type.label;
            select.appendChild(option);
          });

          const modal = document.createElement("div");
          modal.style.cssText = "position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); display: flex; align-items: center; justify-content: center; z-index: 10000;";
          
          const modalContent = document.createElement("div");
          modalContent.style.cssText = "background: white; padding: 30px; border: 1px solid #000; max-width: 400px; width: 90%;";
          modalContent.innerHTML = `
            <h3 style="margin-top: 0; margin-bottom: 15px; font-size: 14px; text-transform: uppercase;">Select Block Type</h3>
            <div style="margin-bottom: 15px;"></div>
            <div style="display: flex; gap: 10px; justify-content: flex-end;">
              <button id="cancel-block-type" style="padding: 8px 16px; background: #fff; color: #000; border: 1px solid #000; cursor: pointer; font-size: 11px; text-transform: uppercase;">Cancel</button>
              <button id="confirm-block-type" style="padding: 8px 16px; background: #000; color: #fff; border: none; cursor: pointer; font-size: 11px; text-transform: uppercase;">Add</button>
            </div>
          `;
          
          const selectContainer = modalContent.querySelector("div");
          selectContainer.appendChild(select);
          
          modal.appendChild(modalContent);
          document.body.appendChild(modal);

          const cleanup = () => {
            document.body.removeChild(modal);
          };

          modalContent.querySelector("#cancel-block-type").addEventListener("click", cleanup);
          modalContent.querySelector("#confirm-block-type").addEventListener("click", () => {
            blockType = select.value;
            cleanup();
            
            const newBlock = {
              type: blockType,
              content: "",
              order: postBlocks.length,
              metadata: blockType === "slideshow" ? { 
                images: [], 
                width: "full",
                slideshowConfig: {
                  showArrows: true,
                  arrowStyle: 'arrows',
                  autoPlay: false,
                  slideDuration: 3,
                  imageWidth: 1200,  // Dimensiones por defecto
                  imageHeight: 800
                }
              } : { width: "full" },
            };

            postBlocks.push(newBlock);
            renderBlocks();
          });
          
          return; // Salir aquí, el bloque se añadirá en el callback
        }

        const newBlock = {
          type: blockType,
          content: "",
          order: postBlocks.length,
          metadata: blockType === "slideshow" ? { 
            images: [], 
            width: "full",
            slideshowConfig: {
              showArrows: true,
              arrowStyle: 'arrows',
              autoPlay: false,
              slideDuration: 3,
              imageWidth: 1200,  // Dimensiones por defecto
              imageHeight: 800
            }
          } : { width: "full" },
        };

        postBlocks.push(newBlock);
        renderBlocks();
      });

      // Función helper para escapar HTML
      function escapeHtml(text) {
        const div = document.createElement("div");
        div.textContent = text;
        return div.innerHTML;
      }

      // ==================== FIN GESTIÓN DE BLOQUES ====================

      // Crear/editar post
      document.getElementById("post-form").addEventListener("submit", async (e) => {
        e.preventDefault();

        console.log("[Post Save] ========== INICIO GUARDADO POST ==========");

        const id = document.getElementById("post-id").value;
        const title = document.getElementById("title").value;
        const slug = document.getElementById("slug").value;
        const postOrder = parseInt(document.getElementById("post-order")?.value || "0") || 0;
        
        if (!title) {
          showMessage("Title is required", "error");
          return;
        }

        // Obtener contenido legacy (si existe y se está usando)
        let content = "";
        if (quillEditor) {
          content = quillEditor.root.innerHTML;
          document.getElementById("content").value = content;
        }

        // Validar según el tipo de post
        if (currentPostType === 'slideshow') {
          // Para slideshow, validar que haya slides
          if (slideshowSlides.length === 0) {
            showMessage("Please add at least one slide to the slideshow", "error");
            return;
          }
        } else {
          // Para otros tipos, validar bloques o contenido legacy
          if (postBlocks.length === 0 && (!content || content.trim() === "" || content === "<p><br></p>" || content === "<p></p>")) {
            showMessage("Please add content blocks or use the legacy editor", "error");
            return;
          }
        }

        const published = document.getElementById("published").checked;

        // Obtener sección y tags seleccionados
        const sectionId = document.getElementById("section").value || null;
        const tagIds = selectedTags.map(tag => tag.id);
        
        if (!sectionId) {
          showMessage("Please select a section", "error");
          return;
        }
        
        if (!currentSiteId) {
          showMessage("No site selected. Please select a site.", "error");
          return;
        }
        
        // Obtener datos de thumbnail si la sección es de tipo "thumbnails"
        const section = sections.find(s => s.id === parseInt(sectionId));
        let thumbnailData = null;
        if (section && section.postType === "thumbnails") {
          const thumbnailImageUrl = document.getElementById("thumbnail-image-url")?.value || "";
          const thumbnailCaption = document.getElementById("thumbnail-caption")?.value || "";
          
          if (!thumbnailImageUrl) {
            showMessage("Thumbnail image URL is required for thumbnail posts", "error");
            return;
          }
          
          thumbnailData = {
            imageUrl: thumbnailImageUrl,
            description: thumbnailCaption
          };
        }
        
        // Sincronizar contenido de todos los editores Quill de bloques de texto antes de guardar
        // Buscar todos los editores Quill activos en el DOM y mapearlos a los bloques
        const allQuillEditors = document.querySelectorAll('.block-quill-editor');
        const editorMap = new Map();
        
        // Mapear cada editor Quill a su índice de bloque
        allQuillEditors.forEach((editorContainer) => {
          if (editorContainer.__quill) {
            // Extraer el índice del ID del editor (formato: quill-editor-{index})
            const match = editorContainer.id.match(/quill-editor-(\d+)/);
            if (match) {
              const blockIndex = parseInt(match[1]);
              editorMap.set(blockIndex, editorContainer.__quill);
            }
          }
        });
        
        // Sincronizar contenido de todos los bloques de texto
        postBlocks.forEach((block, index) => {
          if (block.type === "text") {
            // Intentar obtener el editor desde la referencia guardada primero
            let quillEditor = block._quillEditor;
            
            // Si no hay referencia, buscar en el mapa de editores del DOM
            if (!quillEditor) {
              quillEditor = editorMap.get(index);
            }
            
            // Si encontramos el editor, sincronizar el contenido
            if (quillEditor) {
              const newContent = quillEditor.root.innerHTML;
              const oldContent = block.content || "";
              block.content = newContent;
              console.log(`[Post Save] ✅ Synced text block ${index}:`, {
                oldLength: oldContent.length,
                newLength: newContent.length,
                changed: oldContent !== newContent,
                preview: newContent.substring(0, 150).replace(/\n/g, ' ')
              });
            } else {
              console.warn(`[Post Save] ⚠️ Text block ${index} has no Quill editor (checked both _quillEditor and DOM)`);
              // Si no hay editor pero hay contenido, mantener el contenido existente
              if (!block.content) {
                console.warn(`[Post Save] ⚠️ Text block ${index} also has no content!`);
              }
            }
          }
        });
        
        // Preparar bloques con orden correcto
        const blocks = postBlocks.map((block, index) => {
          // Asegurar que el metadata esté completo antes de guardar
          let metadata = block.metadata || {};
          // Para slideshows, asegurar que slideshowConfig esté completo con dimensiones por defecto
          if (block.type === 'slideshow') {
            if (!metadata.slideshowConfig) {
              metadata.slideshowConfig = {
                showArrows: true,
                arrowStyle: 'arrows',
                autoPlay: false,
                slideDuration: 3,
                imageWidth: 1200,
                imageHeight: 800
              };
            } else {
              // Asegurar que las dimensiones por defecto estén presentes si no existen
              if (!metadata.slideshowConfig.imageWidth) {
                metadata.slideshowConfig.imageWidth = 1200;
              }
              if (!metadata.slideshowConfig.imageHeight) {
                metadata.slideshowConfig.imageHeight = 800;
              }
            }
            // Asegurar que width esté presente
            if (!metadata.width) {
              metadata.width = 'full';
            }
          } else {
            // Para otros bloques, asegurar que width esté presente
            if (!metadata.width) {
              metadata.width = 'full';
            }
          }
          
          const blockData = {
            type: block.type,
            content: block.content || null,
            order: index,
            metadata: metadata,
          };
          console.log(`[Post Save] Block ${index}:`, JSON.stringify(blockData, null, 2));
          return blockData;
        });

        // Metadata (legacy). Para nuevo contenido usamos "slideshow como bloque".
        // No enviamos metadata salvo que haya un motivo explícito (mantener undefined preserva metadata existente en backend).
        let metadata = undefined;
        
        // El tipo se obtendrá automáticamente del backend basado en la sección
        const payload = { 
          title, 
          slug, 
          content: content || "",
          published, 
          order: postOrder,
          sectionId, 
          tagIds, 
          siteId: currentSiteId,
          // Bloques para todos los tipos (incluyendo slideshow como bloque)
          metadata: metadata,
          blocks: blocks && blocks.length > 0 ? blocks : undefined,
          // Datos de thumbnail si la sección es de tipo "thumbnails"
          thumbnailData: thumbnailData || undefined
        };
        console.log("[Post Save] Full payload:", {
          title: title,
          slug: slug || "auto",
          contentLength: content.length,
          contentFull: content, // Mostrar el contenido completo
          published: published,
          tagIds: tagIds,
          payloadJSON: JSON.stringify(payload)
        });

        try {
          const url = id ? `${API_URL}/posts/${id}` : `${API_URL}/posts`;
          const method = id ? "PUT" : "POST";

          console.log("[Post Save] Sending request:", {
            url: url,
            method: method,
            payloadSize: JSON.stringify(payload).length
          });

          const res = await fetch(url, {
            method,
            headers: { "Content-Type": "application/json" },
            credentials: "include",
            body: JSON.stringify(payload),
          });
          
          console.log("[Post Save] Response received:", {
            status: res.status,
            statusText: res.statusText,
            ok: res.ok,
            headers: Object.fromEntries(res.headers.entries())
          });

          if (res.status === 401) {
            console.error("[Post Save] ERROR: No autorizado (401)");
            window.location.href = "login.html";
            return;
          }

          if (!res.ok) {
            let error;
            try {
              error = await res.json();
            } catch (e) {
              const text = await res.text();
              error = { error: text || "Unknown error", raw: text };
            }
            const errorMessage = error.error || error.message || "Failed to save post";
            console.error("[Post Save] ERROR in response:", {
              status: res.status,
              statusText: res.statusText,
              error: error,
              errorMessage: errorMessage,
              fullError: JSON.stringify(error, null, 2)
            });
            // Mostrar el error completo en la consola para debugging
            console.error("[Post Save] Error completo del servidor:", error);
            throw new Error(errorMessage);
          }

          const post = await res.json();
          console.log("[Post Save] ✅ Post saved successfully:", {
            id: post.id,
            title: post.title,
            slug: post.slug,
            contentLength: post.content ? post.content.length : 0
          });

          showMessage(
            id ? "Post updated successfully" : "Post created successfully",
            "success"
          );
          resetForm();
          loadPosts();
        } catch (err) {
          console.error("[Post Save] ERROR in catch:", {
            message: err.message,
            stack: err.stack,
            name: err.name
          });
          showMessage(`Error: ${err.message}`, "error");
        }

        console.log("[Post Save] ========== FIN GUARDADO POST ==========");
      });

      // Renderizar paginación
      function renderPagination(pagination) {
        if (!pagination || pagination.totalPages <= 1) {
          document.getElementById("pagination").innerHTML = "";
          return;
        }
        
        const container = document.getElementById("pagination");
        let html = "";
        
        // Botón anterior
        if (pagination.page > 1) {
          html += `<button onclick="loadPosts(${pagination.page - 1})" style="padding: 10px 20px; background: #000000; color: #ffffff; border: 1px solid #000000; border-radius: 0; cursor: pointer; font-size: 11px; text-transform: uppercase; letter-spacing: 0.5px; transition: all 0.2s ease;" onmouseover="this.style.background='#ffffff'; this.style.color='#000000';" onmouseout="this.style.background='#000000'; this.style.color='#ffffff';">Previous</button>`;
        }
        
        // Números de página
        const maxPages = 5;
        let startPage = Math.max(1, pagination.page - Math.floor(maxPages / 2));
        let endPage = Math.min(pagination.totalPages, startPage + maxPages - 1);
        
        if (endPage - startPage < maxPages - 1) {
          startPage = Math.max(1, endPage - maxPages + 1);
        }
        
        if (startPage > 1) {
          html += `<button onclick="loadPosts(1)" style="padding: 10px 15px; background: #ffffff; color: #000000; border: 1px solid #000000; border-radius: 0; cursor: pointer; font-size: 11px; transition: all 0.2s ease;" onmouseover="this.style.background='#000000'; this.style.color='#ffffff';" onmouseout="this.style.background='#ffffff'; this.style.color='#000000';">1</button>`;
          if (startPage > 2) {
            html += `<span style="padding: 10px; color: #666666;">...</span>`;
          }
        }
        
        for (let i = startPage; i <= endPage; i++) {
          if (i === pagination.page) {
            html += `<button style="padding: 10px 15px; background: #000000; color: #ffffff; border: 1px solid #000000; border-radius: 0; cursor: pointer; font-size: 11px; font-weight: 400;">${i}</button>`;
          } else {
            html += `<button onclick="loadPosts(${i})" style="padding: 10px 15px; background: #ffffff; color: #000000; border: 1px solid #000000; border-radius: 0; cursor: pointer; font-size: 11px; transition: all 0.2s ease;" onmouseover="this.style.background='#000000'; this.style.color='#ffffff';" onmouseout="this.style.background='#ffffff'; this.style.color='#000000';">${i}</button>`;
          }
        }
        
        if (endPage < pagination.totalPages) {
          if (endPage < pagination.totalPages - 1) {
            html += `<span style="padding: 10px; color: #666666;">...</span>`;
          }
          html += `<button onclick="loadPosts(${pagination.totalPages})" style="padding: 10px 15px; background: #ffffff; color: #000000; border: 1px solid #000000; border-radius: 0; cursor: pointer; font-size: 11px; transition: all 0.2s ease;" onmouseover="this.style.background='#000000'; this.style.color='#ffffff';" onmouseout="this.style.background='#ffffff'; this.style.color='#000000';">${pagination.totalPages}</button>`;
        }
        
        // Botón siguiente
        if (pagination.page < pagination.totalPages) {
          html += `<button onclick="loadPosts(${pagination.page + 1})" style="padding: 10px 20px; background: #000000; color: #ffffff; border: 1px solid #000000; border-radius: 0; cursor: pointer; font-size: 11px; text-transform: uppercase; letter-spacing: 0.5px; transition: all 0.2s ease;" onmouseover="this.style.background='#ffffff'; this.style.color='#000000';" onmouseout="this.style.background='#000000'; this.style.color='#ffffff';">Next</button>`;
        }
        
        html += `<span style="margin-left: 20px; color: #666666; font-size: 11px; text-transform: uppercase; letter-spacing: 0.5px;">Page ${pagination.page} of ${pagination.totalPages} (${pagination.total} posts)</span>`;
        
        container.innerHTML = html;
      }

      // Editar post
      async function editPost(id) {
        if (!currentSiteId) {
          showMessage("No site selected. Please select a site.", "error");
          return;
        }
        
        try {
          // Agregar timestamp para evitar caché cuando se edita un post
          const params = new URLSearchParams({ 
            page: "1", 
            limit: "1000", 
            siteId: currentSiteId.toString(),
            _t: Date.now().toString() // Cache busting
          });
          const res = await authFetch(`${API_URL}/posts/all?${params.toString()}`, {
            credentials: "include",
            cache: "no-store" // Forzar no usar caché del navegador
          });
          
          if (res.status === 401) {
            window.location.href = "login.html";
            return;
          }
          
          if (!res.ok) throw new Error("Failed to load posts");
          const data = await res.json();
          const posts = data.posts || data;
          const post = posts.find((p) => p.id === id);

          if (!post) {
            showMessage("Post not found", "error");
            return;
          }

          editingPostId = id;
          document.getElementById("post-id").value = id;
          document.getElementById("title").value = post.title;
          document.getElementById("slug").value = post.slug;
          document.getElementById("post-order").value = post.order ?? 0;
          
          // Cargar sección
          document.getElementById("section").value = post.sectionId || "";
          
          // Actualizar info de tipo de sección (esto también actualiza el tipo de post)
          updateSectionTypeInfo();
          
          // Si el post es de tipo "thumbnails", cargar datos del thumbnail
          if (post.type === 'thumbnails' || (post.section && post.section.postType === 'thumbnails')) {
            try {
              const sectionId = post.sectionId;
              if (sectionId) {
                const thumbRes = await fetch(`${API_URL}/thumbnails?sectionId=${sectionId}`, {
                  credentials: "include"
                });
                if (thumbRes.ok) {
                  const thumbnails = await thumbRes.json();
                  // Buscar el thumbnail que tiene este post como detailPost
                  const thumbnail = thumbnails.find(t => t.detailPostId === id);
                  if (thumbnail) {
                    // Cargar datos del thumbnail en los campos del formulario
                    const thumbnailImageUrlInput = document.getElementById("thumbnail-image-url");
                    const thumbnailCaptionInput = document.getElementById("thumbnail-caption");
                    if (thumbnailImageUrlInput) {
                      thumbnailImageUrlInput.value = thumbnail.imageUrl || "";
                      // Actualizar preview
                      const preview = document.getElementById("thumbnail-image-preview");
                      if (preview && thumbnail.imageUrl) {
                        const img = preview.querySelector("img");
                        if (img) {
                          img.src = convertImgurUrl(thumbnail.imageUrl);
                          img.style.display = "block";
                        } else {
                          preview.innerHTML = `<img src="${convertImgurUrl(thumbnail.imageUrl)}" style="max-width: 100%; max-height: 100%; object-fit: contain;" />`;
                        }
                      }
                    }
                    if (thumbnailCaptionInput) {
                      thumbnailCaptionInput.value = thumbnail.description || "";
                    }
                  }
                }
              }
            } catch (err) {
              console.error("Error loading thumbnail data:", err);
              // No fallar si no se puede cargar el thumbnail
            }
          }
          
          // Migración suave: si el post es legacy type=slideshow (sin blocks) convertir a "slideshow como bloque" para edición.
          const isLegacySlideshowPost =
            post.type === 'slideshow' &&
            (!post.blocks || post.blocks.length === 0) &&
            post.metadata &&
            Array.isArray(post.metadata.slides);
          if (isLegacySlideshowPost) {
            console.log("[Slideshow Migration] Legacy slideshow post detected. Converting metadata.slides -> block(slideshow).");
          }
          
          // Cargar tags
          selectedTags = post.tags || [];
          renderSelectedTags();
          
          // Si es un slideshow legacy, NO usar el modo "post type slideshow". Se edita como bloque.
          if (isLegacySlideshowPost) {
            const md = post.metadata;
            const slides = Array.isArray(md.slides) ? md.slides : [];

            const normalizeDurationSeconds = (interval) => {
              if (typeof interval !== "number" || !isFinite(interval) || interval <= 0) return 3;
              // Heurística: si parece ms, convertir a segundos
              return interval > 50 ? Math.max(1, Math.round(interval / 1000)) : Math.max(1, Math.round(interval));
            };

            const slideshowBlock = {
              type: "slideshow",
              content: "",
              order: 0,
              metadata: {
                width: "full",
                images: slides.map((s) => ({
                  url: s.imageUrl || s.url || "",
                  caption: s.caption || "",
                })),
                slideshowConfig: {
                  showArrows: true,
                  arrowStyle: "arrows",
                  autoPlay: Boolean(md.autoplay),
                  slideDuration: normalizeDurationSeconds(md.interval),
                  imageWidth: 1200,
                  imageHeight: 800,
                },
              },
            };

            postBlocks = [slideshowBlock];
            slideshowSlides = [];
            renderBlocks();
          } else {
            slideshowSlides = [];
          }
          
          // Cargar bloques (preservar todo el metadata completo)
          // Si ya migramos legacy slideshow -> block, no sobrescribir.
          if (!isLegacySlideshowPost) {
          postBlocks = (post.blocks || []).map(block => {
            // Preservar metadata completo, solo añadir width si no existe
            const metadata = block.metadata ? { ...block.metadata } : {};
            if (!metadata.width) {
              metadata.width = "full";
            }
            // Para slideshows, asegurar que slideshowConfig existe con dimensiones por defecto
            if (block.type === 'slideshow') {
              if (!metadata.slideshowConfig) {
                metadata.slideshowConfig = {
                  showArrows: true,
                  arrowStyle: 'arrows',
                  autoPlay: false,
                  slideDuration: 3,
                  imageWidth: 1200,
                  imageHeight: 800
                };
              } else {
                // Asegurar que las dimensiones por defecto estén presentes si no existen
                if (!metadata.slideshowConfig.imageWidth) {
                  metadata.slideshowConfig.imageWidth = 1200;
                }
                if (!metadata.slideshowConfig.imageHeight) {
                  metadata.slideshowConfig.imageHeight = 800;
                }
              }
            }
            const blockData = {
              type: block.type,
              content: block.content,
              order: block.order,
              metadata: metadata
            };
            console.log(`[Edit Post] Loading block ${block.order} (${block.type}):`, {
              contentLength: block.content?.length || 0,
              contentPreview: block.content?.substring(0, 100) || "(empty)"
            });
            return blockData;
          });
          console.log(`[Edit Post] Total blocks loaded: ${postBlocks.length}`);
          renderBlocks();
          }
          
          // Cargar contenido HTML en el editor Quill (legacy, solo si no hay bloques)
          if (quillEditor) {
            if (postBlocks.length === 0 && post.content) {
              quillEditor.root.innerHTML = post.content || '';
              document.getElementById("content").value = post.content || '';
              document.getElementById("legacy-editor-container").style.display = "block";
            } else {
              document.getElementById("legacy-editor-container").style.display = "none";
            }
          }
          
          document.getElementById("published").checked = post.published;
          document.getElementById("form-title").textContent = "Edit Post";
          document.getElementById("submit-btn").textContent = "Update";
          document.getElementById("cancel-btn").style.display = "block";

          // Scroll al formulario de edición
          const formContainer = document.getElementById("post-form-container");
          if (formContainer) {
            formContainer.scrollIntoView({ behavior: "smooth", block: "start" });
          }
        } catch (err) {
          showMessage(`Error: ${err.message}`, "error");
        }
      }

      // Eliminar post
      async function deletePost(id) {
        if (!confirm("Are you sure you want to delete this post?")) {
          return;
        }

        if (!currentSiteId) {
          showMessage("No site selected. Please select a site.", "error");
          return;
        }

        try {
          const res = await fetch(`${API_URL}/posts/${id}?siteId=${currentSiteId}`, {
            method: "DELETE",
            credentials: "include",
          });
          
          if (res.status === 401) {
            window.location.href = "login.html";
            return;
          }

          if (!res.ok) {
            const error = await res.json();
            throw new Error(error.error || "Failed to delete post");
          }

          showMessage("Post deleted successfully", "success");
          loadPosts();
        } catch (err) {
          showMessage(`Error: ${err.message}`, "error");
        }
      }

      // Renderizar tags seleccionados
      function renderSelectedTags() {
        const container = document.getElementById("tags-container");
        container.innerHTML = selectedTags.map(tag => 
          `<span style="display: inline-flex; align-items: center; gap: 8px; padding: 6px 12px; background: #ffffff; color: #000000; border: 1px solid #000000; border-radius: 0; font-size: 11px; text-transform: uppercase; letter-spacing: 0.5px; cursor: pointer; transition: all 0.2s ease;" onclick="removeTag(${tag.id})" onmouseover="this.style.background='#000000'; this.style.color='#ffffff';" onmouseout="this.style.background='#ffffff'; this.style.color='#000000';">
            ${escapeHtml(tag.name)} ×
          </span>`
        ).join("");
      }

      // Añadir tag
      function addTag() {
        const input = document.getElementById("tag-input");
        const tagName = input.value.trim();
        
        if (!tagName) return;
        
        // Buscar si el tag ya existe
        let tag = tags.find(t => t.name.toLowerCase() === tagName.toLowerCase());
        
        if (!tag) {
          if (!currentSiteId) {
            showMessage("No site selected. Please select a site.", "error");
            return;
          }
          
          // Crear nuevo tag
          fetch(`${API_URL}/tags`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            credentials: "include",
            body: JSON.stringify({ name: tagName, siteId: currentSiteId }),
          })
          .then(res => res.json())
          .then(newTag => {
            tags.push(newTag);
            selectedTags.push(newTag);
            renderSelectedTags();
            input.value = "";
            // Actualizar select de filtros
            const filterTagSelect = document.getElementById("filter-tag");
            const option = document.createElement("option");
            option.value = newTag.id;
            option.textContent = newTag.name;
            filterTagSelect.appendChild(option);
          })
          .catch(err => {
            console.error("Error creating tag:", err);
            showMessage("Error creating tag", "error");
          });
        } else {
          // Tag ya existe, añadirlo si no está ya seleccionado
          if (!selectedTags.find(t => t.id === tag.id)) {
            selectedTags.push(tag);
            renderSelectedTags();
          }
          input.value = "";
        }
      }

      // Eliminar tag
      function removeTag(tagId) {
        selectedTags = selectedTags.filter(t => t.id !== tagId);
        renderSelectedTags();
      }

      // Resetear formulario
      function resetForm() {
        console.log("[Reset Form] Resetting form...");
        editingPostId = null;
        document.getElementById("post-form").reset();
        document.getElementById("post-id").value = "";
        document.getElementById("section").value = "";
        const orderEl = document.getElementById("post-order");
        if (orderEl) orderEl.value = 0;
        selectedTags = [];
        renderSelectedTags();
        updateSectionTypeInfo();
        // Limpiar el editor Quill
        if (quillEditor) {
          quillEditor.setContents([]);
          quillEditor.setText('');
        }
        document.getElementById("content").value = '';
        // Limpiar slideshow
        slideshowSlides = [];
        if (currentPostType === 'slideshow') {
          renderSlideshowSlides();
          updateSlideshowPreview();
        }
        // Limpiar bloques
        postBlocks = [];
        console.log("[Reset Form] postBlocks cleared, length:", postBlocks.length);
        renderBlocks();
        document.getElementById("form-title").textContent = "Create New Post";
        document.getElementById("submit-btn").textContent = "Save";
        document.getElementById("cancel-btn").style.display = "none";
        // Remover required del campo thumbnail cuando se resetea el formulario
        const thumbnailImageUrlInput = document.getElementById("thumbnail-image-url");
        if (thumbnailImageUrlInput) thumbnailImageUrlInput.removeAttribute("required");
      }

      // Botón cancelar
      document.getElementById("cancel-btn").addEventListener("click", resetForm);

      // Función para renderizar bloques en el preview
      function renderBlocksForPreview(blocks) {
        if (!blocks || blocks.length === 0) {
          return '';
        }

        let html = '<div class="preview-blocks-container">';
        let currentRow = [];
        let currentRowWidth = 0;

        blocks.forEach((block, index) => {
          const width = (block.metadata && block.metadata.width) || 'full';
          let blockWidth = 1; // full width = 1

          if (width === 'half') blockWidth = 0.5;
          else if (width === 'third') blockWidth = 0.333;
          else if (width === 'two-thirds') blockWidth = 0.666;

          // Si el bloque es full width o la fila actual + este bloque > 1, cerrar la fila anterior
          if (width === 'full' || (currentRowWidth + blockWidth > 1 && currentRow.length > 0)) {
            if (currentRow.length > 0) {
              html += '<div class="preview-blocks-row">';
              currentRow.forEach(blockHtml => {
                html += blockHtml;
              });
              html += '</div>';
              currentRow = [];
              currentRowWidth = 0;
            }
          }

          // Renderizar el bloque según su tipo
          let blockHtml = '';
          if (block.type === 'text') {
            blockHtml = `<div class="preview-block-item" data-width="${width}">${block.content || ''}</div>`;
          } else if (block.type === 'image') {
            const caption = (block.metadata && block.metadata.caption) ? `<p style="font-size: 12px; color: #666; margin-top: 8px; font-style: italic;">${escapeHtml(block.metadata.caption)}</p>` : '';
            const imgHtml = block.content ? createImageWithFallback(block.content, '', 'max-width: 100%; height: auto; border-radius: 0; margin: 0; border: 1px solid #000000;') : '';
            blockHtml = `<div class="preview-block-item" data-width="${width}">${imgHtml}${caption}</div>`;
          } else if (block.type === 'video') {
            let videoHtml = '';
            if (block.content) {
              const youtubeId = extractYouTubeId(block.content);
              const vimeoId = extractVimeoId(block.content);
              if (youtubeId) {
                videoHtml = createYouTubeEmbed(youtubeId, block.content);
              } else if (vimeoId) {
                videoHtml = createVimeoEmbed(vimeoId, block.content);
              }
            }
            blockHtml = `<div class="preview-block-item" data-width="${width}">${videoHtml}</div>`;
          } else if (block.type === 'slideshow') {
            const images = (block.metadata && block.metadata.images) || [];
            const config = (block.metadata && block.metadata.slideshowConfig) || {};
            const showArrows = config.showArrows !== undefined ? config.showArrows : true;
            const arrowStyle = config.arrowStyle || 'arrows';
            const autoPlay = config.autoPlay !== undefined ? config.autoPlay : false;
            const slideDuration = config.slideDuration || 3;
            
            const slideshowId = `preview-slideshow-${Date.now()}-${index}`;
            
            // Crear HTML del slideshow
            let slideshowHtml = `<div class="slideshow-wrapper" id="${slideshowId}" data-auto-play="${autoPlay}" data-slide-duration="${slideDuration * 1000}">`;
            slideshowHtml += '<div class="slideshow-container">';
            
            images.forEach((img, imgIndex) => {
              const imgHtml = img.url ? createImageWithFallback(img.url, '', 'max-width: 100%; height: auto; border-radius: 0; margin: 0; border: 1px solid #000000;') : '';
              const caption = img.caption ? `<div class="slideshow-caption">${escapeHtml(img.caption)}</div>` : '';
              const activeClass = imgIndex === 0 ? 'active' : '';
              slideshowHtml += `<div class="slideshow-slide ${activeClass}" data-slide-index="${imgIndex}">${imgHtml}${caption}</div>`;
            });
            
            slideshowHtml += '</div>';
            
            // Añadir flechas de navegación si está habilitado
            if (showArrows && images.length > 1) {
              const arrowSymbols = {
                'arrows': { left: '←', right: '→' },
                'chevrons': { left: '‹', right: '›' },
                'circles': { left: '◯', right: '◯' },
                'triangles': { left: '◀', right: '▶' }
              };
              const arrows = arrowSymbols[arrowStyle] || arrowSymbols['arrows'];
              slideshowHtml += `<button class="slideshow-arrow slideshow-prev" aria-label="Previous">${arrows.left}</button>`;
              slideshowHtml += `<button class="slideshow-arrow slideshow-next" aria-label="Next">${arrows.right}</button>`;
            }
            
            // Indicadores de slide
            if (images.length > 1) {
              slideshowHtml += '<div class="slideshow-indicators">';
              images.forEach((img, imgIndex) => {
                const activeClass = imgIndex === 0 ? 'active' : '';
                slideshowHtml += `<button class="slideshow-indicator ${activeClass}" data-slide-index="${imgIndex}" aria-label="Go to slide ${imgIndex + 1}"></button>`;
              });
              slideshowHtml += '</div>';
            }
            
            slideshowHtml += '</div>';
            blockHtml = `<div class="preview-block-item" data-width="${width}">${slideshowHtml}</div>`;
          } else if (block.type === 'link') {
            const href = String(block.content || '').trim();
            const safeHref = escapeHtml(href);
            const linkHtml = href
              ? `<a href="${safeHref}" target="_blank" rel="noopener noreferrer">${safeHref}</a>`
              : '';
            blockHtml = `<div class="preview-block-item" data-width="${width}">${linkHtml}</div>`;
          } else if (block.type === 'embed_instagram' || block.type === 'embed_soundcloud') {
            blockHtml = `<div class="preview-block-item" data-width="${width}">${block.content || ''}</div>`;
          } else {
            // Tipo desconocido, renderizar como HTML
            blockHtml = `<div class="preview-block-item" data-width="${width}">${block.content || ''}</div>`;
          }

          if (width === 'full') {
            html += blockHtml;
          } else {
            currentRow.push(blockHtml);
            currentRowWidth += blockWidth;
          }
        });

        // Cerrar la última fila si hay bloques pendientes
        if (currentRow.length > 0) {
          html += '<div class="preview-blocks-row">';
          currentRow.forEach(blockHtml => {
            html += blockHtml;
          });
          html += '</div>';
        }

        html += '</div>';
        return html;
      }

      // Función para mostrar preview
      function showPreview() {
        const title = document.getElementById("title").value;
        const content = quillEditor ? quillEditor.root.innerHTML : document.getElementById("content").value;

        // Validar que haya contenido
        const hasBlocks = postBlocks && postBlocks.length > 0;
        const hasContent = content && content.trim() !== '' && content !== '<p><br></p>' && content !== '<p></p>';
        
        if (!title && !hasBlocks && !hasContent) {
          showMessage("Please add a title or content to preview", "error");
          return;
        }

        // Construir HTML del preview
        let previewHtml = "";

        // Título
        if (title) {
          previewHtml += `<div class="preview-post-title">${escapeHtml(title)}</div>`;
        }

        // Contenido: bloques o contenido legacy
        if (hasBlocks) {
          previewHtml += renderBlocksForPreview(postBlocks);
        } else if (hasContent) {
          previewHtml += `<div class="preview-post-content">${content}</div>`;
        }

        // Insertar en el modal
        document.getElementById("preview-post").innerHTML = previewHtml;

        // Inicializar slideshows en el preview
        setTimeout(() => {
          initPreviewSlideshows();
        }, 100);

        // Mostrar modal
        document.getElementById("preview-modal").classList.add("show");
      }

      // Función para inicializar slideshows en el preview
      function initPreviewSlideshows() {
        const slideshows = document.querySelectorAll('#preview-post .slideshow-wrapper');
        slideshows.forEach(slideshow => {
          const slides = slideshow.querySelectorAll('.slideshow-slide');
          if (slides.length <= 1) return;
          
          let currentIndex = 0;
          const autoPlay = slideshow.dataset.autoPlay === 'true';
          const slideDuration = parseInt(slideshow.dataset.slideDuration) || 3000;
          let autoPlayInterval = null;
          
          function showSlide(index) {
            slides.forEach((slide, i) => {
              slide.classList.remove('active');
              if (i === index) slide.classList.add('active');
            });
            const indicators = slideshow.querySelectorAll('.slideshow-indicator');
            indicators.forEach((indicator, i) => {
              indicator.classList.remove('active');
              if (i === index) indicator.classList.add('active');
            });
            currentIndex = index;
          }
          
          function nextSlide() {
            showSlide((currentIndex + 1) % slides.length);
          }
          
          function prevSlide() {
            showSlide((currentIndex - 1 + slides.length) % slides.length);
          }
          
          const prevBtn = slideshow.querySelector('.slideshow-prev');
          const nextBtn = slideshow.querySelector('.slideshow-next');
          
          if (prevBtn) prevBtn.addEventListener('click', () => { prevSlide(); resetAutoPlay(); });
          if (nextBtn) nextBtn.addEventListener('click', () => { nextSlide(); resetAutoPlay(); });
          
          const indicators = slideshow.querySelectorAll('.slideshow-indicator');
          indicators.forEach((indicator, index) => {
            indicator.addEventListener('click', () => { showSlide(index); resetAutoPlay(); });
          });
          
          function resetAutoPlay() {
            if (autoPlayInterval) clearInterval(autoPlayInterval);
            if (autoPlay) startAutoPlay();
          }
          
          function startAutoPlay() {
            if (autoPlay && slides.length > 1) {
              autoPlayInterval = setInterval(nextSlide, slideDuration);
            }
          }
          
          if (autoPlay) startAutoPlay();
          
          slideshow.addEventListener('mouseenter', () => {
            if (autoPlayInterval) clearInterval(autoPlayInterval);
          });
          slideshow.addEventListener('mouseleave', () => {
            if (autoPlay) startAutoPlay();
          });
        });
      }

      // Event listeners para preview (asegurar que el DOM esté listo)
      function initPreviewListeners() {
        const previewBtn = document.getElementById("preview-btn");
        const previewCloseBtn = document.getElementById("preview-close-btn");
        const previewModal = document.getElementById("preview-modal");

        if (previewBtn) {
          previewBtn.addEventListener("click", function(e) {
            e.preventDefault();
            showPreview();
          });
        } else {
          console.error("Preview button not found");
        }

        if (previewCloseBtn) {
          previewCloseBtn.addEventListener("click", function() {
            if (previewModal) {
              previewModal.classList.remove("show");
            }
          });
        }

        if (previewModal) {
          // Cerrar modal al hacer click fuera
          previewModal.addEventListener("click", function(e) {
            if (e.target === this) {
              this.classList.remove("show");
            }
          });
        }

        // Cerrar modal con ESC
        document.addEventListener("keydown", function(e) {
          if (e.key === "Escape" && previewModal) {
            previewModal.classList.remove("show");
          }
        });
      }

      // Inicializar listeners cuando el DOM esté listo
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initPreviewListeners);
      } else {
        initPreviewListeners();
      }

      // Variables para el editor de imágenes
      let imageCropper = null;
      let currentImageIndex = null;
      let currentImageUrl = null;
      let currentImageElement = null; // Guardar referencia al elemento img

      // Variables para el editor de imágenes con contexto de bloque
      let currentBlockContext = null; // { type: 'image'|'slideshow', blockIndex, imageIndex? }

      // Variables para el editor de slideshow
      let currentSlideshowBlock = null;
      let currentSlideshowBlockIndex = null;
      let slideshowImageCroppers = {}; // { imageIndex: cropperInstance }
      
      function openImageEditor(imageUrl, imageIndex, quillInstance) {
        currentImageUrl = imageUrl;
        currentImageIndex = imageIndex;
        currentBlockContext = null;
        
        // Si se pasa una instancia de Quill, usarla en lugar del editor principal
        const editor = quillInstance || quillEditor;
        
        // Buscar el elemento img en el editor si no tenemos el índice
        if (!currentImageElement && editor) {
          const images = editor.root.querySelectorAll('img');
          for (let img of images) {
            if (img.src === imageUrl || img.src.includes(imageUrl.split('/').pop())) {
              currentImageElement = img;
              break;
            }
          }
        }
        
        const img = document.getElementById('image-editor-img');
        const modal = document.getElementById('image-editor-modal');
        
        if (!img || !modal) {
          console.error('Image editor elements not found');
          return;
        }
        
        // Limpiar cropper anterior si existe
        if (imageCropper) {
          imageCropper.destroy();
          imageCropper = null;
        }
        
        // Resetear la imagen
        img.src = '';
        
        // Cargar la imagen
        img.src = imageUrl;
        
        img.onload = function() {
          // Mostrar modal
          modal.classList.add('show');
          
          // Esperar un momento para que el modal se renderice
          setTimeout(function() {
            // Inicializar Cropper.js
            if (imageCropper) {
              imageCropper.destroy();
            }
            
            imageCropper = new Cropper(img, {
              aspectRatio: NaN, // Permite cualquier proporción
              viewMode: 1,
              dragMode: 'move',
              autoCropArea: 0.8,
              restore: false,
              guides: true,
              center: true,
              highlight: false,
              cropBoxMovable: true,
              cropBoxResizable: true,
              toggleable: true,
              minCropBoxWidth: 50,
              minCropBoxHeight: 50,
            });
          }, 100);
        };
        
        img.onerror = function() {
          alert('Error loading image. Please check the URL.');
          modal.classList.remove('show');
        };
      }

      // Función para cerrar el editor de imágenes
      function closeImageEditor() {
        const modal = document.getElementById('image-editor-modal');
        modal.classList.remove('show');
        
        if (imageCropper) {
          imageCropper.destroy();
          imageCropper = null;
        }
        
        currentImageIndex = null;
        currentImageUrl = null;
        currentImageElement = null;
      }

      // Función para aplicar el recorte y reemplazar la imagen en el editor
      function applyImageEdit() {
        if (!imageCropper || !currentImageUrl) {
          console.error('[Image Edit] Missing cropper or image URL');
          return;
        }
        
        console.log('[Image Edit] Starting image replacement. Original URL:', currentImageUrl);
        
        // Obtener el canvas recortado
        const canvas = imageCropper.getCroppedCanvas({
          imageSmoothingEnabled: true,
          imageSmoothingQuality: 'high',
        });
        
        if (!canvas) {
          alert('Error creating cropped image');
          return;
        }
        
        // Convertir canvas a base64 (usar JPEG para menor tamaño)
        const croppedImageUrl = canvas.toDataURL('image/jpeg', 0.9);
        console.log('[Image Edit] Cropped image created. Base64 length:', croppedImageUrl.length);
        
        // Reemplazar la imagen en el editor Quill, bloque, slideshow-post o thumbnail
        if (currentBlockContext) {
          // Si es thumbnail, actualizar el campo de URL en el modal o en el formulario
          if (currentBlockContext.type === 'thumbnail') {
            if (currentBlockContext.field === 'thumbnail-image-url') {
              // Es el campo de thumbnail en el formulario de posts
              const imageUrlInput = document.getElementById('thumbnail-image-url');
              if (imageUrlInput) {
                imageUrlInput.value = croppedImageUrl;
                // Actualizar preview
                const preview = document.getElementById('thumbnail-image-preview');
                if (preview) {
                  const img = preview.querySelector("img");
                  if (img) {
                    img.src = croppedImageUrl;
                    img.style.display = "block";
                  } else {
                    preview.innerHTML = `<img src="${croppedImageUrl}" style="max-width: 100%; max-height: 100%; object-fit: contain;" />`;
                  }
                }
              }
            } else {
              // Es el modal de edición de thumbnail
              const imageUrlInput = document.getElementById('thumbnail-editor-image-url');
              if (imageUrlInput) {
                imageUrlInput.value = croppedImageUrl;
                updateThumbnailImagePreview(croppedImageUrl);
              }
            }
            // Cerrar el editor de imágenes
            closeImageEditor();
          }
          // Si es slideshow-post, actualizar el slide
          else if (currentBlockContext.type === 'slideshow-post' && currentBlockContext.slideIndex !== undefined) {
            const slideIndex = currentBlockContext.slideIndex;
            if (slideshowSlides[slideIndex]) {
              slideshowSlides[slideIndex].imageUrl = croppedImageUrl;
              renderSlideshowSlides();
              updateSlideshowPreview();
            }
          } else {
            // Actualizar imagen en el bloque
            const block = currentBlockContext.block;
            const blockIndex = currentBlockContext.blockIndex;
            
            if (block.type === 'image') {
              // Actualizar URL de la imagen en el bloque
              block.content = croppedImageUrl;
              // Actualizar preview
              const blockElement = document.querySelector(`.block-item[data-index="${blockIndex}"]`);
              if (blockElement) {
                const preview = blockElement.querySelector('.block-image-preview');
                const input = blockElement.querySelector('.block-image-url-input');
                if (preview) preview.src = croppedImageUrl;
                if (input) input.value = croppedImageUrl;
              }
            } else if (block.type === 'slideshow' && currentBlockContext.imageIndex !== undefined) {
              // Actualizar imagen en el slideshow
              if (!block.metadata) block.metadata = {};
              if (!block.metadata.images) block.metadata.images = [];
              if (!block.metadata.images[currentBlockContext.imageIndex]) {
                block.metadata.images[currentBlockContext.imageIndex] = {};
              }
              block.metadata.images[currentBlockContext.imageIndex].url = croppedImageUrl;
              // Actualizar preview
              renderBlocks();
            }
          }
        } else if (quillEditor) {
          let found = false;
          
          // Método 1: Si tenemos el elemento img directamente, reemplazarlo
          if (currentImageElement && currentImageElement.parentNode) {
            console.log('[Image Edit] Method 1: Replacing via element reference');
            currentImageElement.src = croppedImageUrl;
            found = true;
          }
          
          // Método 2: Buscar en el contenido de Quill usando el índice
          if (!found && currentImageIndex !== null) {
            try {
              console.log('[Image Edit] Method 2: Trying to replace by index:', currentImageIndex);
              const op = quillEditor.getContents(currentImageIndex, 1);
              if (op.ops && op.ops[0] && op.ops[0].insert && typeof op.ops[0].insert === 'object' && op.ops[0].insert.image) {
                quillEditor.deleteText(currentImageIndex, 1);
                quillEditor.insertEmbed(currentImageIndex, 'image', croppedImageUrl, 'user');
                found = true;
                console.log('[Image Edit] Method 2: Success');
              }
            } catch (e) {
              console.warn('[Image Edit] Method 2 failed:', e);
            }
          }
          
          // Método 3: Buscar en todo el contenido de Quill
          if (!found) {
            console.log('[Image Edit] Method 3: Searching in Quill contents');
            const contents = quillEditor.getContents();
            for (let i = 0; i < contents.length(); i++) {
              const op = quillEditor.getContents(i, 1);
              if (op.ops && op.ops[0] && op.ops[0].insert && typeof op.ops[0].insert === 'object' && op.ops[0].insert.image) {
                const storedImgUrl = op.ops[0].insert.image;
                // Comparar URLs (pueden tener parámetros diferentes o ser base64)
                if (storedImgUrl === currentImageUrl || 
                    storedImgUrl.includes(currentImageUrl.split('/').pop()) || 
                    currentImageUrl.includes(storedImgUrl.split('/').pop())) {
                  // Reemplazar esta imagen
                  console.log('[Image Edit] Method 3: Found image at index', i, 'Replacing...');
                  quillEditor.deleteText(i, 1);
                  quillEditor.insertEmbed(i, 'image', croppedImageUrl, 'user');
                  found = true;
                  break;
                }
              }
            }
          }
          
          // Método 4: Buscar y reemplazar en el HTML directamente
          if (!found) {
            console.log('[Image Edit] Method 4: Searching in HTML');
            const html = quillEditor.root.innerHTML;
            console.log('[Image Edit] Current HTML length:', html.length);
            console.log('[Image Edit] Looking for URL:', currentImageUrl);
            
            // Escapar la URL para regex
            const escapedUrl = currentImageUrl.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            if (html.includes(currentImageUrl)) {
              console.log('[Image Edit] Method 4: Found exact URL match, replacing...');
              const newHtml = html.replace(new RegExp(escapedUrl, 'g'), croppedImageUrl);
              quillEditor.root.innerHTML = newHtml;
              found = true;
            } else {
              // Intentar buscar variaciones de la URL
              const urlParts = currentImageUrl.split('/');
              const imageId = urlParts[urlParts.length - 1].split('?')[0]; // Remover query params
              console.log('[Image Edit] Method 4: Trying to find by image ID:', imageId);
              
              if (html.includes(imageId)) {
                // Buscar el src que contiene este ID
                const imgRegex = new RegExp(`(<img[^>]*src=["'])([^"']]*${imageId}[^"']*)(["'][^>]*>)`, 'gi');
                const newHtml = html.replace(imgRegex, function(match, before, src, after) {
                  console.log('[Image Edit] Method 4: Replacing img src:', src, 'with base64');
                  return before + croppedImageUrl + after;
                });
                quillEditor.root.innerHTML = newHtml;
                found = true;
              }
            }
          }
          
          if (!found) {
            console.error('[Image Edit] ERROR: Image not found in editor content');
            console.error('[Image Edit] Original URL:', currentImageUrl);
            console.error('[Image Edit] Current HTML:', quillEditor.root.innerHTML);
            alert('Could not find the image to replace. Please try again.');
            return;
          }
          
          // Actualizar el campo hidden de contenido
          const content = quillEditor.root.innerHTML;
          document.getElementById('content').value = content;
          
          // Verificar que la imagen base64 esté en el contenido
          if (content.includes(croppedImageUrl.substring(0, 50))) {
            console.log('[Image Edit] ✅ Success: Base64 image found in content');
          } else {
            console.warn('[Image Edit] ⚠️ Warning: Base64 image may not be in content');
          }
        }
        
        // Cerrar el modal
        closeImageEditor();
        showMessage('Image edited successfully', 'success');
      }

      // Inicializar event listeners para el editor de imágenes cuando el DOM esté listo
      function initImageEditorListeners() {
        const cropBtn = document.getElementById('image-editor-crop-btn');
        const cancelBtn = document.getElementById('image-editor-cancel-btn');
        const closeBtn = document.getElementById('image-editor-close-btn');
        const modal = document.getElementById('image-editor-modal');
        
        if (cropBtn) {
          cropBtn.addEventListener('click', applyImageEdit);
        }
        if (cancelBtn) {
          cancelBtn.addEventListener('click', closeImageEditor);
        }
        if (closeBtn) {
          closeBtn.addEventListener('click', closeImageEditor);
        }
        if (modal) {
          // Cerrar modal al hacer click fuera
          modal.addEventListener('click', function(e) {
            if (e.target === this) {
              closeImageEditor();
            }
          });
        }
      }
      
      // Inicializar cuando el DOM esté listo
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initImageEditorListeners);
      } else {
        initImageEditorListeners();
      }

      // ==================== EDITOR DE SLIDESHOW ====================
      
      // Función para abrir el editor de slideshow
      function openSlideshowEditor(block, blockIndex) {
        currentSlideshowBlock = JSON.parse(JSON.stringify(block)); // Copia profunda
        currentSlideshowBlockIndex = blockIndex;
        slideshowImageCroppers = {};
        
        const modal = document.getElementById('slideshow-editor-modal');
        if (!modal) {
          console.error('Slideshow editor modal not found');
          return;
        }
        
        // Cargar configuración del bloque
        const config = currentSlideshowBlock.metadata?.slideshowConfig || {};
        const showArrows = config.showArrows !== undefined ? config.showArrows : true;
        const autoplay = config.autoPlay !== undefined ? config.autoPlay : false;
        const interval = config.slideDuration || 5; // En segundos
        
        // Actualizar campos del modal
        document.getElementById('slideshow-modal-show-arrows').checked = showArrows;
        document.getElementById('slideshow-modal-autoplay').checked = autoplay;
        document.getElementById('slideshow-modal-interval').value = interval;
        
        // Mostrar modal
        modal.classList.add('show');
        
        // Esperar a que el modal se renderice antes de inicializar
        setTimeout(() => {
          // Renderizar preview
          renderSlideshowPreviewInModal();
          
          // Renderizar lista de imágenes
          renderSlideshowImagesListInModal();
        }, 100);
      }
      
      // Función para actualizar el preview cuando cambian los settings en el modal
      function updateSlideshowPreviewInModal() {
        renderSlideshowPreviewInModal();
      }
      
      // Función para renderizar el preview del slideshow en el modal
      function renderSlideshowPreviewInModal() {
        const container = document.getElementById('slideshow-preview-container');
        if (!container) return;
        
        // Obtener slides según el contexto (post o bloque)
        let images = [];
        let showArrows = true;
        let autoplay = false;
        let interval = 5; // En segundos
        
        if (currentPostType === 'slideshow') {
          // Para posts de tipo slideshow
          images = slideshowSlides.map(slide => ({ url: slide.imageUrl, caption: slide.caption }));
          showArrows = document.getElementById('slideshow-modal-show-arrows')?.checked !== false;
          autoplay = document.getElementById('slideshow-modal-autoplay')?.checked || false;
          interval = parseInt(document.getElementById('slideshow-modal-interval')?.value) || 5;
        } else if (currentSlideshowBlock) {
          // Para bloques de slideshow
          images = currentSlideshowBlock.metadata?.images || [];
          showArrows = document.getElementById('slideshow-modal-show-arrows')?.checked !== false;
          autoplay = document.getElementById('slideshow-modal-autoplay')?.checked || false;
          interval = parseInt(document.getElementById('slideshow-modal-interval')?.value) || 5;
        }
        
        if (images.length === 0) {
          container.innerHTML = '<p style="text-align: center; color: #999; padding: 40px;">No slides in slideshow. Add slides first.</p>';
          return;
        }
        
        // El frontend decidirá las dimensiones, aquí usamos un aspect ratio por defecto para el preview
        const defaultAspectRatio = 800 / 1200; // Aspect ratio por defecto (2:3)
        
        // Calcular tamaño del preview (máximo 600px de ancho)
        const maxPreviewWidth = 600;
        const previewWidth = Math.min(maxPreviewWidth, container.offsetWidth - 40);
        const previewHeight = previewWidth * defaultAspectRatio;
        
        const slideshowId = `slideshow-preview-${Date.now()}`;
        
        let html = `<div class="slideshow-wrapper" id="${slideshowId}" data-auto-play="${autoplay}" data-slide-duration="${interval}" style="position: relative; width: ${previewWidth}px; height: ${previewHeight}px; margin: 0 auto; background: #f0f0f0; border: 1px solid #000;">`;
        html += `<div class="slideshow-container" style="position: relative; width: 100%; height: 100%; overflow: hidden;">`;
        
        images.forEach((img, index) => {
          const activeClass = index === 0 ? 'active' : '';
          const imgUrl = img.url ? convertImgurUrl(img.url) : '';
          const imgStyle = `position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; display: ${index === 0 ? 'block' : 'none'};`;
          html += `<div class="slideshow-preview-slide ${activeClass}" data-preview-index="${index}" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;">
            ${imgUrl ? `<img src="${escapeHtml(imgUrl)}" style="${imgStyle}" />` : '<div style="width: 100%; height: 100%; background: #ddd; display: flex; align-items: center; justify-content: center; color: #999;">No image</div>'}
            ${img.caption ? `<div style="position: absolute; bottom: 0; left: 0; right: 0; background: rgba(0,0,0,0.7); color: #fff; padding: 8px; font-size: 11px; text-align: center;">${escapeHtml(img.caption)}</div>` : ''}
          </div>`;
        });
        
        html += '</div>';
        
        // Añadir flechas de navegación (solo si showArrows está activado y hay más de una imagen)
        if (images.length > 1 && showArrows) {
          html += `<button class="slideshow-arrow slideshow-prev" aria-label="Previous" style="position: absolute; left: 10px; top: 50%; transform: translateY(-50%); background: rgba(0,0,0,0.7); color: #fff; border: none; padding: 10px 15px; cursor: pointer; font-size: 18px; z-index: 10;">←</button>`;
          html += `<button class="slideshow-arrow slideshow-next" aria-label="Next" style="position: absolute; right: 10px; top: 50%; transform: translateY(-50%); background: rgba(0,0,0,0.7); color: #fff; border: none; padding: 10px 15px; cursor: pointer; font-size: 18px; z-index: 10;">→</button>`;
        }
        
        // Indicadores
        if (images.length > 1) {
          html += '<div class="slideshow-indicators" style="position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%); display: flex; gap: 5px; z-index: 10;">';
          images.forEach((img, index) => {
            const activeClass = index === 0 ? 'active' : '';
            html += `<button class="slideshow-indicator ${activeClass}" data-slide-index="${index}" aria-label="Go to slide ${index + 1}" style="width: 10px; height: 10px; border-radius: 50%; border: 1px solid #000; background: ${index === 0 ? '#000' : 'transparent'}; cursor: pointer; padding: 0;"></button>`;
          });
          html += '</div>';
        }
        
        html += '</div>';
        container.innerHTML = html;
        
        // Inicializar funcionalidad del slideshow (navegación y autoplay)
        // Convertir segundos a milisegundos para el autoplay
        const intervalMs = autoplay ? interval * 1000 : 0;
        initSlideshowPreview(slideshowId, images.length, autoplay, intervalMs, showArrows);
      }
      
      // Función para inicializar el slideshow en el preview
      function initSlideshowPreview(slideshowId, totalSlides, autoplay, interval, showArrows = true) {
        const slideshow = document.getElementById(slideshowId);
        if (!slideshow || totalSlides <= 1) return;
        
        const slides = slideshow.querySelectorAll('.slideshow-preview-slide');
        const prevBtn = slideshow.querySelector('.slideshow-prev');
        const nextBtn = slideshow.querySelector('.slideshow-next');
        const indicators = slideshow.querySelectorAll('.slideshow-indicator');
        
        // Ocultar flechas si showArrows es false
        if (!showArrows) {
          if (prevBtn) prevBtn.style.display = 'none';
          if (nextBtn) nextBtn.style.display = 'none';
        }
        
        let currentIndex = 0;
        let autoPlayInterval = null;
        
        // Función para mostrar un slide específico
        function showSlide(index) {
          slides.forEach((slide, i) => {
            slide.classList.remove('active');
            const img = slide.querySelector('img');
            if (img) img.style.display = i === index ? 'block' : 'none';
          });
          
          indicators.forEach((indicator, i) => {
            indicator.classList.remove('active');
            indicator.style.background = i === index ? '#000' : 'transparent';
          });
          
          currentIndex = index;
        }
        
        // Función para siguiente slide
        function nextSlide() {
          const nextIndex = (currentIndex + 1) % totalSlides;
          showSlide(nextIndex);
        }
        
        // Función para slide anterior
        function prevSlide() {
          const prevIndex = (currentIndex - 1 + totalSlides) % totalSlides;
          showSlide(prevIndex);
        }
        
        // Función para iniciar autoplay
        function startAutoPlay() {
          if (autoPlayInterval) clearInterval(autoPlayInterval);
          if (autoplay && interval > 0) {
            autoPlayInterval = setInterval(nextSlide, interval);
          }
        }
        
        // Event listeners para flechas
        if (prevBtn && showArrows) {
          prevBtn.addEventListener('click', () => {
            if (autoPlayInterval) clearInterval(autoPlayInterval);
            prevSlide();
            if (autoplay) startAutoPlay();
          });
        }
        
        if (nextBtn && showArrows) {
          nextBtn.addEventListener('click', () => {
            if (autoPlayInterval) clearInterval(autoPlayInterval);
            nextSlide();
            if (autoplay) startAutoPlay();
          });
        }
        
        // Event listeners para indicadores
        indicators.forEach((indicator, index) => {
          indicator.addEventListener('click', () => {
            if (autoPlayInterval) clearInterval(autoPlayInterval);
            showSlide(index);
            if (autoplay) startAutoPlay();
          });
        });
        
        // Iniciar autoplay si está habilitado
        if (autoplay) {
          startAutoPlay();
        }
        
        // Pausar autoplay al pasar el mouse
        slideshow.addEventListener('mouseenter', () => {
          if (autoPlayInterval) clearInterval(autoPlayInterval);
        });
        
        slideshow.addEventListener('mouseleave', () => {
          if (autoplay) startAutoPlay();
        });
      }
      
      // Función para renderizar la lista de imágenes en el modal
      function renderSlideshowImagesListInModal() {
        const container = document.getElementById('slideshow-images-editor-list');
        if (!container) return;
        
        // Obtener imágenes según el contexto (post o bloque)
        let images = [];
        if (currentPostType === 'slideshow') {
          // Para posts de tipo slideshow
          images = slideshowSlides.map((slide, index) => ({
            url: slide.imageUrl,
            caption: slide.caption || '',
            index: index
          }));
        } else if (currentSlideshowBlock) {
          // Para bloques de slideshow (legacy)
          images = (currentSlideshowBlock.metadata?.images || []).map((img, index) => ({
            url: img.url,
            caption: img.caption || '',
            index: index
          }));
        }
        
        if (images.length === 0) {
          container.innerHTML = '<p style="text-align: center; color: #999; padding: 20px;">No images in slideshow. Add images first.</p>';
          return;
        }
        
        // El frontend decidirá las dimensiones, aquí usamos un aspect ratio por defecto para el cropper
        const defaultAspectRatio = 1200 / 800; // Aspect ratio por defecto (3:2)
        
        let html = '';
        images.forEach((img, index) => {
          const imgUrl = img.url ? convertImgurUrl(img.url) : '';
          html += `
            <div class="slideshow-image-editor-item" data-image-index="${index}" style="border: 1px solid #ddd; padding: 15px; background: #fff;">
              <div style="margin-bottom: 10px;">
                <label style="font-size: 11px; text-transform: uppercase; font-weight: bold;">Image ${index + 1}</label>
              </div>
              <div style="position: relative; width: 100%; padding-bottom: ${(1 / defaultAspectRatio) * 100}%; background: #f0f0f0; margin-bottom: 10px; border: 1px solid #000; overflow: hidden;">
                <div id="slideshow-cropper-${index}" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;">
                  ${imgUrl ? `<img id="slideshow-img-${index}" src="${escapeHtml(imgUrl)}" style="max-width: 100%; max-height: 100%;" />` : '<div style="width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; color: #999;">No image</div>'}
                </div>
              </div>
              <div style="margin-bottom: 10px;">
                <label style="display: block; margin-bottom: 5px; font-size: 10px; color: #666;">Caption</label>
                <input type="text" class="slideshow-image-caption-input" data-image-index="${index}" value="${escapeHtml(img.caption || '')}" placeholder="Image caption..." style="width: 100%; padding: 6px; border: 1px solid #000; font-size: 12px;" />
              </div>
              <button class="slideshow-crop-image-btn" data-image-index="${index}" style="width: 100%; padding: 8px; background: #000; color: #fff; border: 1px solid #000; cursor: pointer; font-size: 10px; text-transform: uppercase;">Crop Image</button>
            </div>
          `;
        });
        
        container.innerHTML = html;
        
        // Inicializar croppers para cada imagen
        images.forEach((img, index) => {
          const imgElement = document.getElementById(`slideshow-img-${index}`);
          if (imgElement && img.url) {
            setTimeout(() => {
              if (slideshowImageCroppers[index]) {
                slideshowImageCroppers[index].destroy();
              }
              slideshowImageCroppers[index] = new Cropper(imgElement, {
                aspectRatio: defaultAspectRatio,
                viewMode: 1,
                dragMode: 'move',
                autoCropArea: 0.8,
                restore: false,
                guides: true,
                center: true,
                highlight: false,
                cropBoxMovable: true,
                cropBoxResizable: true,
                toggleable: true,
                minCropBoxWidth: 50,
                minCropBoxHeight: 50,
              });
            }, 100 * (index + 1));
          }
        });
        
        // Event listeners para captions
        container.querySelectorAll('.slideshow-image-caption-input').forEach(input => {
          input.addEventListener('input', (e) => {
            const imgIndex = parseInt(e.target.dataset.imageIndex);
            if (currentPostType === 'slideshow') {
              // Actualizar caption en slideshowSlides
              if (slideshowSlides[imgIndex]) {
                slideshowSlides[imgIndex].caption = e.target.value;
              }
            } else if (currentSlideshowBlock && currentSlideshowBlock.metadata?.images) {
              // Actualizar caption en bloque
              if (currentSlideshowBlock.metadata.images[imgIndex]) {
                currentSlideshowBlock.metadata.images[imgIndex].caption = e.target.value;
              }
            }
            renderSlideshowPreviewInModal();
          });
        });
        
        // Event listeners para botones de crop
        container.querySelectorAll('.slideshow-crop-image-btn').forEach(btn => {
          btn.addEventListener('click', (e) => {
            const imgIndex = parseInt(e.target.dataset.imageIndex);
            cropSlideshowImageInModal(imgIndex);
          });
        });
      }
      
      // Función para recortar una imagen del slideshow en el modal
      function cropSlideshowImageInModal(imageIndex) {
        const cropper = slideshowImageCroppers[imageIndex];
        if (!cropper) {
          alert('Please wait for the image to load');
          return;
        }
        
        const canvas = cropper.getCroppedCanvas({
          imageSmoothingEnabled: true,
          imageSmoothingQuality: 'high',
        });
        
        if (!canvas) {
          alert('Error creating cropped image');
          return;
        }
        
        const croppedImageUrl = canvas.toDataURL('image/jpeg', 0.9);
        
        // Actualizar la imagen según el contexto
        if (currentPostType === 'slideshow') {
          // Actualizar en slideshowSlides
          if (slideshowSlides[imageIndex]) {
            slideshowSlides[imageIndex].imageUrl = croppedImageUrl;
          }
        } else if (currentSlideshowBlock && currentSlideshowBlock.metadata?.images) {
          // Actualizar en bloque
          if (currentSlideshowBlock.metadata.images[imageIndex]) {
            currentSlideshowBlock.metadata.images[imageIndex].url = croppedImageUrl;
          }
        }
        
        // Re-renderizar preview y lista
        renderSlideshowPreviewInModal();
        renderSlideshowImagesListInModal();
        
        showMessage('Image cropped successfully', 'success');
      }
      
      // Función para renderizar el preview del slideshow (legacy, para bloques)
      function renderSlideshowPreview() {
        const container = document.getElementById('slideshow-preview-container');
        if (!container) return;
        
        const images = currentSlideshowBlock.metadata?.images || [];
        const config = currentSlideshowBlock.metadata?.slideshowConfig || {};
        const width = parseInt(document.getElementById('slideshow-global-width').value) || config.imageWidth || 1200;
        const height = parseInt(document.getElementById('slideshow-global-height').value) || config.imageHeight || 800;
        const aspectRatio = height / width;
        
        // Actualizar display de dimensiones
        const dimensionsDisplay = document.getElementById('slideshow-preview-dimensions');
        if (dimensionsDisplay) {
          dimensionsDisplay.textContent = `Dimensions: ${width} × ${height}px`;
        }
        
        // Calcular tamaño del preview (máximo 600px de ancho, mantener aspect ratio)
        const maxPreviewWidth = 600;
        const previewWidth = Math.min(maxPreviewWidth, container.offsetWidth - 40);
        const previewHeight = previewWidth * aspectRatio;
        
        let html = `<div style="position: relative; width: ${previewWidth}px; height: ${previewHeight}px; margin: 0 auto; background: #f0f0f0;">`;
        
        images.forEach((img, index) => {
          const activeClass = index === 0 ? 'active' : '';
          const imgUrl = img.url ? convertImgurUrl(img.url) : '';
          const imgStyle = `position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; display: ${index === 0 ? 'block' : 'none'};`;
          html += `<div class="slideshow-preview-slide ${activeClass}" data-preview-index="${index}" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;">
            ${imgUrl ? `<img src="${escapeHtml(imgUrl)}" style="${imgStyle}" />` : '<div style="width: 100%; height: 100%; background: #ddd; display: flex; align-items: center; justify-content: center; color: #999;">No image</div>'}
            ${img.caption ? `<div style="position: absolute; bottom: 0; left: 0; right: 0; background: rgba(0,0,0,0.7); color: #fff; padding: 8px; font-size: 11px; text-align: center;">${escapeHtml(img.caption)}</div>` : ''}
          </div>`;
        });
        
        // Añadir controles de navegación
        if (images.length > 1) {
          html += `<div style="position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%); display: flex; gap: 5px; z-index: 10;">`;
          images.forEach((img, index) => {
            const activeClass = index === 0 ? 'active' : '';
            html += `<button class="slideshow-preview-indicator ${activeClass}" data-preview-index="${index}" style="width: 10px; height: 10px; border-radius: 50%; border: 1px solid #000; background: ${index === 0 ? '#000' : 'transparent'}; cursor: pointer; padding: 0;"></button>`;
          });
          html += `</div>`;
        }
        
        html += `</div>`;
        container.innerHTML = html;
        
        // Añadir event listeners para navegación
        container.querySelectorAll('.slideshow-preview-indicator').forEach(btn => {
          btn.addEventListener('click', (e) => {
            const index = parseInt(e.target.dataset.previewIndex);
            showPreviewSlide(index);
          });
        });
      }
      
      // Función para mostrar un slide específico en el preview
      function showPreviewSlide(index) {
        const container = document.getElementById('slideshow-preview-container');
        if (!container) return;
        
        container.querySelectorAll('.slideshow-preview-slide').forEach((slide, i) => {
          slide.classList.remove('active');
          const img = slide.querySelector('img');
          if (img) img.style.display = i === index ? 'block' : 'none';
        });
        
        container.querySelectorAll('.slideshow-preview-indicator').forEach((indicator, i) => {
          indicator.classList.remove('active');
          indicator.style.background = i === index ? '#000' : 'transparent';
        });
      }
      
      // Función para renderizar la lista de imágenes editables
      function renderSlideshowImagesList() {
        const container = document.getElementById('slideshow-images-editor-list');
        if (!container) return;
        
        const images = currentSlideshowBlock.metadata?.images || [];
        const config = currentSlideshowBlock.metadata?.slideshowConfig || {};
        const width = parseInt(document.getElementById('slideshow-global-width').value) || config.imageWidth || 1200;
        const height = parseInt(document.getElementById('slideshow-global-height').value) || config.imageHeight || 800;
        const aspectRatio = height / width;
        
        if (images.length === 0) {
          container.innerHTML = '<p style="text-align: center; color: #999; padding: 20px;">No images in slideshow. Add images first.</p>';
          return;
        }
        
        let html = '';
        images.forEach((img, index) => {
          const imgUrl = img.url ? convertImgurUrl(img.url) : '';
          html += `
            <div class="slideshow-image-editor-item" data-image-index="${index}" style="border: 1px solid #ddd; padding: 15px; background: #fff;">
              <div style="margin-bottom: 10px;">
                <label style="font-size: 11px; text-transform: uppercase; font-weight: bold;">Image ${index + 1}</label>
              </div>
              <div style="position: relative; width: 100%; padding-bottom: ${aspectRatio * 100}%; background: #f0f0f0; margin-bottom: 10px; border: 1px solid #000;">
                <div id="slideshow-cropper-${index}" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;">
                  ${imgUrl ? `<img id="slideshow-img-${index}" src="${escapeHtml(imgUrl)}" style="max-width: 100%; max-height: 100%;" />` : '<div style="width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; color: #999;">No image</div>'}
                </div>
              </div>
              <div style="margin-bottom: 10px;">
                <label style="display: block; margin-bottom: 5px; font-size: 10px; color: #666;">Caption</label>
                <input type="text" class="slideshow-image-caption-input" data-image-index="${index}" value="${escapeHtml(img.caption || '')}" placeholder="Image caption..." style="width: 100%; padding: 6px; border: 1px solid #000; font-size: 12px;" />
              </div>
              <button class="slideshow-crop-image-btn" data-image-index="${index}" style="width: 100%; padding: 8px; background: #000; color: #fff; border: 1px solid #000; cursor: pointer; font-size: 10px; text-transform: uppercase;">Crop Image</button>
            </div>
          `;
        });
        
        container.innerHTML = html;
        
        // Inicializar croppers para cada imagen
        images.forEach((img, index) => {
          const imgElement = document.getElementById(`slideshow-img-${index}`);
          if (imgElement && img.url) {
            setTimeout(() => {
              if (slideshowImageCroppers[index]) {
                slideshowImageCroppers[index].destroy();
              }
              slideshowImageCroppers[index] = new Cropper(imgElement, {
                aspectRatio: aspectRatio,
                viewMode: 1,
                dragMode: 'move',
                autoCropArea: 0.8,
                restore: false,
                guides: true,
                center: true,
                highlight: false,
                cropBoxMovable: true,
                cropBoxResizable: true,
                toggleable: true,
                minCropBoxWidth: 50,
                minCropBoxHeight: 50,
              });
            }, 100 * (index + 1));
          }
        });
        
        // Event listeners para captions
        container.querySelectorAll('.slideshow-image-caption-input').forEach(input => {
          input.addEventListener('input', (e) => {
            const imgIndex = parseInt(e.target.dataset.imageIndex);
            if (currentSlideshowBlock.metadata.images[imgIndex]) {
              currentSlideshowBlock.metadata.images[imgIndex].caption = e.target.value;
            }
          });
        });
        
        // Event listeners para botones de crop
        container.querySelectorAll('.slideshow-crop-image-btn').forEach(btn => {
          btn.addEventListener('click', (e) => {
            const imgIndex = parseInt(e.target.dataset.imageIndex);
            cropSlideshowImage(imgIndex);
          });
        });
      }
      
      // Función para recortar una imagen del slideshow
      function cropSlideshowImage(imageIndex) {
        const cropper = slideshowImageCroppers[imageIndex];
        if (!cropper) {
          alert('Please wait for the image to load');
          return;
        }
        
        const canvas = cropper.getCroppedCanvas({
          imageSmoothingEnabled: true,
          imageSmoothingQuality: 'high',
        });
        
        if (!canvas) {
          alert('Error creating cropped image');
          return;
        }
        
        const croppedImageUrl = canvas.toDataURL('image/jpeg', 0.9);
        
        // Actualizar la imagen en el bloque
        if (currentSlideshowBlock.metadata.images[imageIndex]) {
          currentSlideshowBlock.metadata.images[imageIndex].url = croppedImageUrl;
        }
        
        // Actualizar el preview y la lista
        renderSlideshowPreview();
        renderSlideshowImagesList();
        
        showMessage('Image cropped successfully', 'success');
      }
      
      // Función para aplicar dimensiones globales
      function applySlideshowDimensions() {
        const width = parseInt(document.getElementById('slideshow-global-width').value);
        const height = parseInt(document.getElementById('slideshow-global-height').value);
        
        if (!width || !height || width < 100 || height < 100) {
          alert('Please enter valid dimensions (min 100px)');
          return;
        }
        
        if (!currentSlideshowBlock.metadata) {
          currentSlideshowBlock.metadata = {};
        }
        if (!currentSlideshowBlock.metadata.slideshowConfig) {
          currentSlideshowBlock.metadata.slideshowConfig = {};
        }
        
        currentSlideshowBlock.metadata.slideshowConfig.imageWidth = width;
        currentSlideshowBlock.metadata.slideshowConfig.imageHeight = height;
        
        // Re-renderizar con nuevas dimensiones
        renderSlideshowPreview();
        renderSlideshowImagesList();
        
        showMessage('Dimensions applied. Images will be cropped to these dimensions.', 'success');
      }
      
      // Función para guardar cambios del slideshow
      function saveSlideshowChanges() {
        if (currentPostType === 'slideshow') {
          // Guardar cambios para un post de tipo slideshow
          const autoplay = document.getElementById('slideshow-modal-autoplay').checked;
          const interval = parseInt(document.getElementById('slideshow-modal-interval').value) || 5000;
          
          // Actualizar los campos del editor principal
          document.getElementById('slideshow-autoplay').checked = autoplay;
          document.getElementById('slideshow-interval').value = interval;
          
          // Cerrar modal
          closeSlideshowEditor();
          
          // Actualizar preview en el editor principal
          updateSlideshowPreview();
          
          showMessage('Slideshow settings saved', 'success');
        } else if (currentSlideshowBlock && currentSlideshowBlockIndex !== null) {
          // Guardar cambios para un bloque de slideshow
          const originalBlock = postBlocks[currentSlideshowBlockIndex];
          
          // Actualizar configuración desde el modal
          const showArrows = document.getElementById('slideshow-modal-show-arrows').checked;
          const autoplay = document.getElementById('slideshow-modal-autoplay').checked;
          const interval = parseInt(document.getElementById('slideshow-modal-interval').value) || 5; // En segundos
          
          // Asegurar que metadata y slideshowConfig existan
          if (!originalBlock.metadata) originalBlock.metadata = {};
          if (!originalBlock.metadata.slideshowConfig) originalBlock.metadata.slideshowConfig = {};
          
          // Actualizar configuración
          originalBlock.metadata.slideshowConfig.showArrows = showArrows;
          originalBlock.metadata.slideshowConfig.autoPlay = autoplay;
          originalBlock.metadata.slideshowConfig.slideDuration = interval; // Ya está en segundos
          
          // Actualizar imágenes desde el bloque temporal
          if (currentSlideshowBlock.metadata && currentSlideshowBlock.metadata.images) {
            originalBlock.metadata.images = JSON.parse(JSON.stringify(currentSlideshowBlock.metadata.images));
          }
          
          // Cerrar modal
          closeSlideshowEditor();
          
          // Re-renderizar bloques
          renderBlocks();
          
          showMessage('Slideshow changes saved', 'success');
        }
      }
      
      // Función para cerrar el editor de slideshow
      function closeSlideshowEditor() {
        const modal = document.getElementById('slideshow-editor-modal');
        if (modal) {
          modal.classList.remove('show');
        }
        
        // Destruir todos los croppers
        Object.values(slideshowImageCroppers).forEach(cropper => {
          if (cropper) cropper.destroy();
        });
        slideshowImageCroppers = {};
        
        // Limpiar estado (solo para bloques, no para posts)
        if (currentSlideshowBlockIndex !== null) {
          currentSlideshowBlock = null;
          currentSlideshowBlockIndex = null;
        }
      }
      
      // Inicializar event listeners del editor de slideshow
      function initSlideshowEditorListeners() {
        const modal = document.getElementById('slideshow-editor-modal');
        const closeBtn = document.getElementById('slideshow-editor-close-btn');
        const cancelBtn = document.getElementById('slideshow-editor-cancel-btn');
        const saveBtn = document.getElementById('slideshow-editor-save-btn');
        
        if (closeBtn) {
          closeBtn.addEventListener('click', closeSlideshowEditor);
        }
        if (cancelBtn) {
          cancelBtn.addEventListener('click', closeSlideshowEditor);
        }
        if (saveBtn) {
          saveBtn.addEventListener('click', saveSlideshowChanges);
        }
        if (modal) {
          modal.addEventListener('click', function(e) {
            if (e.target === this) {
              closeSlideshowEditor();
            }
          });
        }
        
        // Los event listeners para autoplay e interval se añaden en renderSlideshowSlides()
        // para que se actualicen cuando cambian los settings del modal
      }
      
      // Función para inicializar el control interactivo de dimensiones
      function initDimensionCropper() {
        const container = document.getElementById('slideshow-dimension-cropper-container');
        const cropperArea = document.getElementById('slideshow-dimension-cropper');
        const handle = document.getElementById('slideshow-dimension-cropper-handle');
        
        if (!container || !cropperArea || !handle) return;
        
        let isDragging = false;
        let dragType = null; // 'move', 'resize-se', 'resize-sw', 'resize-ne', 'resize-nw'
        let startX = 0;
        let startY = 0;
        let startWidth = 0;
        let startHeight = 0;
        let startLeft = 0;
        let startTop = 0;
        
        const containerRect = container.getBoundingClientRect();
        const maxWidth = containerRect.width;
        const maxHeight = containerRect.height;
        
        // Función para actualizar el cropper visual basado en los valores de width/height
        function updateDimensionCropper() {
          const width = parseInt(document.getElementById('slideshow-global-width').value) || 1200;
          const height = parseInt(document.getElementById('slideshow-global-height').value) || 800;
          const aspectRatio = height / width;
          
          // Calcular tamaño visual (máximo 80% del contenedor)
          const maxSize = Math.min(maxWidth * 0.8, maxHeight * 0.8);
          const visualWidth = Math.min(maxSize, width / 2); // Escalar para que sea visible
          const visualHeight = visualWidth * aspectRatio;
          
          if (visualHeight > maxHeight * 0.8) {
            const adjustedHeight = maxHeight * 0.8;
            const adjustedWidth = adjustedHeight / aspectRatio;
            handle.style.width = adjustedWidth + 'px';
            handle.style.height = adjustedHeight + 'px';
          } else {
            handle.style.width = visualWidth + 'px';
            handle.style.height = visualHeight + 'px';
          }
          
          // Centrar
          handle.style.left = '50%';
          handle.style.top = '50%';
          handle.style.transform = 'translate(-50%, -50%)';
          
          // Actualizar display
          const display = document.getElementById('slideshow-dimension-display');
          if (display) {
            display.textContent = `${width} × ${height}`;
          }
          
          // Sincronizar la imagen dentro del recuadro con la imagen de fondo
          const previewImg = document.getElementById('slideshow-dimension-preview-img');
          const cropperImg = document.getElementById('slideshow-dimension-cropper-img');
          const cropperArea = document.getElementById('slideshow-dimension-cropper');
          
          if (previewImg && cropperImg && cropperArea && previewImg.src) {
            // Obtener dimensiones del área y del recuadro
            const areaRect = cropperArea.getBoundingClientRect();
            const handleRect = handle.getBoundingClientRect();
            
            if (areaRect.width > 0 && areaRect.height > 0) {
              // Calcular la posición relativa del recuadro
              const offsetX = handleRect.left - areaRect.left;
              const offsetY = handleRect.top - areaRect.top;
              
              // Calcular porcentajes
              const percentX = (offsetX / areaRect.width) * 100;
              const percentY = (offsetY / areaRect.height) * 100;
              
              // Calcular escala necesaria para que la imagen dentro del recuadro muestre la porción correcta
              const handleWidthPercent = (handleRect.width / areaRect.width) * 100;
              const handleHeightPercent = (handleRect.height / areaRect.height) * 100;
              
              const scaleX = 100 / handleWidthPercent;
              const scaleY = 100 / handleHeightPercent;
              
              // Calcular object-position para que muestre la misma porción que el fondo
              const objectX = 50 - (percentX - 50) * scaleX;
              const objectY = 50 - (percentY - 50) * scaleY;
              
              // Aplicar estilos
              cropperImg.style.objectPosition = `${objectX}% ${objectY}%`;
              cropperImg.style.width = `${scaleX * 100}%`;
              cropperImg.style.height = `${scaleY * 100}%`;
              cropperImg.style.left = `${-scaleX * 50 + 50}%`;
              cropperImg.style.top = `${-scaleY * 50 + 50}%`;
              cropperImg.style.objectFit = 'cover';
            }
          }
        }
        
        // Inicializar tamaño
        updateDimensionCropper();
        
        // Función para convertir posición visual a dimensiones reales
        function visualToRealDimensions(visualWidth, visualHeight) {
          // El área visual representa las dimensiones, necesitamos escalar
          const baseScale = 2; // Factor de escala (ajustar según necesidad)
          const realWidth = Math.round(visualWidth * baseScale);
          const realHeight = Math.round(visualHeight * baseScale);
          return { width: Math.max(100, Math.min(5000, realWidth)), height: Math.max(100, Math.min(5000, realHeight)) };
        }
        
        // Función para convertir dimensiones reales a visuales
        function realToVisualDimensions(realWidth, realHeight) {
          const baseScale = 2;
          return { width: realWidth / baseScale, height: realHeight / baseScale };
        }
        
        // Event listeners para handles de redimensionamiento
        handle.querySelectorAll('.dimension-handle').forEach(h => {
          h.addEventListener('mousedown', (e) => {
            e.stopPropagation();
            isDragging = true;
            dragType = h.classList.contains('dimension-handle-se') ? 'resize-se' :
                      h.classList.contains('dimension-handle-sw') ? 'resize-sw' :
                      h.classList.contains('dimension-handle-ne') ? 'resize-ne' : 'resize-nw';
            startX = e.clientX;
            startY = e.clientY;
            const rect = handle.getBoundingClientRect();
            startWidth = rect.width;
            startHeight = rect.height;
            startLeft = rect.left - containerRect.left;
            startTop = rect.top - containerRect.top;
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
          });
        });
        
        // Event listener para mover
        handle.addEventListener('mousedown', (e) => {
          if (e.target === handle || e.target.classList.contains('dimension-handle')) return;
          isDragging = true;
          dragType = 'move';
          startX = e.clientX;
          startY = e.clientY;
          const rect = handle.getBoundingClientRect();
          startLeft = rect.left - containerRect.left;
          startTop = rect.top - containerRect.top;
          document.addEventListener('mousemove', onMouseMove);
          document.addEventListener('mouseup', onMouseUp);
        });
        
        function onMouseMove(e) {
          if (!isDragging) return;
          
          const deltaX = e.clientX - startX;
          const deltaY = e.clientY - startY;
          
          if (dragType === 'move') {
            // Mover el handle (solo visual, no afecta dimensiones)
            const newLeft = Math.max(0, Math.min(maxWidth - parseFloat(handle.style.width), startLeft + deltaX));
            const newTop = Math.max(0, Math.min(maxHeight - parseFloat(handle.style.height), startTop + deltaY));
            handle.style.left = newLeft + 'px';
            handle.style.top = newTop + 'px';
            handle.style.transform = 'none';
            
            // Actualizar sincronización de imágenes durante el movimiento
            requestAnimationFrame(() => {
              updateDimensionCropper();
            });
          } else {
            // Redimensionar
            let newWidth = startWidth;
            let newHeight = startHeight;
            
            if (dragType === 'resize-se') {
              newWidth = Math.max(50, Math.min(maxWidth, startWidth + deltaX));
              newHeight = Math.max(50, Math.min(maxHeight, startHeight + deltaY));
            } else if (dragType === 'resize-sw') {
              newWidth = Math.max(50, Math.min(maxWidth, startWidth - deltaX));
              newHeight = Math.max(50, Math.min(maxHeight, startHeight + deltaY));
            } else if (dragType === 'resize-ne') {
              newWidth = Math.max(50, Math.min(maxWidth, startWidth + deltaX));
              newHeight = Math.max(50, Math.min(maxHeight, startHeight - deltaY));
            } else if (dragType === 'resize-nw') {
              newWidth = Math.max(50, Math.min(maxWidth, startWidth - deltaX));
              newHeight = Math.max(50, Math.min(maxHeight, startHeight - deltaY));
            }
            
            // Mantener aspect ratio si se presiona Shift
            if (e.shiftKey) {
              const aspectRatio = startHeight / startWidth;
              if (Math.abs(deltaX) > Math.abs(deltaY)) {
                newHeight = newWidth * aspectRatio;
              } else {
                newWidth = newHeight / aspectRatio;
              }
            }
            
            handle.style.width = newWidth + 'px';
            handle.style.height = newHeight + 'px';
            
            // Convertir a dimensiones reales y actualizar inputs
            const realDims = visualToRealDimensions(newWidth, newHeight);
            document.getElementById('slideshow-global-width').value = realDims.width;
            document.getElementById('slideshow-global-height').value = realDims.height;
            
            // Actualizar display
            const display = document.getElementById('slideshow-dimension-display');
            if (display) {
              display.textContent = `${realDims.width} × ${realDims.height}`;
            }
            
            // Actualizar preview y lista
            if (currentSlideshowBlock) {
              renderSlideshowPreview();
              renderSlideshowImagesList();
            }
          }
        }
        
        function onMouseUp() {
          isDragging = false;
          dragType = null;
          document.removeEventListener('mousemove', onMouseMove);
          document.removeEventListener('mouseup', onMouseUp);
          
          // Actualizar sincronización de imágenes después de mover/redimensionar
          updateDimensionCropper();
          
          // Actualizar preview y lista después de terminar el movimiento
          if (currentSlideshowBlock) {
            renderSlideshowPreview();
            renderSlideshowImagesList();
          }
        }
        
        // Hacer la función updateDimensionCropper accesible globalmente
        window.updateDimensionCropper = updateDimensionCropper;
      }
      
      // Inicializar cuando el DOM esté listo
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initSlideshowEditorListeners);
      } else {
        initSlideshowEditorListeners();
      }


      // Event listeners para búsqueda y filtros
      document.getElementById("search-input").addEventListener("input", function(e) {
        currentFilters.search = e.target.value;
        loadPosts(1);
      });

      document.getElementById("filter-published").addEventListener("change", function(e) {
        currentFilters.published = e.target.value;
        loadPosts(1);
      });

      document.getElementById("filter-tag").addEventListener("change", function(e) {
        currentFilters.tagId = e.target.value;
        loadPosts(1);
      });

      document.getElementById("filter-section").addEventListener("change", function(e) {
        currentFilters.sectionId = e.target.value;
        loadPosts(1);
      });

      document.getElementById("clear-filters").addEventListener("click", function() {
        currentFilters = { search: "", published: "", tagId: "", sectionId: "" };
        document.getElementById("search-input").value = "";
        document.getElementById("filter-published").value = "";
        document.getElementById("filter-tag").value = "";
        document.getElementById("filter-section").value = "";
        loadPosts(1);
      });

      // Event listeners para crear sección
      document.getElementById("create-section-btn")?.addEventListener("click", openCreateSectionModal);
      document.getElementById("create-section-modal-close-btn")?.addEventListener("click", closeCreateSectionModal);
      document.getElementById("create-section-cancel-btn")?.addEventListener("click", closeCreateSectionModal);
      document.getElementById("create-section-form")?.addEventListener("submit", createSection);
      
      // Cerrar modal al hacer clic fuera
      document.getElementById("create-section-modal")?.addEventListener("click", function(e) {
        if (e.target.id === "create-section-modal") {
          closeCreateSectionModal();
        }
      });

      // Event listener para añadir tags
      document.getElementById("tag-input").addEventListener("keypress", function(e) {
        if (e.key === "Enter") {
          e.preventDefault();
          addTag();
        }
      });

      // Event listener para el selector de sección
      document.getElementById("section").addEventListener("change", async function() {
        console.log("[Section Change] Section changed to:", this.value);
        console.log("[Section Change] editingPostId:", editingPostId);
        updateSectionTypeInfo();
        // Cargar template de la sección si existe
        const sectionId = this.value;
        if (sectionId && !editingPostId) {
          // Solo cargar template si estamos creando un nuevo post (no editando)
          // Limpiar bloques existentes primero para que el template pueda cargarse
          console.log("[Section Change] Clearing existing blocks before loading template...");
          postBlocks = [];
          renderBlocks();
          console.log("[Section Change] Loading template for new post...");
          await loadSectionTemplate(sectionId);
        } else {
          console.log("[Section Change] Skipping template load - editingPostId:", editingPostId, "sectionId:", sectionId);
        }
      });
      
      // Función para cargar el template de una sección
      async function loadSectionTemplate(sectionId) {
        try {
          console.log("[Load Template] Loading template for section:", sectionId);
          console.log("[Load Template] Current postBlocks length:", postBlocks.length);
          
          const response = await fetch(`${API_URL}/sections/${sectionId}/template`, {
            credentials: 'include',
          });
          
          console.log("[Load Template] Response status:", response.status);
          
          if (!response.ok) {
            console.log("[Load Template] No template found or error:", response.status);
            const errorText = await response.text();
            console.log("[Load Template] Error response:", errorText);
            return;
          }
          
          const data = await response.json();
          console.log("[Load Template] Template data received:", data);
          
          if (data.blockTemplate && data.blockTemplate.blocks && Array.isArray(data.blockTemplate.blocks)) {
            console.log("[Load Template] Template found with", data.blockTemplate.blocks.length, "blocks");
            
            // Generar bloques desde el template
            const templateBlocks = data.blockTemplate.blocks.map((blockDef, index) => {
              const baseBlock = {
                type: blockDef.type,
                content: "",
                order: index,
                metadata: {
                  required: blockDef.required || false,
                  width: blockDef.width || "full",
                },
              };
              
              // Configuración específica por tipo de bloque
              switch (blockDef.type) {
                case "slideshow":
                  baseBlock.content = "";
                  baseBlock.metadata = {
                    ...baseBlock.metadata,
                    images: [],
                    slideshowConfig: blockDef.settings || {
                      showArrows: true,
                      autoplay: false,
                      interval: 3,
                    },
                  };
                  break;
                case "text":
                  baseBlock.content = "";
                  break;
                case "image":
                  baseBlock.content = "";
                  baseBlock.metadata = {
                    ...baseBlock.metadata,
                    caption: "",
                  };
                  break;
                case "video":
                  baseBlock.content = "";
                  break;
                case "embed_instagram":
                case "embed_soundcloud":
                  baseBlock.content = "";
                  break;
              }
              
              return baseBlock;
            });
            
            console.log("[Load Template] Generated template blocks:", templateBlocks);
            
            // Solo reemplazar bloques si no hay bloques existentes
            if (postBlocks.length === 0) {
              postBlocks = templateBlocks;
              console.log("[Load Template] Setting postBlocks, new length:", postBlocks.length);
              renderBlocks();
              console.log("[Load Template] Template blocks loaded and rendered:", postBlocks.length);
            } else {
              console.log("[Load Template] Skipping template load - postBlocks already has", postBlocks.length, "blocks");
            }
          } else {
            console.log("[Load Template] No template blocks defined (freedom mode)");
            console.log("[Load Template] blockTemplate value:", data.blockTemplate);
          }
        } catch (err) {
          console.error("[Load Template] Error loading template:", err);
          console.error("[Load Template] Error stack:", err.stack);
        }
      }

      // Inicializar: verificar auth y cargar datos
      // Usar una función async auto-ejecutada con manejo de errores
      (async () => {
        try {
          console.log("[Init] Starting initialization...");
          const authenticated = await checkAuth();
          if (authenticated) {
            console.log("[Init] Authenticated, loading data...");
            await loadTags();
            await loadSections();
            loadPosts(1);
            console.log("[Init] ✅ Initialization complete");
          } else {
            console.log("[Init] ⚠️ Not authenticated or initialization failed");
            // No hacer nada más, checkAuth ya maneja las redirecciones
          }
        } catch (err) {
          console.error("[Init] ❌ Error during initialization:", err);
          // No redirigir aquí, checkAuth ya maneja las redirecciones de autenticación
          // Solo loguear el error para debugging
        }
      })();

      // ==================== AUDIT LOGS ====================
      let auditCurrentPage = 1;
      let auditFilters = {
        action: "",
        resource: "",
        startDate: "",
        endDate: "",
      };

      // Abrir modal de audit logs
      function openAuditLogsModal() {
        const modal = document.getElementById("audit-logs-modal");
        if (modal) {
          modal.style.display = "block";
          loadAuditStats();
          loadAuditLogs(1);
        }
      }

      // Cerrar modal de audit logs
      function closeAuditLogsModal() {
        const modal = document.getElementById("audit-logs-modal");
        if (modal) {
          modal.style.display = "none";
        }
      }

      // Cargar estadísticas de auditoría
      async function loadAuditStats() {
        try {
          const res = await fetch(`${API_URL}/audit-logs/stats`, {
            credentials: "include",
          });
          if (res.ok) {
            const stats = await res.json();
            document.getElementById("audit-total-logs").textContent = stats.totalLogs || 0;
            document.getElementById("audit-logs-24h").textContent = stats.logsLast24h || 0;
          }
        } catch (err) {
          console.error("Error loading audit stats:", err);
        }
      }

      // Cargar logs de auditoría
      async function loadAuditLogs(page = 1) {
        try {
          auditCurrentPage = page;
          const params = new URLSearchParams({
            page: page.toString(),
            limit: "50",
          });
          
          if (auditFilters.action) params.append("action", auditFilters.action);
          if (auditFilters.resource) params.append("resource", auditFilters.resource);
          if (auditFilters.startDate) params.append("startDate", auditFilters.startDate);
          if (auditFilters.endDate) params.append("endDate", auditFilters.endDate);
          
          const res = await fetch(`${API_URL}/audit-logs?${params.toString()}`, {
            credentials: "include",
          });
          
          if (res.status === 403) {
            document.getElementById("audit-logs-list").innerHTML = 
              "<p style='padding: 20px; text-align: center; color: #666666;'>Only administrators can view audit logs.</p>";
            return;
          }
          
          if (!res.ok) throw new Error("Failed to load audit logs");
          
          const data = await res.json();
          renderAuditLogs(data.logs || []);
          renderAuditPagination(data.pagination);
        } catch (err) {
          document.getElementById("audit-logs-list").innerHTML = 
            `<p style="padding: 20px; text-align: center; color: #000000; border: 1px solid #000000;">Error loading audit logs: ${err.message}</p>`;
        }
      }

      // Renderizar logs de auditoría
      function renderAuditLogs(logs) {
        const container = document.getElementById("audit-logs-list");
        
        if (!logs || logs.length === 0) {
          container.innerHTML = "<p style='padding: 20px; text-align: center; color: #666666;'>No audit logs found.</p>";
          return;
        }

        container.innerHTML = logs.map(log => {
          const date = new Date(log.createdAt).toLocaleString();
          const userEmail = log.user ? log.user.email : "System";
          const siteName = log.site ? log.site.name : "-";
          const details = log.details ? JSON.stringify(log.details, null, 2) : "";
          
          return `
            <div style="padding: 15px; border-bottom: 1px solid #000000; background: ${log.action.includes('failed') ? '#fff5f5' : '#ffffff'};">
              <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 10px;">
                <div style="flex: 1;">
                  <div style="font-weight: 500; color: #000000; margin-bottom: 5px;">
                    ${escapeHtml(log.action)} ${log.resource ? `on ${escapeHtml(log.resource)}` : ""}
                    ${log.resourceId ? `#${log.resourceId}` : ""}
                  </div>
                  <div style="font-size: 11px; color: #666666; text-transform: uppercase; letter-spacing: 0.5px;">
                    User: ${escapeHtml(userEmail)} | Site: ${escapeHtml(siteName)} | ${date}
                  </div>
                  ${log.ipAddress ? `<div style="font-size: 10px; color: #999999; margin-top: 5px;">IP: ${escapeHtml(log.ipAddress)}</div>` : ""}
                </div>
              </div>
              ${details ? `<details style="margin-top: 10px;"><summary style="cursor: pointer; font-size: 11px; color: #666666; text-transform: uppercase; letter-spacing: 0.5px;">Details</summary><pre style="margin-top: 10px; padding: 10px; background: #f5f5f5; border: 1px solid #000000; font-size: 11px; overflow-x: auto;">${escapeHtml(details)}</pre></details>` : ""}
            </div>
          `;
        }).join("");
      }

      // Renderizar paginación de audit logs
      function renderAuditPagination(pagination) {
        const container = document.getElementById("audit-pagination");
        if (!pagination || pagination.totalPages <= 1) {
          container.innerHTML = "";
          return;
        }

        let html = "";
        if (pagination.page > 1) {
          html += `<button onclick="loadAuditLogs(${pagination.page - 1})" style="padding: 8px 16px; background: #ffffff; color: #000000; border: 1px solid #000000; border-radius: 0; cursor: pointer; font-size: 11px; text-transform: uppercase; letter-spacing: 0.5px;">Previous</button>`;
        }
        html += `<span style="padding: 0 15px; font-size: 12px; color: #666666;">Page ${pagination.page} of ${pagination.totalPages}</span>`;
        if (pagination.page < pagination.totalPages) {
          html += `<button onclick="loadAuditLogs(${pagination.page + 1})" style="padding: 8px 16px; background: #000000; color: #ffffff; border: 1px solid #000000; border-radius: 0; cursor: pointer; font-size: 11px; text-transform: uppercase; letter-spacing: 0.5px;">Next</button>`;
        }

        container.innerHTML = html;
      }
      
      // Hacer loadAuditLogs disponible globalmente para onclick
      window.loadAuditLogs = loadAuditLogs;

      // Event listeners para filtros de audit logs
      document.getElementById("audit-apply-filters")?.addEventListener("click", function() {
        auditFilters.action = document.getElementById("audit-filter-action").value;
        auditFilters.resource = document.getElementById("audit-filter-resource").value;
        auditFilters.startDate = document.getElementById("audit-filter-start-date").value;
        auditFilters.endDate = document.getElementById("audit-filter-end-date").value;
        loadAuditLogs(1);
      });

      document.getElementById("audit-clear-filters")?.addEventListener("click", function() {
        document.getElementById("audit-filter-action").value = "";
        document.getElementById("audit-filter-resource").value = "";
        document.getElementById("audit-filter-start-date").value = "";
        document.getElementById("audit-filter-end-date").value = "";
        auditFilters = {
          action: "",
          resource: "",
          startDate: "",
          endDate: "",
        };
        loadAuditLogs(1);
      });

      // Event listener para cerrar el modal de audit logs
      document.getElementById("audit-logs-modal-close-btn")?.addEventListener("click", closeAuditLogsModal);

      // Cerrar modal al hacer clic fuera de él
      document.getElementById("audit-logs-modal")?.addEventListener("click", function(e) {
        if (e.target.id === "audit-logs-modal") {
          closeAuditLogsModal();
        }
      });
    </script>
  </body>
</html>

